; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\stm32f10x_can.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\stm32f10x_can.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I"C:\Users\Kenneth Au\Desktop\toKenneth\Complicated Big Motor Control\(encoder)24V Big Blue Black Motor Control June 7\RTE" -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=513 -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=.\obj\stm32f10x_can.crf FWlib\SRC\stm32f10x_can.c]
                          THUMB

                          AREA ||i.CAN_CancelTransmit||, CODE, READONLY, ALIGN=1

                  CAN_CancelTransmit PROC
;;;556      */
;;;557    void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
000000  b121              CBZ      r1,|L1.12|
;;;558    {
;;;559      /* Check the parameters */
;;;560      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;561      assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
;;;562      /* abort transmission */
;;;563      switch (Mailbox)
000002  2901              CMP      r1,#1
000004  d007              BEQ      |L1.22|
000006  2902              CMP      r1,#2
000008  d10f              BNE      |L1.42|
00000a  e009              B        |L1.32|
                  |L1.12|
;;;564      {
;;;565        case (0): CANx->TSR |= TSR_ABRQ0;
00000c  6882              LDR      r2,[r0,#8]
00000e  f0420280          ORR      r2,r2,#0x80
000012  6082              STR      r2,[r0,#8]
;;;566          break;
000014  e00a              B        |L1.44|
                  |L1.22|
;;;567        case (1): CANx->TSR |= TSR_ABRQ1;
000016  6882              LDR      r2,[r0,#8]
000018  f4424200          ORR      r2,r2,#0x8000
00001c  6082              STR      r2,[r0,#8]
;;;568          break;
00001e  e005              B        |L1.44|
                  |L1.32|
;;;569        case (2): CANx->TSR |= TSR_ABRQ2;
000020  6882              LDR      r2,[r0,#8]
000022  f4420200          ORR      r2,r2,#0x800000
000026  6082              STR      r2,[r0,#8]
;;;570          break;
000028  e000              B        |L1.44|
                  |L1.42|
;;;571        default:
;;;572          break;
00002a  bf00              NOP      
                  |L1.44|
00002c  bf00              NOP                            ;566
;;;573      }
;;;574    }
00002e  4770              BX       lr
;;;575    
                          ENDP


                          AREA ||i.CAN_ClearFlag||, CODE, READONLY, ALIGN=1

                  CAN_ClearFlag PROC
;;;782      */
;;;783    void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
000000  6982              LDR      r2,[r0,#0x18]
;;;784    {
;;;785      /* Check the parameters */
;;;786      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;787      assert_param(IS_CAN_FLAG(CAN_FLAG));
;;;788      /* Clear the selected CAN flags */
;;;789      CANx->ESR &= ~CAN_FLAG;
000002  438a              BICS     r2,r2,r1
000004  6182              STR      r2,[r0,#0x18]
;;;790    }
000006  4770              BX       lr
;;;791    
                          ENDP


                          AREA ||i.CAN_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  CAN_ClearITPendingBit PROC
;;;860      */
;;;861    void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
000000  2940              CMP      r1,#0x40
;;;862    {
;;;863      /* Check the parameters */
;;;864      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;865      assert_param(IS_CAN_ITStatus(CAN_IT));
;;;866      switch (CAN_IT)
000002  d035              BEQ      |L3.112|
000004  dc0e              BGT      |L3.36|
000006  2907              CMP      r1,#7
000008  d025              BEQ      |L3.86|
00000a  dc06              BGT      |L3.26|
00000c  2904              CMP      r1,#4
00000e  d026              BEQ      |L3.94|
000010  2905              CMP      r1,#5
000012  d019              BEQ      |L3.72|
000014  2906              CMP      r1,#6
000016  d143              BNE      |L3.160|
000018  e019              B        |L3.78|
                  |L3.26|
00001a  2908              CMP      r1,#8
00001c  d022              BEQ      |L3.100|
00001e  2920              CMP      r1,#0x20
000020  d13e              BNE      |L3.160|
000022  e022              B        |L3.106|
                  |L3.36|
000024  f5b16f80          CMP      r1,#0x400
000028  d02f              BEQ      |L3.138|
00002a  dc06              BGT      |L3.58|
00002c  f5b17f80          CMP      r1,#0x100
000030  d021              BEQ      |L3.118|
000032  f5b17f00          CMP      r1,#0x200
000036  d133              BNE      |L3.160|
000038  e022              B        |L3.128|
                  |L3.58|
00003a  f5b13f80          CMP      r1,#0x10000
00003e  d029              BEQ      |L3.148|
000040  f5b13f00          CMP      r1,#0x20000
000044  d12c              BNE      |L3.160|
000046  e028              B        |L3.154|
                  |L3.72|
;;;867      {
;;;868        case CAN_IT_RQCP0:
;;;869          CANx->TSR = TSR_RQCP0; /* rc_w1*/
000048  2201              MOVS     r2,#1
00004a  6082              STR      r2,[r0,#8]
;;;870          break;
00004c  e029              B        |L3.162|
                  |L3.78|
;;;871        case CAN_IT_RQCP1:
;;;872          CANx->TSR = TSR_RQCP1; /* rc_w1*/
00004e  f44f7280          MOV      r2,#0x100
000052  6082              STR      r2,[r0,#8]
;;;873          break;
000054  e025              B        |L3.162|
                  |L3.86|
;;;874        case CAN_IT_RQCP2:
;;;875          CANx->TSR = TSR_RQCP2; /* rc_w1*/
000056  f44f3280          MOV      r2,#0x10000
00005a  6082              STR      r2,[r0,#8]
;;;876          break;
00005c  e021              B        |L3.162|
                  |L3.94|
;;;877        case CAN_IT_FF0:
;;;878          CANx->RF0R = RF0R_FULL0; /* rc_w1*/
00005e  2208              MOVS     r2,#8
000060  60c2              STR      r2,[r0,#0xc]
;;;879          break;
000062  e01e              B        |L3.162|
                  |L3.100|
;;;880        case CAN_IT_FOV0:
;;;881          CANx->RF0R = RF0R_FOVR0; /* rc_w1*/
000064  2210              MOVS     r2,#0x10
000066  60c2              STR      r2,[r0,#0xc]
;;;882          break;
000068  e01b              B        |L3.162|
                  |L3.106|
;;;883        case CAN_IT_FF1:
;;;884          CANx->RF1R = RF1R_FULL1; /* rc_w1*/
00006a  2208              MOVS     r2,#8
00006c  6102              STR      r2,[r0,#0x10]
;;;885          break;
00006e  e018              B        |L3.162|
                  |L3.112|
;;;886        case CAN_IT_FOV1:
;;;887          CANx->RF1R = RF1R_FOVR1; /* rc_w1*/
000070  2210              MOVS     r2,#0x10
000072  6102              STR      r2,[r0,#0x10]
;;;888          break;
000074  e015              B        |L3.162|
                  |L3.118|
;;;889        case CAN_IT_EWG:
;;;890          CANx->ESR &= ~ ESR_EWGF; /* rw */
000076  6982              LDR      r2,[r0,#0x18]
000078  f0220201          BIC      r2,r2,#1
00007c  6182              STR      r2,[r0,#0x18]
;;;891          break;
00007e  e010              B        |L3.162|
                  |L3.128|
;;;892        case CAN_IT_EPV:
;;;893          CANx->ESR &= ~ ESR_EPVF; /* rw */
000080  6982              LDR      r2,[r0,#0x18]
000082  f0220202          BIC      r2,r2,#2
000086  6182              STR      r2,[r0,#0x18]
;;;894          break;
000088  e00b              B        |L3.162|
                  |L3.138|
;;;895        case CAN_IT_BOF:
;;;896          CANx->ESR &= ~ ESR_BOFF; /* rw */
00008a  6982              LDR      r2,[r0,#0x18]
00008c  f0220204          BIC      r2,r2,#4
000090  6182              STR      r2,[r0,#0x18]
;;;897          break;
000092  e006              B        |L3.162|
                  |L3.148|
;;;898        case CAN_IT_WKU:
;;;899          CANx->MSR = MSR_WKUI;  /* rc_w1*/
000094  2208              MOVS     r2,#8
000096  6042              STR      r2,[r0,#4]
;;;900          break;
000098  e003              B        |L3.162|
                  |L3.154|
;;;901        case CAN_IT_SLK:
;;;902          CANx->MSR = MSR_SLAKI;  /* rc_w1*/
00009a  2210              MOVS     r2,#0x10
00009c  6042              STR      r2,[r0,#4]
;;;903          break;
00009e  e000              B        |L3.162|
                  |L3.160|
;;;904        default :
;;;905          break;
0000a0  bf00              NOP      
                  |L3.162|
0000a2  bf00              NOP                            ;870
;;;906      }
;;;907    }
0000a4  4770              BX       lr
;;;908    
                          ENDP


                          AREA ||i.CAN_DBGFreeze||, CODE, READONLY, ALIGN=1

                  CAN_DBGFreeze PROC
;;;674      */
;;;675    void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState Newstate)
000000  b121              CBZ      r1,|L4.12|
;;;676    {
;;;677      /* Check the parameters */
;;;678      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;679      assert_param(IS_FUNCTIONAL_STATE(Newstate));
;;;680       if (Newstate != DISABLE)
;;;681      {
;;;682        /* Enable Debug Freeze  */
;;;683        CANx->MCR |= MCR_DBF;
000002  6802              LDR      r2,[r0,#0]
000004  f4423280          ORR      r2,r2,#0x10000
000008  6002              STR      r2,[r0,#0]
00000a  e003              B        |L4.20|
                  |L4.12|
;;;684      }
;;;685      else
;;;686      {
;;;687        /* Disable Debug Freeze */
;;;688        CANx->MCR &= ~MCR_DBF;
00000c  6802              LDR      r2,[r0,#0]
00000e  f4223280          BIC      r2,r2,#0x10000
000012  6002              STR      r2,[r0,#0]
                  |L4.20|
;;;689      }
;;;690    }
000014  4770              BX       lr
;;;691    
                          ENDP


                          AREA ||i.CAN_DeInit||, CODE, READONLY, ALIGN=2

                  CAN_DeInit PROC
;;;143      */
;;;144    void CAN_DeInit(CAN_TypeDef* CANx)
000000  b510              PUSH     {r4,lr}
;;;145    {
000002  4604              MOV      r4,r0
;;;146      /* Check the parameters */
;;;147      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;148     
;;;149      switch (*(uint32_t*)&CANx)
000004  4807              LDR      r0,|L5.36|
000006  4420              ADD      r0,r0,r4
000008  b948              CBNZ     r0,|L5.30|
;;;150      {
;;;151        case CAN1_BASE:
;;;152          /* Enable CAN1 reset state */
;;;153          RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  0648              LSLS     r0,r1,#25
00000e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;154          /* Release CAN1 from reset state */
;;;155          RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
000012  2100              MOVS     r1,#0
000014  f04f7000          MOV      r0,#0x2000000
000018  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;156          break;        
00001c  e000              B        |L5.32|
                  |L5.30|
;;;157        default:
;;;158          break;
00001e  bf00              NOP      
                  |L5.32|
000020  bf00              NOP                            ;156
;;;159      }
;;;160    }
000022  bd10              POP      {r4,pc}
;;;161    
                          ENDP

                  |L5.36|
                          DCD      0xbfff9c00

                          AREA ||i.CAN_FIFORelease||, CODE, READONLY, ALIGN=1

                  CAN_FIFORelease PROC
;;;581      */
;;;582    void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
000000  b911              CBNZ     r1,|L6.8|
;;;583    {
;;;584      /* Check the parameters */
;;;585      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;586      assert_param(IS_CAN_FIFO(FIFONumber));
;;;587      /* Release FIFO0 */
;;;588      if (FIFONumber == CAN_FIFO0)
;;;589      {
;;;590        CANx->RF0R = RF0R_RFOM0;
000002  2220              MOVS     r2,#0x20
000004  60c2              STR      r2,[r0,#0xc]
000006  e001              B        |L6.12|
                  |L6.8|
;;;591      }
;;;592      /* Release FIFO1 */
;;;593      else /* FIFONumber == CAN_FIFO1 */
;;;594      {
;;;595        CANx->RF1R = RF1R_RFOM1;
000008  2220              MOVS     r2,#0x20
00000a  6102              STR      r2,[r0,#0x10]
                  |L6.12|
;;;596      }
;;;597    }
00000c  4770              BX       lr
;;;598    
                          ENDP


                          AREA ||i.CAN_FilterInit||, CODE, READONLY, ALIGN=2

                  CAN_FilterInit PROC
;;;290      */
;;;291    void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
000000  b510              PUSH     {r4,lr}
;;;292    {
;;;293      uint32_t filter_number_bit_pos = 0;
000002  2100              MOVS     r1,#0
;;;294      /* Check the parameters */
;;;295      assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
;;;296      assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
;;;297      assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
;;;298      assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
;;;299      assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
;;;300      filter_number_bit_pos = 
000004  7803              LDRB     r3,[r0,#0]
000006  2201              MOVS     r2,#1
000008  fa02f103          LSL      r1,r2,r3
;;;301      (uint32_t)(((uint32_t)0x00000001) << ((uint32_t)CAN_FilterInitStruct->CAN_FilterNumber));
;;;302      /* Initialisation mode for the filter */
;;;303      CAN1->FMR |= FMR_FINIT;
00000c  4a3d              LDR      r2,|L7.260|
00000e  6812              LDR      r2,[r2,#0]
000010  f0420201          ORR      r2,r2,#1
000014  4b3b              LDR      r3,|L7.260|
000016  601a              STR      r2,[r3,#0]
;;;304      /* Filter Deactivation */
;;;305      CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
000018  4a3a              LDR      r2,|L7.260|
00001a  321c              ADDS     r2,r2,#0x1c
00001c  6812              LDR      r2,[r2,#0]
00001e  438a              BICS     r2,r2,r1
000020  4b38              LDR      r3,|L7.260|
000022  331c              ADDS     r3,r3,#0x1c
000024  601a              STR      r2,[r3,#0]
;;;306      /* Filter Scale */
;;;307      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
000026  7882              LDRB     r2,[r0,#2]
000028  b9ca              CBNZ     r2,|L7.94|
;;;308      {
;;;309        /* 16-bit scale for the filter */
;;;310        CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
00002a  4a36              LDR      r2,|L7.260|
00002c  320c              ADDS     r2,r2,#0xc
00002e  6812              LDR      r2,[r2,#0]
000030  438a              BICS     r2,r2,r1
000032  4b34              LDR      r3,|L7.260|
000034  330c              ADDS     r3,r3,#0xc
000036  601a              STR      r2,[r3,#0]
;;;311        /* First 16-bit identifier and First 16-bit mask */
;;;312        /* Or First 16-bit identifier and Second 16-bit identifier */
;;;313        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
000038  88c2              LDRH     r2,[r0,#6]
00003a  8943              LDRH     r3,[r0,#0xa]
00003c  ea424303          ORR      r3,r2,r3,LSL #16
000040  4a30              LDR      r2,|L7.260|
000042  3240              ADDS     r2,r2,#0x40
000044  7804              LDRB     r4,[r0,#0]
000046  f8423034          STR      r3,[r2,r4,LSL #3]
;;;314        ((uint32_t)((uint32_t)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
;;;315            ((uint32_t)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterIdLow);
;;;316        /* Second 16-bit identifier and Second 16-bit mask */
;;;317        /* Or Third 16-bit identifier and Fourth 16-bit identifier */
;;;318        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
00004a  8882              LDRH     r2,[r0,#4]
00004c  8903              LDRH     r3,[r0,#8]
00004e  ea424303          ORR      r3,r2,r3,LSL #16
000052  4a2c              LDR      r2,|L7.260|
000054  3240              ADDS     r2,r2,#0x40
000056  7804              LDRB     r4,[r0,#0]
000058  eb0202c4          ADD      r2,r2,r4,LSL #3
00005c  6053              STR      r3,[r2,#4]
                  |L7.94|
;;;319        ((uint32_t)((uint32_t)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;320            ((uint32_t)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterIdHigh);
;;;321      }
;;;322      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
00005e  7882              LDRB     r2,[r0,#2]
000060  2a01              CMP      r2,#1
000062  d119              BNE      |L7.152|
;;;323      {
;;;324        /* 32-bit scale for the filter */
;;;325        CAN1->FS1R |= filter_number_bit_pos;
000064  4a27              LDR      r2,|L7.260|
000066  320c              ADDS     r2,r2,#0xc
000068  6812              LDR      r2,[r2,#0]
00006a  430a              ORRS     r2,r2,r1
00006c  4b25              LDR      r3,|L7.260|
00006e  330c              ADDS     r3,r3,#0xc
000070  601a              STR      r2,[r3,#0]
;;;326        /* 32-bit identifier or First 32-bit identifier */
;;;327        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
000072  88c2              LDRH     r2,[r0,#6]
000074  8883              LDRH     r3,[r0,#4]
000076  ea424303          ORR      r3,r2,r3,LSL #16
00007a  4a22              LDR      r2,|L7.260|
00007c  3240              ADDS     r2,r2,#0x40
00007e  7804              LDRB     r4,[r0,#0]
000080  f8423034          STR      r3,[r2,r4,LSL #3]
;;;328        ((uint32_t)((uint32_t)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
;;;329            ((uint32_t)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterIdLow);
;;;330        /* 32-bit mask or Second 32-bit identifier */
;;;331        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
000084  8942              LDRH     r2,[r0,#0xa]
000086  8903              LDRH     r3,[r0,#8]
000088  ea424303          ORR      r3,r2,r3,LSL #16
00008c  4a1d              LDR      r2,|L7.260|
00008e  3240              ADDS     r2,r2,#0x40
000090  7804              LDRB     r4,[r0,#0]
000092  eb0202c4          ADD      r2,r2,r4,LSL #3
000096  6053              STR      r3,[r2,#4]
                  |L7.152|
;;;332        ((uint32_t)((uint32_t)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;333            ((uint32_t)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterMaskIdLow);
;;;334      }
;;;335      /* Filter Mode */
;;;336      if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
000098  7842              LDRB     r2,[r0,#1]
00009a  b93a              CBNZ     r2,|L7.172|
;;;337      {
;;;338        /*Id/Mask mode for the filter*/
;;;339        CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
00009c  4a19              LDR      r2,|L7.260|
00009e  1d12              ADDS     r2,r2,#4
0000a0  6812              LDR      r2,[r2,#0]
0000a2  438a              BICS     r2,r2,r1
0000a4  4b17              LDR      r3,|L7.260|
0000a6  1d1b              ADDS     r3,r3,#4
0000a8  601a              STR      r2,[r3,#0]
0000aa  e006              B        |L7.186|
                  |L7.172|
;;;340      }
;;;341      else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
;;;342      {
;;;343        /*Identifier list mode for the filter*/
;;;344        CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
0000ac  4a15              LDR      r2,|L7.260|
0000ae  1d12              ADDS     r2,r2,#4
0000b0  6812              LDR      r2,[r2,#0]
0000b2  430a              ORRS     r2,r2,r1
0000b4  4b13              LDR      r3,|L7.260|
0000b6  1d1b              ADDS     r3,r3,#4
0000b8  601a              STR      r2,[r3,#0]
                  |L7.186|
;;;345      }
;;;346      /* Filter FIFO assignment */
;;;347      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_FilterFIFO0)
0000ba  8982              LDRH     r2,[r0,#0xc]
0000bc  b932              CBNZ     r2,|L7.204|
;;;348      {
;;;349        /* FIFO 0 assignation for the filter */
;;;350        CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
0000be  4a11              LDR      r2,|L7.260|
0000c0  3214              ADDS     r2,r2,#0x14
0000c2  6812              LDR      r2,[r2,#0]
0000c4  438a              BICS     r2,r2,r1
0000c6  4b0f              LDR      r3,|L7.260|
0000c8  3314              ADDS     r3,r3,#0x14
0000ca  601a              STR      r2,[r3,#0]
                  |L7.204|
;;;351      }
;;;352      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_FilterFIFO1)
0000cc  8982              LDRH     r2,[r0,#0xc]
0000ce  2a01              CMP      r2,#1
0000d0  d106              BNE      |L7.224|
;;;353      {
;;;354        /* FIFO 1 assignation for the filter */
;;;355        CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
0000d2  4a0c              LDR      r2,|L7.260|
0000d4  3214              ADDS     r2,r2,#0x14
0000d6  6812              LDR      r2,[r2,#0]
0000d8  430a              ORRS     r2,r2,r1
0000da  4b0a              LDR      r3,|L7.260|
0000dc  3314              ADDS     r3,r3,#0x14
0000de  601a              STR      r2,[r3,#0]
                  |L7.224|
;;;356      }
;;;357      
;;;358      /* Filter activation */
;;;359      if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
0000e0  7b82              LDRB     r2,[r0,#0xe]
0000e2  2a01              CMP      r2,#1
0000e4  d106              BNE      |L7.244|
;;;360      {
;;;361        CAN1->FA1R |= filter_number_bit_pos;
0000e6  4a07              LDR      r2,|L7.260|
0000e8  321c              ADDS     r2,r2,#0x1c
0000ea  6812              LDR      r2,[r2,#0]
0000ec  430a              ORRS     r2,r2,r1
0000ee  4b05              LDR      r3,|L7.260|
0000f0  331c              ADDS     r3,r3,#0x1c
0000f2  601a              STR      r2,[r3,#0]
                  |L7.244|
;;;362      }
;;;363      /* Leave the initialisation mode for the filter */
;;;364      CAN1->FMR &= ~FMR_FINIT;
0000f4  4a03              LDR      r2,|L7.260|
0000f6  6812              LDR      r2,[r2,#0]
0000f8  f0220201          BIC      r2,r2,#1
0000fc  4b01              LDR      r3,|L7.260|
0000fe  601a              STR      r2,[r3,#0]
;;;365    }
000100  bd10              POP      {r4,pc}
;;;366    
                          ENDP

000102  0000              DCW      0x0000
                  |L7.260|
                          DCD      0x40006600

                          AREA ||i.CAN_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  CAN_GetFlagStatus PROC
;;;755      */
;;;756    FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
000000  4602              MOV      r2,r0
;;;757    {
;;;758      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;759      /* Check the parameters */
;;;760      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;761      assert_param(IS_CAN_FLAG(CAN_FLAG));
;;;762      /* Check the status of the specified CAN flag */
;;;763      if ((CANx->ESR & CAN_FLAG) != (uint32_t)RESET)
000004  6993              LDR      r3,[r2,#0x18]
000006  400b              ANDS     r3,r3,r1
000008  b10b              CBZ      r3,|L8.14|
;;;764      {
;;;765        /* CAN_FLAG is set */
;;;766        bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L8.16|
                  |L8.14|
;;;767      }
;;;768      else
;;;769      {
;;;770        /* CAN_FLAG is reset */
;;;771        bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L8.16|
;;;772      }
;;;773      /* Return the CAN_FLAG status */
;;;774      return  bitstatus;
;;;775    }
000010  4770              BX       lr
;;;776    
                          ENDP


                          AREA ||i.CAN_GetITStatus||, CODE, READONLY, ALIGN=1

                  CAN_GetITStatus PROC
;;;802      */
;;;803    ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;804    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;805      ITStatus pendingbitstatus = RESET;
000006  2600              MOVS     r6,#0
;;;806      /* Check the parameters */
;;;807      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;808      assert_param(IS_CAN_ITStatus(CAN_IT));
;;;809      switch (CAN_IT)
000008  2d40              CMP      r5,#0x40
00000a  d047              BEQ      |L9.156|
00000c  dc0e              BGT      |L9.44|
00000e  2d07              CMP      r5,#7
000010  d02b              BEQ      |L9.106|
000012  dc06              BGT      |L9.34|
000014  2d04              CMP      r5,#4
000016  d02f              BEQ      |L9.120|
000018  2d05              CMP      r5,#5
00001a  d019              BEQ      |L9.80|
00001c  2d06              CMP      r5,#6
00001e  d161              BNE      |L9.228|
000020  e01c              B        |L9.92|
                  |L9.34|
000022  2d08              CMP      r5,#8
000024  d02e              BEQ      |L9.132|
000026  2d20              CMP      r5,#0x20
000028  d15c              BNE      |L9.228|
00002a  e031              B        |L9.144|
                  |L9.44|
00002c  f5b56f80          CMP      r5,#0x400
000030  d046              BEQ      |L9.192|
000032  dc06              BGT      |L9.66|
000034  f5b57f80          CMP      r5,#0x100
000038  d036              BEQ      |L9.168|
00003a  f5b57f00          CMP      r5,#0x200
00003e  d151              BNE      |L9.228|
000040  e038              B        |L9.180|
                  |L9.66|
000042  f5b53f80          CMP      r5,#0x10000
000046  d047              BEQ      |L9.216|
000048  f5b53f00          CMP      r5,#0x20000
00004c  d14a              BNE      |L9.228|
00004e  e03d              B        |L9.204|
                  |L9.80|
;;;810      {
;;;811        case CAN_IT_RQCP0:
;;;812          pendingbitstatus = CheckITStatus(CANx->TSR, TSR_RQCP0);
000050  68a0              LDR      r0,[r4,#8]
000052  2101              MOVS     r1,#1
000054  f7fffffe          BL       CheckITStatus
000058  4606              MOV      r6,r0
;;;813          break;
00005a  e045              B        |L9.232|
                  |L9.92|
;;;814        case CAN_IT_RQCP1:
;;;815          pendingbitstatus = CheckITStatus(CANx->TSR, TSR_RQCP1);
00005c  68a0              LDR      r0,[r4,#8]
00005e  f44f7180          MOV      r1,#0x100
000062  f7fffffe          BL       CheckITStatus
000066  4606              MOV      r6,r0
;;;816          break;
000068  e03e              B        |L9.232|
                  |L9.106|
;;;817        case CAN_IT_RQCP2:
;;;818          pendingbitstatus = CheckITStatus(CANx->TSR, TSR_RQCP2);
00006a  68a0              LDR      r0,[r4,#8]
00006c  f44f3180          MOV      r1,#0x10000
000070  f7fffffe          BL       CheckITStatus
000074  4606              MOV      r6,r0
;;;819          break;
000076  e037              B        |L9.232|
                  |L9.120|
;;;820        case CAN_IT_FF0:
;;;821          pendingbitstatus = CheckITStatus(CANx->RF0R, RF0R_FULL0);
000078  68e0              LDR      r0,[r4,#0xc]
00007a  2108              MOVS     r1,#8
00007c  f7fffffe          BL       CheckITStatus
000080  4606              MOV      r6,r0
;;;822          break;
000082  e031              B        |L9.232|
                  |L9.132|
;;;823        case CAN_IT_FOV0:
;;;824          pendingbitstatus = CheckITStatus(CANx->RF0R, RF0R_FOVR0);
000084  68e0              LDR      r0,[r4,#0xc]
000086  2110              MOVS     r1,#0x10
000088  f7fffffe          BL       CheckITStatus
00008c  4606              MOV      r6,r0
;;;825          break;
00008e  e02b              B        |L9.232|
                  |L9.144|
;;;826        case CAN_IT_FF1:
;;;827          pendingbitstatus = CheckITStatus(CANx->RF1R, RF1R_FULL1);
000090  6920              LDR      r0,[r4,#0x10]
000092  2108              MOVS     r1,#8
000094  f7fffffe          BL       CheckITStatus
000098  4606              MOV      r6,r0
;;;828          break;
00009a  e025              B        |L9.232|
                  |L9.156|
;;;829        case CAN_IT_FOV1:
;;;830          pendingbitstatus = CheckITStatus(CANx->RF1R, RF1R_FOVR1);
00009c  6920              LDR      r0,[r4,#0x10]
00009e  2110              MOVS     r1,#0x10
0000a0  f7fffffe          BL       CheckITStatus
0000a4  4606              MOV      r6,r0
;;;831          break;
0000a6  e01f              B        |L9.232|
                  |L9.168|
;;;832        case CAN_IT_EWG:
;;;833          pendingbitstatus = CheckITStatus(CANx->ESR, ESR_EWGF);
0000a8  69a0              LDR      r0,[r4,#0x18]
0000aa  2101              MOVS     r1,#1
0000ac  f7fffffe          BL       CheckITStatus
0000b0  4606              MOV      r6,r0
;;;834          break;
0000b2  e019              B        |L9.232|
                  |L9.180|
;;;835        case CAN_IT_EPV:
;;;836          pendingbitstatus = CheckITStatus(CANx->ESR, ESR_EPVF);
0000b4  69a0              LDR      r0,[r4,#0x18]
0000b6  2102              MOVS     r1,#2
0000b8  f7fffffe          BL       CheckITStatus
0000bc  4606              MOV      r6,r0
;;;837          break;
0000be  e013              B        |L9.232|
                  |L9.192|
;;;838        case CAN_IT_BOF:
;;;839          pendingbitstatus = CheckITStatus(CANx->ESR, ESR_BOFF);
0000c0  69a0              LDR      r0,[r4,#0x18]
0000c2  2104              MOVS     r1,#4
0000c4  f7fffffe          BL       CheckITStatus
0000c8  4606              MOV      r6,r0
;;;840          break;
0000ca  e00d              B        |L9.232|
                  |L9.204|
;;;841        case CAN_IT_SLK:
;;;842          pendingbitstatus = CheckITStatus(CANx->MSR, MSR_SLAKI);
0000cc  6860              LDR      r0,[r4,#4]
0000ce  2110              MOVS     r1,#0x10
0000d0  f7fffffe          BL       CheckITStatus
0000d4  4606              MOV      r6,r0
;;;843          break;
0000d6  e007              B        |L9.232|
                  |L9.216|
;;;844        case CAN_IT_WKU:
;;;845          pendingbitstatus = CheckITStatus(CANx->MSR, MSR_WKUI);
0000d8  6860              LDR      r0,[r4,#4]
0000da  2108              MOVS     r1,#8
0000dc  f7fffffe          BL       CheckITStatus
0000e0  4606              MOV      r6,r0
;;;846          break;
0000e2  e001              B        |L9.232|
                  |L9.228|
;;;847        default :
;;;848          pendingbitstatus = RESET;
0000e4  2600              MOVS     r6,#0
;;;849          break;
0000e6  bf00              NOP      
                  |L9.232|
0000e8  bf00              NOP                            ;813
;;;850      }
;;;851      /* Return the CAN_IT status */
;;;852      return  pendingbitstatus;
0000ea  4630              MOV      r0,r6
;;;853    }
0000ec  bd70              POP      {r4-r6,pc}
;;;854    
                          ENDP


                          AREA ||i.CAN_ITConfig||, CODE, READONLY, ALIGN=1

                  CAN_ITConfig PROC
;;;413      */
;;;414    void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState Newstate)
000000  b11a              CBZ      r2,|L10.10|
;;;415    {
;;;416      /* Check the parameters */
;;;417      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;418      assert_param(IS_CAN_ITConfig(CAN_IT));
;;;419      assert_param(IS_FUNCTIONAL_STATE(Newstate));
;;;420      if (Newstate != DISABLE)
;;;421      {
;;;422        /* Enable the selected CAN interrupt */
;;;423        CANx->IER |= CAN_IT;
000002  6943              LDR      r3,[r0,#0x14]
000004  430b              ORRS     r3,r3,r1
000006  6143              STR      r3,[r0,#0x14]
000008  e002              B        |L10.16|
                  |L10.10|
;;;424      }
;;;425      else
;;;426      {
;;;427        /* Disable the selected CAN interrupt */
;;;428        CANx->IER &= ~CAN_IT;
00000a  6943              LDR      r3,[r0,#0x14]
00000c  438b              BICS     r3,r3,r1
00000e  6143              STR      r3,[r0,#0x14]
                  |L10.16|
;;;429      }
;;;430    }
000010  4770              BX       lr
;;;431    
                          ENDP


                          AREA ||i.CAN_Init||, CODE, READONLY, ALIGN=1

                  CAN_Init PROC
;;;170      */
;;;171    uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;172    {
000002  4602              MOV      r2,r0
;;;173      uint8_t InitStatus = CANINITFAILED;
000004  2000              MOVS     r0,#0
;;;174      uint32_t wait_ack = 0x00000000;
000006  2300              MOVS     r3,#0
;;;175      /* Check the parameters */
;;;176      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;177      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
;;;178      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
;;;179      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
;;;180      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
;;;181      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
;;;182      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
;;;183      assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
;;;184      assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
;;;185      assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
;;;186      assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
;;;187      assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
;;;188      /* exit from sleep mode */
;;;189      CANx->MCR &= ~MCR_SLEEP;
000008  6814              LDR      r4,[r2,#0]
00000a  f0240402          BIC      r4,r4,#2
00000e  6014              STR      r4,[r2,#0]
;;;190      /* Request initialisation */
;;;191      CANx->MCR |= MCR_INRQ ;
000010  6814              LDR      r4,[r2,#0]
000012  f0440401          ORR      r4,r4,#1
000016  6014              STR      r4,[r2,#0]
;;;192      /* Wait the acknowledge */
;;;193      while ((wait_ack != INAK_TimeOut)&&((CANx->MSR & MSR_INAK) != MSR_INAK))
000018  e000              B        |L11.28|
                  |L11.26|
;;;194      {
;;;195        wait_ack++;
00001a  1c5b              ADDS     r3,r3,#1
                  |L11.28|
00001c  f64f74ff          MOV      r4,#0xffff            ;193
000020  42a3              CMP      r3,r4                 ;193
000022  d004              BEQ      |L11.46|
000024  6854              LDR      r4,[r2,#4]            ;193
000026  f0040401          AND      r4,r4,#1              ;193
00002a  2c00              CMP      r4,#0                 ;193
00002c  d0f5              BEQ      |L11.26|
                  |L11.46|
;;;196      }
;;;197      /* ...and check acknowledged */
;;;198      if ((CANx->MSR & MSR_INAK) != MSR_INAK)
00002e  6854              LDR      r4,[r2,#4]
000030  f0040401          AND      r4,r4,#1
000034  b90c              CBNZ     r4,|L11.58|
;;;199      {
;;;200        InitStatus = CANINITFAILED;
000036  2000              MOVS     r0,#0
000038  e06d              B        |L11.278|
                  |L11.58|
;;;201      }
;;;202      else 
;;;203      {
;;;204        /* Set the time triggered communication mode */
;;;205        if (CAN_InitStruct->CAN_TTCM == ENABLE)
00003a  780c              LDRB     r4,[r1,#0]
00003c  2c01              CMP      r4,#1
00003e  d104              BNE      |L11.74|
;;;206        {
;;;207          CANx->MCR |= MCR_TTCM;
000040  6814              LDR      r4,[r2,#0]
000042  f0440480          ORR      r4,r4,#0x80
000046  6014              STR      r4,[r2,#0]
000048  e003              B        |L11.82|
                  |L11.74|
;;;208        }
;;;209        else
;;;210        {
;;;211          CANx->MCR &= ~MCR_TTCM;
00004a  6814              LDR      r4,[r2,#0]
00004c  f0240480          BIC      r4,r4,#0x80
000050  6014              STR      r4,[r2,#0]
                  |L11.82|
;;;212        }
;;;213        /* Set the automatic bus-off management */
;;;214        if (CAN_InitStruct->CAN_ABOM == ENABLE)
000052  784c              LDRB     r4,[r1,#1]
000054  2c01              CMP      r4,#1
000056  d104              BNE      |L11.98|
;;;215        {
;;;216          CANx->MCR |= MCR_ABOM;
000058  6814              LDR      r4,[r2,#0]
00005a  f0440440          ORR      r4,r4,#0x40
00005e  6014              STR      r4,[r2,#0]
000060  e003              B        |L11.106|
                  |L11.98|
;;;217        }
;;;218        else
;;;219        {
;;;220          CANx->MCR &= ~MCR_ABOM;
000062  6814              LDR      r4,[r2,#0]
000064  f0240440          BIC      r4,r4,#0x40
000068  6014              STR      r4,[r2,#0]
                  |L11.106|
;;;221        }
;;;222        /* Set the automatic wake-up mode */
;;;223        if (CAN_InitStruct->CAN_AWUM == ENABLE)
00006a  788c              LDRB     r4,[r1,#2]
00006c  2c01              CMP      r4,#1
00006e  d104              BNE      |L11.122|
;;;224        {
;;;225          CANx->MCR |= MCR_AWUM;
000070  6814              LDR      r4,[r2,#0]
000072  f0440420          ORR      r4,r4,#0x20
000076  6014              STR      r4,[r2,#0]
000078  e003              B        |L11.130|
                  |L11.122|
;;;226        }
;;;227        else
;;;228        {
;;;229          CANx->MCR &= ~MCR_AWUM;
00007a  6814              LDR      r4,[r2,#0]
00007c  f0240420          BIC      r4,r4,#0x20
000080  6014              STR      r4,[r2,#0]
                  |L11.130|
;;;230        }
;;;231        /* Set the no automatic retransmission */
;;;232        if (CAN_InitStruct->CAN_NART == ENABLE)
000082  78cc              LDRB     r4,[r1,#3]
000084  2c01              CMP      r4,#1
000086  d104              BNE      |L11.146|
;;;233        {
;;;234          CANx->MCR |= MCR_NART;
000088  6814              LDR      r4,[r2,#0]
00008a  f0440410          ORR      r4,r4,#0x10
00008e  6014              STR      r4,[r2,#0]
000090  e003              B        |L11.154|
                  |L11.146|
;;;235        }
;;;236        else
;;;237        {
;;;238          CANx->MCR &= ~MCR_NART;
000092  6814              LDR      r4,[r2,#0]
000094  f0240410          BIC      r4,r4,#0x10
000098  6014              STR      r4,[r2,#0]
                  |L11.154|
;;;239        }
;;;240        /* Set the receive FIFO locked mode */
;;;241        if (CAN_InitStruct->CAN_RFLM == ENABLE)
00009a  790c              LDRB     r4,[r1,#4]
00009c  2c01              CMP      r4,#1
00009e  d104              BNE      |L11.170|
;;;242        {
;;;243          CANx->MCR |= MCR_RFLM;
0000a0  6814              LDR      r4,[r2,#0]
0000a2  f0440408          ORR      r4,r4,#8
0000a6  6014              STR      r4,[r2,#0]
0000a8  e003              B        |L11.178|
                  |L11.170|
;;;244        }
;;;245        else
;;;246        {
;;;247          CANx->MCR &= ~MCR_RFLM;
0000aa  6814              LDR      r4,[r2,#0]
0000ac  f0240408          BIC      r4,r4,#8
0000b0  6014              STR      r4,[r2,#0]
                  |L11.178|
;;;248        }
;;;249        /* Set the transmit FIFO priority */
;;;250        if (CAN_InitStruct->CAN_TXFP == ENABLE)
0000b2  794c              LDRB     r4,[r1,#5]
0000b4  2c01              CMP      r4,#1
0000b6  d104              BNE      |L11.194|
;;;251        {
;;;252          CANx->MCR |= MCR_TXFP;
0000b8  6814              LDR      r4,[r2,#0]
0000ba  f0440404          ORR      r4,r4,#4
0000be  6014              STR      r4,[r2,#0]
0000c0  e003              B        |L11.202|
                  |L11.194|
;;;253        }
;;;254        else
;;;255        {
;;;256          CANx->MCR &= ~MCR_TXFP;
0000c2  6814              LDR      r4,[r2,#0]
0000c4  f0240404          BIC      r4,r4,#4
0000c8  6014              STR      r4,[r2,#0]
                  |L11.202|
;;;257        }
;;;258        /* Set the bit timing register */
;;;259        CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | ((uint32_t)CAN_InitStruct->CAN_SJW << 24) |
0000ca  798c              LDRB     r4,[r1,#6]
0000cc  07a4              LSLS     r4,r4,#30
0000ce  79cd              LDRB     r5,[r1,#7]
0000d0  ea446405          ORR      r4,r4,r5,LSL #24
0000d4  7a0d              LDRB     r5,[r1,#8]
0000d6  ea444405          ORR      r4,r4,r5,LSL #16
0000da  7a4d              LDRB     r5,[r1,#9]
0000dc  ea445405          ORR      r4,r4,r5,LSL #20
0000e0  894d              LDRH     r5,[r1,#0xa]
0000e2  1e6d              SUBS     r5,r5,#1
0000e4  432c              ORRS     r4,r4,r5
0000e6  61d4              STR      r4,[r2,#0x1c]
;;;260                   ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) |
;;;261                   ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
;;;262        /* Request leave initialisation */
;;;263        CANx->MCR &= ~MCR_INRQ;
0000e8  6814              LDR      r4,[r2,#0]
0000ea  f0240401          BIC      r4,r4,#1
0000ee  6014              STR      r4,[r2,#0]
;;;264       /* Wait the acknowledge */
;;;265       wait_ack = 0x00;
0000f0  2300              MOVS     r3,#0
;;;266       while ((wait_ack != INAK_TimeOut)&&((CANx->MSR & MSR_INAK) == MSR_INAK))
0000f2  e000              B        |L11.246|
                  |L11.244|
;;;267       {
;;;268         wait_ack++;
0000f4  1c5b              ADDS     r3,r3,#1
                  |L11.246|
0000f6  f64f74ff          MOV      r4,#0xffff            ;266
0000fa  42a3              CMP      r3,r4                 ;266
0000fc  d004              BEQ      |L11.264|
0000fe  6854              LDR      r4,[r2,#4]            ;266
000100  f0040401          AND      r4,r4,#1              ;266
000104  2c00              CMP      r4,#0                 ;266
000106  d1f5              BNE      |L11.244|
                  |L11.264|
;;;269       }
;;;270        /* ...and check acknowledged */
;;;271        if ((CANx->MSR & MSR_INAK) == MSR_INAK)
000108  6854              LDR      r4,[r2,#4]
00010a  f0040401          AND      r4,r4,#1
00010e  b10c              CBZ      r4,|L11.276|
;;;272        {
;;;273          InitStatus = CANINITFAILED;
000110  2000              MOVS     r0,#0
000112  e000              B        |L11.278|
                  |L11.276|
;;;274        }
;;;275        else
;;;276        {
;;;277          InitStatus = CANINITOK ;
000114  2001              MOVS     r0,#1
                  |L11.278|
;;;278        }
;;;279      }
;;;280      /* At this step, return the status of initialization */
;;;281      return InitStatus;
;;;282    }
000116  bd30              POP      {r4,r5,pc}
;;;283    
                          ENDP


                          AREA ||i.CAN_MessagePending||, CODE, READONLY, ALIGN=1

                  CAN_MessagePending PROC
;;;604      */
;;;605    uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
000000  4602              MOV      r2,r0
;;;606    {
;;;607      uint8_t message_pending=0;
000002  2000              MOVS     r0,#0
;;;608      /* Check the parameters */
;;;609      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;610      assert_param(IS_CAN_FIFO(FIFONumber));
;;;611      if (FIFONumber == CAN_FIFO0)
000004  b919              CBNZ     r1,|L12.14|
;;;612      {
;;;613        message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
000006  68d3              LDR      r3,[r2,#0xc]
000008  f0030003          AND      r0,r3,#3
00000c  e006              B        |L12.28|
                  |L12.14|
;;;614      }
;;;615      else if (FIFONumber == CAN_FIFO1)
00000e  2901              CMP      r1,#1
000010  d103              BNE      |L12.26|
;;;616      {
;;;617        message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
000012  6913              LDR      r3,[r2,#0x10]
000014  f0030003          AND      r0,r3,#3
000018  e000              B        |L12.28|
                  |L12.26|
;;;618      }
;;;619      else
;;;620      {
;;;621        message_pending = 0;
00001a  2000              MOVS     r0,#0
                  |L12.28|
;;;622      }
;;;623      return message_pending;
;;;624    }
00001c  4770              BX       lr
;;;625    
                          ENDP


                          AREA ||i.CAN_Receive||, CODE, READONLY, ALIGN=1

                  CAN_Receive PROC
;;;633      */
;;;634    void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
000000  b530              PUSH     {r4,r5,lr}
;;;635    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4613              MOV      r3,r2
;;;636      /* Check the parameters */
;;;637      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;638      assert_param(IS_CAN_FIFO(FIFONumber));
;;;639      /* Get the Id */
;;;640      RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
000008  f50570d8          ADD      r0,r5,#0x1b0
00000c  eb001004          ADD      r0,r0,r4,LSL #4
000010  6800              LDR      r0,[r0,#0]
000012  f0000004          AND      r0,r0,#4
000016  7218              STRB     r0,[r3,#8]
;;;641      if (RxMessage->IDE == CAN_ID_STD)
000018  7a18              LDRB     r0,[r3,#8]
00001a  b950              CBNZ     r0,|L13.50|
;;;642      {
;;;643        RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
00001c  f50570d8          ADD      r0,r5,#0x1b0
000020  eb001004          ADD      r0,r0,r4,LSL #4
000024  6800              LDR      r0,[r0,#0]
000026  f24071ff          MOV      r1,#0x7ff
00002a  ea015050          AND      r0,r1,r0,LSR #21
00002e  6018              STR      r0,[r3,#0]
000030  e009              B        |L13.70|
                  |L13.50|
;;;644      }
;;;645      else
;;;646      {
;;;647        RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
000032  f50570d8          ADD      r0,r5,#0x1b0
000036  eb001004          ADD      r0,r0,r4,LSL #4
00003a  6800              LDR      r0,[r0,#0]
00003c  f06f4160          MVN      r1,#0xe0000000
000040  ea0100d0          AND      r0,r1,r0,LSR #3
000044  6058              STR      r0,[r3,#4]
                  |L13.70|
;;;648      }
;;;649      
;;;650      RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
000046  f50570d8          ADD      r0,r5,#0x1b0
00004a  eb001004          ADD      r0,r0,r4,LSL #4
00004e  6800              LDR      r0,[r0,#0]
000050  f0000002          AND      r0,r0,#2
000054  7258              STRB     r0,[r3,#9]
;;;651      /* Get the DLC */
;;;652      RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
000056  f50570d8          ADD      r0,r5,#0x1b0
00005a  eb001004          ADD      r0,r0,r4,LSL #4
00005e  6840              LDR      r0,[r0,#4]
000060  f000000f          AND      r0,r0,#0xf
000064  7298              STRB     r0,[r3,#0xa]
;;;653      /* Get the FMI */
;;;654      RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
000066  f50570d8          ADD      r0,r5,#0x1b0
00006a  eb001004          ADD      r0,r0,r4,LSL #4
00006e  6840              LDR      r0,[r0,#4]
000070  0a00              LSRS     r0,r0,#8
000072  74d8              STRB     r0,[r3,#0x13]
;;;655      /* Get the data field */
;;;656      RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
000074  f50570d8          ADD      r0,r5,#0x1b0
000078  eb001004          ADD      r0,r0,r4,LSL #4
00007c  6880              LDR      r0,[r0,#8]
00007e  72d8              STRB     r0,[r3,#0xb]
;;;657      RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
000080  f50570d8          ADD      r0,r5,#0x1b0
000084  eb001004          ADD      r0,r0,r4,LSL #4
000088  6880              LDR      r0,[r0,#8]
00008a  0a01              LSRS     r1,r0,#8
00008c  7319              STRB     r1,[r3,#0xc]
;;;658      RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
00008e  f50570d8          ADD      r0,r5,#0x1b0
000092  eb001004          ADD      r0,r0,r4,LSL #4
000096  6880              LDR      r0,[r0,#8]
000098  0c01              LSRS     r1,r0,#16
00009a  7359              STRB     r1,[r3,#0xd]
;;;659      RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
00009c  f50570d8          ADD      r0,r5,#0x1b0
0000a0  eb001004          ADD      r0,r0,r4,LSL #4
0000a4  6880              LDR      r0,[r0,#8]
0000a6  0e00              LSRS     r0,r0,#24
0000a8  7398              STRB     r0,[r3,#0xe]
;;;660      RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
0000aa  f50570d8          ADD      r0,r5,#0x1b0
0000ae  eb001004          ADD      r0,r0,r4,LSL #4
0000b2  68c0              LDR      r0,[r0,#0xc]
0000b4  73d8              STRB     r0,[r3,#0xf]
;;;661      RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
0000b6  f50570d8          ADD      r0,r5,#0x1b0
0000ba  eb001004          ADD      r0,r0,r4,LSL #4
0000be  68c0              LDR      r0,[r0,#0xc]
0000c0  0a01              LSRS     r1,r0,#8
0000c2  7419              STRB     r1,[r3,#0x10]
;;;662      RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
0000c4  f50570d8          ADD      r0,r5,#0x1b0
0000c8  eb001004          ADD      r0,r0,r4,LSL #4
0000cc  68c0              LDR      r0,[r0,#0xc]
0000ce  0c01              LSRS     r1,r0,#16
0000d0  7459              STRB     r1,[r3,#0x11]
;;;663      RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
0000d2  f50570d8          ADD      r0,r5,#0x1b0
0000d6  eb001004          ADD      r0,r0,r4,LSL #4
0000da  68c0              LDR      r0,[r0,#0xc]
0000dc  0e00              LSRS     r0,r0,#24
0000de  7498              STRB     r0,[r3,#0x12]
;;;664      /* Release the FIFO */
;;;665      CAN_FIFORelease(CANx, FIFONumber);
0000e0  4621              MOV      r1,r4
0000e2  4628              MOV      r0,r5
0000e4  f7fffffe          BL       CAN_FIFORelease
;;;666    }
0000e8  bd30              POP      {r4,r5,pc}
;;;667    
                          ENDP


                          AREA ||i.CAN_Sleep||, CODE, READONLY, ALIGN=1

                  CAN_Sleep PROC
;;;696      */
;;;697    uint8_t CAN_Sleep(CAN_TypeDef* CANx)
000000  4601              MOV      r1,r0
;;;698    {
;;;699      uint8_t sleepstatus = CANSLEEPFAILED;
000002  2000              MOVS     r0,#0
;;;700      
;;;701      /* Check the parameters */
;;;702      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;703        
;;;704      /* Request Sleep mode */
;;;705       CANx->MCR = (((CANx->MCR) & (uint32_t)(~MCR_INRQ)) | MCR_SLEEP);
000004  680a              LDR      r2,[r1,#0]
000006  f0220201          BIC      r2,r2,#1
00000a  f0420202          ORR      r2,r2,#2
00000e  600a              STR      r2,[r1,#0]
;;;706       
;;;707      /* Sleep mode status */
;;;708      if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
000010  684a              LDR      r2,[r1,#4]
000012  f0020203          AND      r2,r2,#3
000016  2a02              CMP      r2,#2
000018  d100              BNE      |L14.28|
;;;709      {
;;;710        /* Sleep mode not entered */
;;;711        sleepstatus =  CANSLEEPOK;
00001a  2001              MOVS     r0,#1
                  |L14.28|
;;;712      }
;;;713      /* At this step, sleep mode status */
;;;714       return (uint8_t)sleepstatus;
;;;715    }
00001c  4770              BX       lr
;;;716    
                          ENDP


                          AREA ||i.CAN_StructInit||, CODE, READONLY, ALIGN=1

                  CAN_StructInit PROC
;;;372      */
;;;373    void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
000000  2100              MOVS     r1,#0
;;;374    {
;;;375      /* Reset CAN init structure parameters values */
;;;376      /* Initialize the time triggered communication mode */
;;;377      CAN_InitStruct->CAN_TTCM = DISABLE;
000002  7001              STRB     r1,[r0,#0]
;;;378      /* Initialize the automatic bus-off management */
;;;379      CAN_InitStruct->CAN_ABOM = DISABLE;
000004  7041              STRB     r1,[r0,#1]
;;;380      /* Initialize the automatic wake-up mode */
;;;381      CAN_InitStruct->CAN_AWUM = DISABLE;
000006  7081              STRB     r1,[r0,#2]
;;;382      /* Initialize the no automatic retransmission */
;;;383      CAN_InitStruct->CAN_NART = DISABLE;
000008  70c1              STRB     r1,[r0,#3]
;;;384      /* Initialize the receive FIFO locked mode */
;;;385      CAN_InitStruct->CAN_RFLM = DISABLE;
00000a  7101              STRB     r1,[r0,#4]
;;;386      /* Initialize the transmit FIFO priority */
;;;387      CAN_InitStruct->CAN_TXFP = DISABLE;
00000c  7141              STRB     r1,[r0,#5]
;;;388      /* Initialize the CAN_Mode member */
;;;389      CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
00000e  7181              STRB     r1,[r0,#6]
;;;390      /* Initialize the CAN_SJW member */
;;;391      CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
000010  71c1              STRB     r1,[r0,#7]
;;;392      /* Initialize the CAN_BS1 member */
;;;393      CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
000012  2103              MOVS     r1,#3
000014  7201              STRB     r1,[r0,#8]
;;;394      /* Initialize the CAN_BS2 member */
;;;395      CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
000016  2102              MOVS     r1,#2
000018  7241              STRB     r1,[r0,#9]
;;;396      /* Initialize the CAN_Prescaler member */
;;;397      CAN_InitStruct->CAN_Prescaler = 1;
00001a  2101              MOVS     r1,#1
00001c  8141              STRH     r1,[r0,#0xa]
;;;398    }
00001e  4770              BX       lr
;;;399    
                          ENDP


                          AREA ||i.CAN_Transmit||, CODE, READONLY, ALIGN=1

                  CAN_Transmit PROC
;;;439      */
;;;440    uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
000000  b510              PUSH     {r4,lr}
;;;441    {
000002  4602              MOV      r2,r0
;;;442      uint8_t transmit_mailbox = 0;
000004  2000              MOVS     r0,#0
;;;443      /* Check the parameters */
;;;444      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;445      assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
;;;446      assert_param(IS_CAN_RTR(TxMessage->RTR));
;;;447      assert_param(IS_CAN_DLC(TxMessage->DLC));
;;;448      /* Select one empty transmit mailbox */
;;;449      if ((CANx->TSR&TSR_TME0) == TSR_TME0)
000006  6893              LDR      r3,[r2,#8]
000008  f0036380          AND      r3,r3,#0x4000000
00000c  f1b36f80          CMP      r3,#0x4000000
000010  d100              BNE      |L16.20|
;;;450      {
;;;451        transmit_mailbox = 0;
000012  e010              B        |L16.54|
                  |L16.20|
;;;452      }
;;;453      else if ((CANx->TSR&TSR_TME1) == TSR_TME1)
000014  6893              LDR      r3,[r2,#8]
000016  f0036300          AND      r3,r3,#0x8000000
00001a  f1b36f00          CMP      r3,#0x8000000
00001e  d101              BNE      |L16.36|
;;;454      {
;;;455        transmit_mailbox = 1;
000020  2001              MOVS     r0,#1
000022  e008              B        |L16.54|
                  |L16.36|
;;;456      }
;;;457      else if ((CANx->TSR&TSR_TME2) == TSR_TME2)
000024  6893              LDR      r3,[r2,#8]
000026  f0035380          AND      r3,r3,#0x10000000
00002a  f1b35f80          CMP      r3,#0x10000000
00002e  d101              BNE      |L16.52|
;;;458      {
;;;459        transmit_mailbox = 2;
000030  2002              MOVS     r0,#2
000032  e000              B        |L16.54|
                  |L16.52|
;;;460      }
;;;461      else
;;;462      {
;;;463        transmit_mailbox = CAN_NO_MB;
000034  2004              MOVS     r0,#4
                  |L16.54|
;;;464      }
;;;465      if (transmit_mailbox != CAN_NO_MB)
000036  2804              CMP      r0,#4
000038  d074              BEQ      |L16.292|
;;;466      {
;;;467        /* Set up the Id */
;;;468        CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
00003a  f50273c0          ADD      r3,r2,#0x180
00003e  eb031300          ADD      r3,r3,r0,LSL #4
000042  681b              LDR      r3,[r3,#0]
000044  f0030401          AND      r4,r3,#1
000048  f50273c0          ADD      r3,r2,#0x180
00004c  eb031300          ADD      r3,r3,r0,LSL #4
000050  601c              STR      r4,[r3,#0]
;;;469        if (TxMessage->IDE == CAN_ID_STD)
000052  7a0b              LDRB     r3,[r1,#8]
000054  b97b              CBNZ     r3,|L16.118|
;;;470        {
;;;471          assert_param(IS_CAN_STDID(TxMessage->StdId));  
;;;472          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | TxMessage->RTR);
000056  7a4b              LDRB     r3,[r1,#9]
000058  880c              LDRH     r4,[r1,#0]
00005a  ea435344          ORR      r3,r3,r4,LSL #21
00005e  f50274c0          ADD      r4,r2,#0x180
000062  eb041400          ADD      r4,r4,r0,LSL #4
000066  6824              LDR      r4,[r4,#0]
000068  4323              ORRS     r3,r3,r4
00006a  f50274c0          ADD      r4,r2,#0x180
00006e  eb041400          ADD      r4,r4,r0,LSL #4
000072  6023              STR      r3,[r4,#0]
000074  e010              B        |L16.152|
                  |L16.118|
;;;473        }
;;;474        else
;;;475        {
;;;476          assert_param(IS_CAN_EXTID(TxMessage->ExtId));
;;;477          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId<<3) | TxMessage->IDE | 
000076  7a0b              LDRB     r3,[r1,#8]
000078  684c              LDR      r4,[r1,#4]
00007a  ea4303c4          ORR      r3,r3,r4,LSL #3
00007e  7a4c              LDRB     r4,[r1,#9]
000080  4323              ORRS     r3,r3,r4
000082  f50274c0          ADD      r4,r2,#0x180
000086  eb041400          ADD      r4,r4,r0,LSL #4
00008a  6824              LDR      r4,[r4,#0]
00008c  4323              ORRS     r3,r3,r4
00008e  f50274c0          ADD      r4,r2,#0x180
000092  eb041400          ADD      r4,r4,r0,LSL #4
000096  6023              STR      r3,[r4,#0]
                  |L16.152|
;;;478                                                   TxMessage->RTR);
;;;479        }
;;;480        
;;;481        /* Set up the DLC */
;;;482        TxMessage->DLC &= (uint8_t)0x0000000F;
000098  7a8b              LDRB     r3,[r1,#0xa]
00009a  f003030f          AND      r3,r3,#0xf
00009e  728b              STRB     r3,[r1,#0xa]
;;;483        CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
0000a0  f50273c0          ADD      r3,r2,#0x180
0000a4  eb031300          ADD      r3,r3,r0,LSL #4
0000a8  685b              LDR      r3,[r3,#4]
0000aa  f023040f          BIC      r4,r3,#0xf
0000ae  f50273c0          ADD      r3,r2,#0x180
0000b2  eb031300          ADD      r3,r3,r0,LSL #4
0000b6  605c              STR      r4,[r3,#4]
;;;484        CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
0000b8  f50273c0          ADD      r3,r2,#0x180
0000bc  eb031300          ADD      r3,r3,r0,LSL #4
0000c0  685b              LDR      r3,[r3,#4]
0000c2  7a8c              LDRB     r4,[r1,#0xa]
0000c4  4323              ORRS     r3,r3,r4
0000c6  f50274c0          ADD      r4,r2,#0x180
0000ca  eb041400          ADD      r4,r4,r0,LSL #4
0000ce  6063              STR      r3,[r4,#4]
;;;485        /* Set up the data field */
;;;486        CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
0000d0  7b8b              LDRB     r3,[r1,#0xe]
0000d2  061c              LSLS     r4,r3,#24
0000d4  7b4b              LDRB     r3,[r1,#0xd]
0000d6  ea444403          ORR      r4,r4,r3,LSL #16
0000da  7b0b              LDRB     r3,[r1,#0xc]
0000dc  ea442303          ORR      r3,r4,r3,LSL #8
0000e0  7acc              LDRB     r4,[r1,#0xb]
0000e2  4323              ORRS     r3,r3,r4
0000e4  f50274c0          ADD      r4,r2,#0x180
0000e8  eb041400          ADD      r4,r4,r0,LSL #4
0000ec  60a3              STR      r3,[r4,#8]
;;;487                                                 ((uint32_t)TxMessage->Data[2] << 16) |
;;;488                                                 ((uint32_t)TxMessage->Data[1] << 8) | 
;;;489                                                 ((uint32_t)TxMessage->Data[0]));
;;;490        CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
0000ee  7c8b              LDRB     r3,[r1,#0x12]
0000f0  061c              LSLS     r4,r3,#24
0000f2  7c4b              LDRB     r3,[r1,#0x11]
0000f4  ea444403          ORR      r4,r4,r3,LSL #16
0000f8  7c0b              LDRB     r3,[r1,#0x10]
0000fa  ea442303          ORR      r3,r4,r3,LSL #8
0000fe  7bcc              LDRB     r4,[r1,#0xf]
000100  4323              ORRS     r3,r3,r4
000102  f50274c0          ADD      r4,r2,#0x180
000106  eb041400          ADD      r4,r4,r0,LSL #4
00010a  60e3              STR      r3,[r4,#0xc]
;;;491                                                 ((uint32_t)TxMessage->Data[6] << 16) |
;;;492                                                 ((uint32_t)TxMessage->Data[5] << 8) |
;;;493                                                 ((uint32_t)TxMessage->Data[4]));
;;;494        /* Request transmission */
;;;495        CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
00010c  f50273c0          ADD      r3,r2,#0x180
000110  eb031300          ADD      r3,r3,r0,LSL #4
000114  681b              LDR      r3,[r3,#0]
000116  f0430401          ORR      r4,r3,#1
00011a  f50273c0          ADD      r3,r2,#0x180
00011e  eb031300          ADD      r3,r3,r0,LSL #4
000122  601c              STR      r4,[r3,#0]
                  |L16.292|
;;;496      }
;;;497      return transmit_mailbox;
;;;498    }
000124  bd10              POP      {r4,pc}
;;;499    
                          ENDP


                          AREA ||i.CAN_TransmitStatus||, CODE, READONLY, ALIGN=1

                  CAN_TransmitStatus PROC
;;;507      */
;;;508    uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t transmit_mailbox)
000000  4602              MOV      r2,r0
;;;509    {
;;;510      /* RQCP, TXOK and TME bits */
;;;511      uint8_t state = 0;
000002  2000              MOVS     r0,#0
;;;512      /* Check the parameters */
;;;513      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;514      assert_param(IS_CAN_TRANSMITMAILBOX(transmit_mailbox));
;;;515      switch (transmit_mailbox)
000004  b121              CBZ      r1,|L17.16|
000006  2901              CMP      r1,#1
000008  d010              BEQ      |L17.44|
00000a  2902              CMP      r1,#2
00000c  d12c              BNE      |L17.104|
00000e  e01c              B        |L17.74|
                  |L17.16|
;;;516      {
;;;517        case (0): state |= (uint8_t)((CANx->TSR & TSR_RQCP0) << 2);
000010  6893              LDR      r3,[r2,#8]
000012  f0030301          AND      r3,r3,#1
000016  ea400083          ORR      r0,r0,r3,LSL #2
;;;518          state |= (uint8_t)((CANx->TSR & TSR_TXOK0) >> 0);
00001a  6893              LDR      r3,[r2,#8]
00001c  f0030302          AND      r3,r3,#2
000020  4318              ORRS     r0,r0,r3
;;;519          state |= (uint8_t)((CANx->TSR & TSR_TME0) >> 26);
000022  6893              LDR      r3,[r2,#8]
000024  f3c36380          UBFX     r3,r3,#26,#1
000028  4318              ORRS     r0,r0,r3
;;;520          break;
00002a  e01f              B        |L17.108|
                  |L17.44|
;;;521        case (1): state |= (uint8_t)((CANx->TSR & TSR_RQCP1) >> 6);
00002c  6893              LDR      r3,[r2,#8]
00002e  f4037380          AND      r3,r3,#0x100
000032  ea401093          ORR      r0,r0,r3,LSR #6
;;;522          state |= (uint8_t)((CANx->TSR & TSR_TXOK1) >> 8);
000036  6893              LDR      r3,[r2,#8]
000038  f4037300          AND      r3,r3,#0x200
00003c  ea402013          ORR      r0,r0,r3,LSR #8
;;;523          state |= (uint8_t)((CANx->TSR & TSR_TME1) >> 27);
000040  6893              LDR      r3,[r2,#8]
000042  f3c363c0          UBFX     r3,r3,#27,#1
000046  4318              ORRS     r0,r0,r3
;;;524          break;
000048  e010              B        |L17.108|
                  |L17.74|
;;;525        case (2): state |= (uint8_t)((CANx->TSR & TSR_RQCP2) >> 14);
00004a  6893              LDR      r3,[r2,#8]
00004c  f4033380          AND      r3,r3,#0x10000
000050  ea403093          ORR      r0,r0,r3,LSR #14
;;;526          state |= (uint8_t)((CANx->TSR & TSR_TXOK2) >> 16);
000054  6893              LDR      r3,[r2,#8]
000056  f4033300          AND      r3,r3,#0x20000
00005a  ea404013          ORR      r0,r0,r3,LSR #16
;;;527          state |= (uint8_t)((CANx->TSR & TSR_TME2) >> 28);
00005e  6893              LDR      r3,[r2,#8]
000060  f3c37300          UBFX     r3,r3,#28,#1
000064  4318              ORRS     r0,r0,r3
;;;528          break;
000066  e001              B        |L17.108|
                  |L17.104|
;;;529        default:
;;;530          state = CANTXFAILED;
000068  2000              MOVS     r0,#0
;;;531          break;
00006a  bf00              NOP      
                  |L17.108|
00006c  bf00              NOP                            ;520
;;;532      }
;;;533      switch (state)
00006e  b120              CBZ      r0,|L17.122|
000070  2805              CMP      r0,#5
000072  d004              BEQ      |L17.126|
000074  2807              CMP      r0,#7
000076  d106              BNE      |L17.134|
000078  e003              B        |L17.130|
                  |L17.122|
;;;534      {
;;;535          /* transmit pending  */
;;;536        case (0x0): state = CANTXPENDING;
00007a  2002              MOVS     r0,#2
;;;537          break;
00007c  e005              B        |L17.138|
                  |L17.126|
;;;538          /* transmit failed  */
;;;539        case (0x5): state = CANTXFAILED;
00007e  2000              MOVS     r0,#0
;;;540          break;
000080  e003              B        |L17.138|
                  |L17.130|
;;;541          /* transmit succedeed  */
;;;542        case (0x7): state = CANTXOK;
000082  2001              MOVS     r0,#1
;;;543          break;
000084  e001              B        |L17.138|
                  |L17.134|
;;;544        default:
;;;545          state = CANTXFAILED;
000086  2000              MOVS     r0,#0
;;;546          break;
000088  bf00              NOP      
                  |L17.138|
00008a  bf00              NOP                            ;537
;;;547      }
;;;548      return state;
;;;549    }
00008c  4770              BX       lr
;;;550    
                          ENDP


                          AREA ||i.CAN_WakeUp||, CODE, READONLY, ALIGN=1

                  CAN_WakeUp PROC
;;;722      */
;;;723    uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
000000  4601              MOV      r1,r0
;;;724    {
;;;725      uint32_t wait_slak = SLAK_TimeOut	;
000002  f64f72ff          MOV      r2,#0xffff
;;;726      uint8_t wakeupstatus = CANWAKEUPFAILED;
000006  2000              MOVS     r0,#0
;;;727      
;;;728      /* Check the parameters */
;;;729      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;730        
;;;731      /* Wake up request */
;;;732      CANx->MCR &= ~MCR_SLEEP;
000008  680b              LDR      r3,[r1,#0]
00000a  f0230302          BIC      r3,r3,#2
00000e  600b              STR      r3,[r1,#0]
;;;733        
;;;734      /* Sleep mode status */
;;;735      while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
000010  e000              B        |L18.20|
                  |L18.18|
;;;736      {
;;;737       wait_slak--;
000012  1e52              SUBS     r2,r2,#1
                  |L18.20|
000014  684b              LDR      r3,[r1,#4]            ;735
000016  f0030302          AND      r3,r3,#2              ;735
00001a  2b02              CMP      r3,#2                 ;735
00001c  d101              BNE      |L18.34|
00001e  2a00              CMP      r2,#0                 ;735
000020  d1f7              BNE      |L18.18|
                  |L18.34|
;;;738      }
;;;739      if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
000022  684b              LDR      r3,[r1,#4]
000024  f0030302          AND      r3,r3,#2
000028  2b02              CMP      r3,#2
00002a  d000              BEQ      |L18.46|
;;;740      {
;;;741       /* Sleep mode exited */
;;;742        wakeupstatus = CANWAKEUPOK;
00002c  2001              MOVS     r0,#1
                  |L18.46|
;;;743      }
;;;744      /* At this step, sleep mode status */
;;;745      return (uint8_t)wakeupstatus;
;;;746    }
00002e  4770              BX       lr
;;;747    
                          ENDP


                          AREA ||i.CheckITStatus||, CODE, READONLY, ALIGN=1

                  CheckITStatus PROC
;;;914      */
;;;915    static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
000000  4602              MOV      r2,r0
;;;916    {
;;;917      ITStatus pendingbitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;918      
;;;919      if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
000004  ea020301          AND      r3,r2,r1
000008  b10b              CBZ      r3,|L19.14|
;;;920      {
;;;921        /* CAN_IT is set */
;;;922        pendingbitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L19.16|
                  |L19.14|
;;;923      }
;;;924      else
;;;925      {
;;;926        /* CAN_IT is reset */
;;;927        pendingbitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L19.16|
;;;928      }
;;;929      return pendingbitstatus;
;;;930    }
000010  4770              BX       lr
;;;931    
                          ENDP

