; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\stm32f10x_flash.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\stm32f10x_flash.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I"C:\Users\Kenneth Au\Desktop\toKenneth\Complicated Big Motor Control\(encoder)24V Big Blue Black Motor Control June 7\RTE" -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=513 -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=.\obj\stm32f10x_flash.crf FWlib\SRC\stm32f10x_flash.c]
                          THUMB

                          AREA ||i.FLASH_ClearFlag||, CODE, READONLY, ALIGN=2

                  FLASH_ClearFlag PROC
;;;782      */
;;;783    void FLASH_ClearFlag(uint16_t FLASH_FLAG)
000000  4901              LDR      r1,|L1.8|
;;;784    {
;;;785      /* Check the parameters */
;;;786      assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
;;;787      
;;;788      /* Clear the flags */
;;;789      FLASH->SR = FLASH_FLAG;
000002  60c8              STR      r0,[r1,#0xc]
;;;790    }
000004  4770              BX       lr
;;;791    
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_EnableWriteProtection||, CODE, READONLY, ALIGN=2

                  FLASH_EnableWriteProtection PROC
;;;460      */
;;;461    FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;462    {
000004  4604              MOV      r4,r0
;;;463      uint16_t WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
000006  f64f76ff          MOV      r6,#0xffff
00000a  4637              MOV      r7,r6
00000c  46b0              MOV      r8,r6
00000e  46b1              MOV      r9,r6
;;;464      
;;;465      FLASH_Status status = FLASH_COMPLETE;
000010  2504              MOVS     r5,#4
;;;466      
;;;467      /* Check the parameters */
;;;468      assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
;;;469      
;;;470      FLASH_Pages = (uint32_t)(~FLASH_Pages);
000012  43e4              MVNS     r4,r4
;;;471      WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
000014  b2e6              UXTB     r6,r4
;;;472      WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
000016  f3c42707          UBFX     r7,r4,#8,#8
;;;473      WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
00001a  f3c44807          UBFX     r8,r4,#16,#8
;;;474      WRP3_Data = (uint16_t)((FLASH_Pages & WRP3_Mask) >> 24);
00001e  ea4f6914          LSR      r9,r4,#24
;;;475      
;;;476      /* Wait for last operation to be completed */
;;;477      status = FLASH_WaitForLastOperation(ProgramTimeout);
000022  200f              MOVS     r0,#0xf
000024  f7fffffe          BL       FLASH_WaitForLastOperation
000028  4605              MOV      r5,r0
;;;478      
;;;479      if(status == FLASH_COMPLETE)
00002a  2d04              CMP      r5,#4
00002c  d13f              BNE      |L2.174|
;;;480      {
;;;481        /* Authorizes the small information block programming */
;;;482        FLASH->OPTKEYR = FLASH_KEY1;
00002e  4821              LDR      r0,|L2.180|
000030  4921              LDR      r1,|L2.184|
000032  6088              STR      r0,[r1,#8]
;;;483        FLASH->OPTKEYR = FLASH_KEY2;
000034  4821              LDR      r0,|L2.188|
000036  6088              STR      r0,[r1,#8]
;;;484        FLASH->CR |= CR_OPTPG_Set;
000038  4608              MOV      r0,r1
00003a  6900              LDR      r0,[r0,#0x10]
00003c  f0400010          ORR      r0,r0,#0x10
000040  6108              STR      r0,[r1,#0x10]
;;;485        if(WRP0_Data != 0xFF)
000042  2eff              CMP      r6,#0xff
000044  d005              BEQ      |L2.82|
;;;486        {
;;;487          OB->WRP0 = WRP0_Data;
000046  481e              LDR      r0,|L2.192|
000048  8006              STRH     r6,[r0,#0]
;;;488          
;;;489          /* Wait for last operation to be completed */
;;;490          status = FLASH_WaitForLastOperation(ProgramTimeout);
00004a  200f              MOVS     r0,#0xf
00004c  f7fffffe          BL       FLASH_WaitForLastOperation
000050  4605              MOV      r5,r0
                  |L2.82|
;;;491        }
;;;492        if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
000052  2d04              CMP      r5,#4
000054  d108              BNE      |L2.104|
000056  2fff              CMP      r7,#0xff
000058  d006              BEQ      |L2.104|
;;;493        {
;;;494          OB->WRP1 = WRP1_Data;
00005a  4819              LDR      r0,|L2.192|
00005c  1c80              ADDS     r0,r0,#2
00005e  8007              STRH     r7,[r0,#0]
;;;495          
;;;496          /* Wait for last operation to be completed */
;;;497          status = FLASH_WaitForLastOperation(ProgramTimeout);
000060  200f              MOVS     r0,#0xf
000062  f7fffffe          BL       FLASH_WaitForLastOperation
000066  4605              MOV      r5,r0
                  |L2.104|
;;;498        }
;;;499        if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
000068  2d04              CMP      r5,#4
00006a  d10a              BNE      |L2.130|
00006c  f1b80fff          CMP      r8,#0xff
000070  d007              BEQ      |L2.130|
;;;500        {
;;;501          OB->WRP2 = WRP2_Data;
000072  4813              LDR      r0,|L2.192|
000074  1d00              ADDS     r0,r0,#4
000076  f8a08000          STRH     r8,[r0,#0]
;;;502          
;;;503          /* Wait for last operation to be completed */
;;;504          status = FLASH_WaitForLastOperation(ProgramTimeout);
00007a  200f              MOVS     r0,#0xf
00007c  f7fffffe          BL       FLASH_WaitForLastOperation
000080  4605              MOV      r5,r0
                  |L2.130|
;;;505        }
;;;506        
;;;507        if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
000082  2d04              CMP      r5,#4
000084  d10a              BNE      |L2.156|
000086  f1b90fff          CMP      r9,#0xff
00008a  d007              BEQ      |L2.156|
;;;508        {
;;;509          OB->WRP3 = WRP3_Data;
00008c  480c              LDR      r0,|L2.192|
00008e  1d80              ADDS     r0,r0,#6
000090  f8a09000          STRH     r9,[r0,#0]
;;;510         
;;;511          /* Wait for last operation to be completed */
;;;512          status = FLASH_WaitForLastOperation(ProgramTimeout);
000094  200f              MOVS     r0,#0xf
000096  f7fffffe          BL       FLASH_WaitForLastOperation
00009a  4605              MOV      r5,r0
                  |L2.156|
;;;513        }
;;;514              
;;;515        if(status != FLASH_BUSY)
00009c  2d01              CMP      r5,#1
00009e  d006              BEQ      |L2.174|
;;;516        {
;;;517          /* if the program operation is completed, disable the OPTPG Bit */
;;;518          FLASH->CR &= CR_OPTPG_Reset;
0000a0  4805              LDR      r0,|L2.184|
0000a2  6900              LDR      r0,[r0,#0x10]
0000a4  f64171ef          MOV      r1,#0x1fef
0000a8  4008              ANDS     r0,r0,r1
0000aa  4903              LDR      r1,|L2.184|
0000ac  6108              STR      r0,[r1,#0x10]
                  |L2.174|
;;;519        }
;;;520      } 
;;;521      /* Return the write protection operation Status */
;;;522      return status;       
0000ae  4628              MOV      r0,r5
;;;523    }
0000b0  e8bd87f0          POP      {r4-r10,pc}
;;;524    
                          ENDP

                  |L2.180|
                          DCD      0x45670123
                  |L2.184|
                          DCD      0x40022000
                  |L2.188|
                          DCD      0xcdef89ab
                  |L2.192|
                          DCD      0x1ffff808

                          AREA ||i.FLASH_EraseAllPages||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllPages PROC
;;;242      */
;;;243    FLASH_Status FLASH_EraseAllPages(void)
000000  b510              PUSH     {r4,lr}
;;;244    {
;;;245      FLASH_Status status = FLASH_COMPLETE;
000002  2404              MOVS     r4,#4
;;;246      /* Wait for last operation to be completed */
;;;247      status = FLASH_WaitForLastOperation(EraseTimeout);
000004  f64070ff          MOV      r0,#0xfff
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4604              MOV      r4,r0
;;;248      
;;;249      if(status == FLASH_COMPLETE)
00000e  2c04              CMP      r4,#4
000010  d118              BNE      |L3.68|
;;;250      {
;;;251        /* if the previous operation is completed, proceed to erase all pages */
;;;252         FLASH->CR |= CR_MER_Set;
000012  480d              LDR      r0,|L3.72|
000014  6900              LDR      r0,[r0,#0x10]
000016  f0400004          ORR      r0,r0,#4
00001a  490b              LDR      r1,|L3.72|
00001c  6108              STR      r0,[r1,#0x10]
;;;253         FLASH->CR |= CR_STRT_Set;
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400040          ORR      r0,r0,#0x40
000026  6108              STR      r0,[r1,#0x10]
;;;254        
;;;255        /* Wait for last operation to be completed */
;;;256        status = FLASH_WaitForLastOperation(EraseTimeout);
000028  f64070ff          MOV      r0,#0xfff
00002c  f7fffffe          BL       FLASH_WaitForLastOperation
000030  4604              MOV      r4,r0
;;;257        if(status != FLASH_BUSY)
000032  2c01              CMP      r4,#1
000034  d006              BEQ      |L3.68|
;;;258        {
;;;259          /* if the erase operation is completed, disable the MER Bit */
;;;260          FLASH->CR &= CR_MER_Reset;
000036  4804              LDR      r0,|L3.72|
000038  6900              LDR      r0,[r0,#0x10]
00003a  f64171fb          MOV      r1,#0x1ffb
00003e  4008              ANDS     r0,r0,r1
000040  4901              LDR      r1,|L3.72|
000042  6108              STR      r0,[r1,#0x10]
                  |L3.68|
;;;261        }
;;;262      }	   
;;;263      /* Return the Erase Status */
;;;264      return status;
000044  4620              MOV      r0,r4
;;;265    }
000046  bd10              POP      {r4,pc}
;;;266    
                          ENDP

                  |L3.72|
                          DCD      0x40022000

                          AREA ||i.FLASH_EraseOptionBytes||, CODE, READONLY, ALIGN=2

                  FLASH_EraseOptionBytes PROC
;;;273      */
;;;274    FLASH_Status FLASH_EraseOptionBytes(void)
000000  b510              PUSH     {r4,lr}
;;;275    {
;;;276      FLASH_Status status = FLASH_COMPLETE;
000002  2404              MOVS     r4,#4
;;;277      
;;;278      /* Wait for last operation to be completed */
;;;279      status = FLASH_WaitForLastOperation(EraseTimeout);
000004  f64070ff          MOV      r0,#0xfff
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4604              MOV      r4,r0
;;;280      if(status == FLASH_COMPLETE)
00000e  2c04              CMP      r4,#4
000010  d13b              BNE      |L4.138|
;;;281      {
;;;282        /* Authorize the small information block programming */
;;;283        FLASH->OPTKEYR = FLASH_KEY1;
000012  481f              LDR      r0,|L4.144|
000014  491f              LDR      r1,|L4.148|
000016  6088              STR      r0,[r1,#8]
;;;284        FLASH->OPTKEYR = FLASH_KEY2;
000018  481f              LDR      r0,|L4.152|
00001a  6088              STR      r0,[r1,#8]
;;;285        
;;;286        /* if the previous operation is completed, proceed to erase the option bytes */
;;;287        FLASH->CR |= CR_OPTER_Set;
00001c  4608              MOV      r0,r1
00001e  6900              LDR      r0,[r0,#0x10]
000020  f0400020          ORR      r0,r0,#0x20
000024  6108              STR      r0,[r1,#0x10]
;;;288        FLASH->CR |= CR_STRT_Set;
000026  4608              MOV      r0,r1
000028  6900              LDR      r0,[r0,#0x10]
00002a  f0400040          ORR      r0,r0,#0x40
00002e  6108              STR      r0,[r1,#0x10]
;;;289        /* Wait for last operation to be completed */
;;;290        status = FLASH_WaitForLastOperation(EraseTimeout);
000030  f64070ff          MOV      r0,#0xfff
000034  f7fffffe          BL       FLASH_WaitForLastOperation
000038  4604              MOV      r4,r0
;;;291        
;;;292        if(status == FLASH_COMPLETE)
00003a  2c04              CMP      r4,#4
00003c  d11c              BNE      |L4.120|
;;;293        {
;;;294          /* if the erase operation is completed, disable the OPTER Bit */
;;;295          FLASH->CR &= CR_OPTER_Reset;
00003e  4815              LDR      r0,|L4.148|
000040  6900              LDR      r0,[r0,#0x10]
000042  f64171df          MOV      r1,#0x1fdf
000046  4008              ANDS     r0,r0,r1
000048  4912              LDR      r1,|L4.148|
00004a  6108              STR      r0,[r1,#0x10]
;;;296           
;;;297          /* Enable the Option Bytes Programming operation */
;;;298          FLASH->CR |= CR_OPTPG_Set;
00004c  4608              MOV      r0,r1
00004e  6900              LDR      r0,[r0,#0x10]
000050  f0400010          ORR      r0,r0,#0x10
000054  6108              STR      r0,[r1,#0x10]
;;;299          /* Enable the readout access */
;;;300          OB->RDP= RDP_Key; 
000056  20a5              MOVS     r0,#0xa5
000058  4910              LDR      r1,|L4.156|
00005a  8008              STRH     r0,[r1,#0]
;;;301          /* Wait for last operation to be completed */
;;;302          status = FLASH_WaitForLastOperation(ProgramTimeout);
00005c  200f              MOVS     r0,#0xf
00005e  f7fffffe          BL       FLASH_WaitForLastOperation
000062  4604              MOV      r4,r0
;;;303     
;;;304          if(status != FLASH_BUSY)
000064  2c01              CMP      r4,#1
000066  d010              BEQ      |L4.138|
;;;305          {
;;;306            /* if the program operation is completed, disable the OPTPG Bit */
;;;307            FLASH->CR &= CR_OPTPG_Reset;
000068  480a              LDR      r0,|L4.148|
00006a  6900              LDR      r0,[r0,#0x10]
00006c  f64171ef          MOV      r1,#0x1fef
000070  4008              ANDS     r0,r0,r1
000072  4908              LDR      r1,|L4.148|
000074  6108              STR      r0,[r1,#0x10]
000076  e008              B        |L4.138|
                  |L4.120|
;;;308          }
;;;309        }
;;;310        else
;;;311        {
;;;312          if (status != FLASH_BUSY)
000078  2c01              CMP      r4,#1
00007a  d006              BEQ      |L4.138|
;;;313          {
;;;314            /* Disable the OPTPG Bit */
;;;315            FLASH->CR &= CR_OPTPG_Reset;
00007c  4805              LDR      r0,|L4.148|
00007e  6900              LDR      r0,[r0,#0x10]
000080  f64171ef          MOV      r1,#0x1fef
000084  4008              ANDS     r0,r0,r1
000086  4903              LDR      r1,|L4.148|
000088  6108              STR      r0,[r1,#0x10]
                  |L4.138|
;;;316          }
;;;317        }  
;;;318      }
;;;319      /* Return the erase status */
;;;320      return status;
00008a  4620              MOV      r0,r4
;;;321    }
00008c  bd10              POP      {r4,pc}
;;;322    
                          ENDP

00008e  0000              DCW      0x0000
                  |L4.144|
                          DCD      0x45670123
                  |L4.148|
                          DCD      0x40022000
                  |L4.152|
                          DCD      0xcdef89ab
                  |L4.156|
                          DCD      0x1ffff800

                          AREA ||i.FLASH_ErasePage||, CODE, READONLY, ALIGN=2

                  FLASH_ErasePage PROC
;;;208      */
;;;209    FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
000000  b570              PUSH     {r4-r6,lr}
;;;210    {
000002  4605              MOV      r5,r0
;;;211      FLASH_Status status = FLASH_COMPLETE;
000004  2404              MOVS     r4,#4
;;;212      /* Check the parameters */
;;;213      assert_param(IS_FLASH_ADDRESS(Page_Address));
;;;214      /* Wait for last operation to be completed */
;;;215      status = FLASH_WaitForLastOperation(EraseTimeout);
000006  f64070ff          MOV      r0,#0xfff
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;216      
;;;217      if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d119              BNE      |L5.72|
;;;218      { 
;;;219        /* if the previous operation is completed, proceed to erase the page */
;;;220        FLASH->CR|= CR_PER_Set;
000014  480d              LDR      r0,|L5.76|
000016  6900              LDR      r0,[r0,#0x10]
000018  f0400002          ORR      r0,r0,#2
00001c  490b              LDR      r1,|L5.76|
00001e  6108              STR      r0,[r1,#0x10]
;;;221        FLASH->AR = Page_Address; 
000020  4608              MOV      r0,r1
000022  6145              STR      r5,[r0,#0x14]
;;;222        FLASH->CR|= CR_STRT_Set;
000024  6900              LDR      r0,[r0,#0x10]
000026  f0400040          ORR      r0,r0,#0x40
00002a  6108              STR      r0,[r1,#0x10]
;;;223        
;;;224        /* Wait for last operation to be completed */
;;;225        status = FLASH_WaitForLastOperation(EraseTimeout);
00002c  f64070ff          MOV      r0,#0xfff
000030  f7fffffe          BL       FLASH_WaitForLastOperation
000034  4604              MOV      r4,r0
;;;226        if(status != FLASH_BUSY)
000036  2c01              CMP      r4,#1
000038  d006              BEQ      |L5.72|
;;;227        {
;;;228          /* if the erase operation is completed, disable the PER Bit */
;;;229          FLASH->CR &= CR_PER_Reset;
00003a  4804              LDR      r0,|L5.76|
00003c  6900              LDR      r0,[r0,#0x10]
00003e  f64171fd          MOV      r1,#0x1ffd
000042  4008              ANDS     r0,r0,r1
000044  4901              LDR      r1,|L5.76|
000046  6108              STR      r0,[r1,#0x10]
                  |L5.72|
;;;230        }
;;;231      }
;;;232      /* Return the Erase Status */
;;;233      return status;
000048  4620              MOV      r0,r4
;;;234    }
00004a  bd70              POP      {r4-r6,pc}
;;;235    
                          ENDP

                  |L5.76|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetFlagStatus PROC
;;;741      */
;;;742    FlagStatus FLASH_GetFlagStatus(uint16_t FLASH_FLAG)
000000  4601              MOV      r1,r0
;;;743    {
;;;744      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;745      /* Check the parameters */
;;;746      assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
;;;747      if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
000004  2901              CMP      r1,#1
000006  d108              BNE      |L6.26|
;;;748      {
;;;749        if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
000008  4a08              LDR      r2,|L6.44|
00000a  69d2              LDR      r2,[r2,#0x1c]
00000c  f0020201          AND      r2,r2,#1
000010  b10a              CBZ      r2,|L6.22|
;;;750        {
;;;751          bitstatus = SET;
000012  2001              MOVS     r0,#1
000014  e008              B        |L6.40|
                  |L6.22|
;;;752        }
;;;753        else
;;;754        {
;;;755          bitstatus = RESET;
000016  2000              MOVS     r0,#0
000018  e006              B        |L6.40|
                  |L6.26|
;;;756        }
;;;757      }
;;;758      else
;;;759      {
;;;760       if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
00001a  4a04              LDR      r2,|L6.44|
00001c  68d2              LDR      r2,[r2,#0xc]
00001e  400a              ANDS     r2,r2,r1
000020  b10a              CBZ      r2,|L6.38|
;;;761        {
;;;762          bitstatus = SET;
000022  2001              MOVS     r0,#1
000024  e000              B        |L6.40|
                  |L6.38|
;;;763        }
;;;764        else
;;;765        {
;;;766          bitstatus = RESET;
000026  2000              MOVS     r0,#0
                  |L6.40|
;;;767        }
;;;768      }
;;;769      /* Return the new state of FLASH_FLAG (SET or RESET) */
;;;770      return bitstatus;
;;;771    }
000028  4770              BX       lr
;;;772    
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetPrefetchBufferStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetPrefetchBufferStatus PROC
;;;686      */
;;;687    FlagStatus FLASH_GetPrefetchBufferStatus(void)
000000  2000              MOVS     r0,#0
;;;688    {
;;;689      FlagStatus bitstatus = RESET;
;;;690      
;;;691      if ((FLASH->ACR & ACR_PRFTBS_Mask) != (uint32_t)RESET)
000002  4904              LDR      r1,|L7.20|
000004  6809              LDR      r1,[r1,#0]
000006  f0010120          AND      r1,r1,#0x20
00000a  b109              CBZ      r1,|L7.16|
;;;692      {
;;;693        bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L7.18|
                  |L7.16|
;;;694      }
;;;695      else
;;;696      {
;;;697        bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L7.18|
;;;698      }
;;;699      /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
;;;700      return bitstatus; 
;;;701    }
000012  4770              BX       lr
;;;702    
                          ENDP

                  |L7.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetReadOutProtectionStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetReadOutProtectionStatus PROC
;;;667      */
;;;668    FlagStatus FLASH_GetReadOutProtectionStatus(void)
000000  2000              MOVS     r0,#0
;;;669    {
;;;670      FlagStatus readoutstatus = RESET;
;;;671      if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)
000002  4904              LDR      r1,|L8.20|
000004  69c9              LDR      r1,[r1,#0x1c]
000006  f0010102          AND      r1,r1,#2
00000a  b109              CBZ      r1,|L8.16|
;;;672      {
;;;673        readoutstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L8.18|
                  |L8.16|
;;;674      }
;;;675      else
;;;676      {
;;;677        readoutstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L8.18|
;;;678      }
;;;679      return readoutstatus;
;;;680    }
000012  4770              BX       lr
;;;681    
                          ENDP

                  |L8.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetStatus PROC
;;;797      */
;;;798    FLASH_Status FLASH_GetStatus(void)
000000  2004              MOVS     r0,#4
;;;799    {
;;;800      FLASH_Status flashstatus = FLASH_COMPLETE;
;;;801      
;;;802      if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
000002  490b              LDR      r1,|L9.48|
000004  68c9              LDR      r1,[r1,#0xc]
000006  f0010101          AND      r1,r1,#1
00000a  b109              CBZ      r1,|L9.16|
;;;803      {
;;;804        flashstatus = FLASH_BUSY;
00000c  2001              MOVS     r0,#1
00000e  e00e              B        |L9.46|
                  |L9.16|
;;;805      }
;;;806      else 
;;;807      {  
;;;808        if(FLASH->SR & FLASH_FLAG_PGERR)
000010  4907              LDR      r1,|L9.48|
000012  68c9              LDR      r1,[r1,#0xc]
000014  f0010104          AND      r1,r1,#4
000018  b109              CBZ      r1,|L9.30|
;;;809        { 
;;;810          flashstatus = FLASH_ERROR_PG;
00001a  2002              MOVS     r0,#2
00001c  e007              B        |L9.46|
                  |L9.30|
;;;811        }
;;;812        else 
;;;813        {
;;;814          if(FLASH->SR & FLASH_FLAG_WRPRTERR)
00001e  4904              LDR      r1,|L9.48|
000020  68c9              LDR      r1,[r1,#0xc]
000022  f0010110          AND      r1,r1,#0x10
000026  b109              CBZ      r1,|L9.44|
;;;815          {
;;;816            flashstatus = FLASH_ERROR_WRP;
000028  2003              MOVS     r0,#3
00002a  e000              B        |L9.46|
                  |L9.44|
;;;817          }
;;;818          else
;;;819          {
;;;820            flashstatus = FLASH_COMPLETE;
00002c  2004              MOVS     r0,#4
                  |L9.46|
;;;821          }
;;;822        }
;;;823      }
;;;824      /* Return the Flash Status */
;;;825      return flashstatus;
;;;826    }
00002e  4770              BX       lr
;;;827    
                          ENDP

                  |L9.48|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetUserOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetUserOptionByte PROC
;;;644      */
;;;645    uint32_t FLASH_GetUserOptionByte(void)
000000  4801              LDR      r0,|L10.8|
;;;646    {
;;;647      /* Return the User Option Byte */
;;;648      return (uint32_t)(FLASH->OBR >> 2);
000002  69c0              LDR      r0,[r0,#0x1c]
000004  0880              LSRS     r0,r0,#2
;;;649    }
000006  4770              BX       lr
;;;650    
                          ENDP

                  |L10.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetWriteProtectionOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetWriteProtectionOptionByte PROC
;;;655      */
;;;656    uint32_t FLASH_GetWriteProtectionOptionByte(void)
000000  4801              LDR      r0,|L11.8|
;;;657    {
;;;658      /* Return the Falsh write protection Register value */
;;;659      return (uint32_t)(FLASH->WRPR);
000002  6a00              LDR      r0,[r0,#0x20]
;;;660    }
000004  4770              BX       lr
;;;661    
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_HalfCycleAccessCmd||, CODE, READONLY, ALIGN=2

                  FLASH_HalfCycleAccessCmd PROC
;;;150      */
;;;151    void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess)
000000  4905              LDR      r1,|L12.24|
;;;152    {
;;;153      /* Check the parameters */
;;;154      assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
;;;155      
;;;156      /* Enable or disable the Half cycle access */
;;;157      FLASH->ACR &= ACR_HLFCYA_Mask;
000002  6809              LDR      r1,[r1,#0]
000004  f0210108          BIC      r1,r1,#8
000008  4a03              LDR      r2,|L12.24|
00000a  6011              STR      r1,[r2,#0]
;;;158      FLASH->ACR |= FLASH_HalfCycleAccess;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;159    }
000014  4770              BX       lr
;;;160    
                          ENDP

000016  0000              DCW      0x0000
                  |L12.24|
                          DCD      0x40022000

                          AREA ||i.FLASH_ITConfig||, CODE, READONLY, ALIGN=2

                  FLASH_ITConfig PROC
;;;713      */
;;;714    void FLASH_ITConfig(uint16_t FLASH_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L13.14|
;;;715    {
;;;716      /* Check the parameters */
;;;717      assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;718      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;719      if(NewState != DISABLE)
;;;720      {
;;;721        /* Enable the interrupt sources */
;;;722        FLASH->CR |= FLASH_IT;
000002  4a06              LDR      r2,|L13.28|
000004  6912              LDR      r2,[r2,#0x10]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L13.28|
00000a  611a              STR      r2,[r3,#0x10]
00000c  e004              B        |L13.24|
                  |L13.14|
;;;723      }
;;;724      else
;;;725      {
;;;726        /* Disable the interrupt sources */
;;;727        FLASH->CR &= ~(uint32_t)FLASH_IT;
00000e  4a03              LDR      r2,|L13.28|
000010  6912              LDR      r2,[r2,#0x10]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L13.28|
000016  611a              STR      r2,[r3,#0x10]
                  |L13.24|
;;;728      }
;;;729    }
000018  4770              BX       lr
;;;730    
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      0x40022000

                          AREA ||i.FLASH_Lock||, CODE, READONLY, ALIGN=2

                  FLASH_Lock PROC
;;;195      */
;;;196    void FLASH_Lock(void)
000000  4803              LDR      r0,|L14.16|
;;;197    {
;;;198      /* Set the Lock Bit to lock the FPEC and the FCR */
;;;199      FLASH->CR |= CR_LOCK_Set;
000002  6900              LDR      r0,[r0,#0x10]
000004  f0400080          ORR      r0,r0,#0x80
000008  4901              LDR      r1,|L14.16|
00000a  6108              STR      r0,[r1,#0x10]
;;;200    }
00000c  4770              BX       lr
;;;201    
                          ENDP

00000e  0000              DCW      0x0000
                  |L14.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_PrefetchBufferCmd||, CODE, READONLY, ALIGN=2

                  FLASH_PrefetchBufferCmd PROC
;;;168      */
;;;169    void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)
000000  4905              LDR      r1,|L15.24|
;;;170    {
;;;171      /* Check the parameters */
;;;172      assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
;;;173      
;;;174      /* Enable or disable the Prefetch Buffer */
;;;175      FLASH->ACR &= ACR_PRFTBE_Mask;
000002  6809              LDR      r1,[r1,#0]
000004  f0210110          BIC      r1,r1,#0x10
000008  4a03              LDR      r2,|L15.24|
00000a  6011              STR      r1,[r2,#0]
;;;176      FLASH->ACR |= FLASH_PrefetchBuffer;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  6011              STR      r1,[r2,#0]
;;;177    }
000014  4770              BX       lr
;;;178    
                          ENDP

000016  0000              DCW      0x0000
                  |L15.24|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramHalfWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramHalfWord PROC
;;;384      */
;;;385    FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;386    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;387      FLASH_Status status = FLASH_COMPLETE;
000006  2404              MOVS     r4,#4
;;;388      /* Check the parameters */
;;;389      assert_param(IS_FLASH_ADDRESS(Address));
;;;390      /* Wait for last operation to be completed */
;;;391      status = FLASH_WaitForLastOperation(ProgramTimeout);
000008  200f              MOVS     r0,#0xf
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;392      
;;;393      if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d113              BNE      |L16.60|
;;;394      {
;;;395        /* if the previous operation is completed, proceed to program the new data */
;;;396        FLASH->CR |= CR_PG_Set;
000014  480a              LDR      r0,|L16.64|
000016  6900              LDR      r0,[r0,#0x10]
000018  f0400001          ORR      r0,r0,#1
00001c  4908              LDR      r1,|L16.64|
00001e  6108              STR      r0,[r1,#0x10]
;;;397      
;;;398        *(__IO uint16_t*)Address = Data;
000020  802e              STRH     r6,[r5,#0]
;;;399        /* Wait for last operation to be completed */
;;;400        status = FLASH_WaitForLastOperation(ProgramTimeout);
000022  200f              MOVS     r0,#0xf
000024  f7fffffe          BL       FLASH_WaitForLastOperation
000028  4604              MOV      r4,r0
;;;401        if(status != FLASH_BUSY)
00002a  2c01              CMP      r4,#1
00002c  d006              BEQ      |L16.60|
;;;402        {
;;;403          /* if the program operation is completed, disable the PG Bit */
;;;404          FLASH->CR &= CR_PG_Reset;
00002e  4804              LDR      r0,|L16.64|
000030  6900              LDR      r0,[r0,#0x10]
000032  f64171fe          MOV      r1,#0x1ffe
000036  4008              ANDS     r0,r0,r1
000038  4901              LDR      r1,|L16.64|
00003a  6108              STR      r0,[r1,#0x10]
                  |L16.60|
;;;405        }
;;;406      } 
;;;407      /* Return the Program Status */
;;;408      return status;
00003c  4620              MOV      r0,r4
;;;409    }
00003e  bd70              POP      {r4-r6,pc}
;;;410    
                          ENDP

                  |L16.64|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramOptionByteData||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramOptionByteData PROC
;;;419      */
;;;420    FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;421    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;422      FLASH_Status status = FLASH_COMPLETE;
000006  2404              MOVS     r4,#4
;;;423      /* Check the parameters */
;;;424      assert_param(IS_OB_DATA_ADDRESS(Address));
;;;425      status = FLASH_WaitForLastOperation(ProgramTimeout);
000008  200f              MOVS     r0,#0xf
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;426      if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d117              BNE      |L17.68|
;;;427      {
;;;428        /* Authorize the small information block programming */
;;;429        FLASH->OPTKEYR = FLASH_KEY1;
000014  480c              LDR      r0,|L17.72|
000016  490d              LDR      r1,|L17.76|
000018  6088              STR      r0,[r1,#8]
;;;430        FLASH->OPTKEYR = FLASH_KEY2;
00001a  480d              LDR      r0,|L17.80|
00001c  6088              STR      r0,[r1,#8]
;;;431        /* Enables the Option Bytes Programming operation */
;;;432        FLASH->CR |= CR_OPTPG_Set; 
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400010          ORR      r0,r0,#0x10
000026  6108              STR      r0,[r1,#0x10]
;;;433        *(__IO uint16_t*)Address = Data;
000028  802e              STRH     r6,[r5,#0]
;;;434        
;;;435        /* Wait for last operation to be completed */
;;;436        status = FLASH_WaitForLastOperation(ProgramTimeout);
00002a  200f              MOVS     r0,#0xf
00002c  f7fffffe          BL       FLASH_WaitForLastOperation
000030  4604              MOV      r4,r0
;;;437        if(status != FLASH_BUSY)
000032  2c01              CMP      r4,#1
000034  d006              BEQ      |L17.68|
;;;438        {
;;;439          /* if the program operation is completed, disable the OPTPG Bit */
;;;440          FLASH->CR &= CR_OPTPG_Reset;
000036  4805              LDR      r0,|L17.76|
000038  6900              LDR      r0,[r0,#0x10]
00003a  f64171ef          MOV      r1,#0x1fef
00003e  4008              ANDS     r0,r0,r1
000040  4902              LDR      r1,|L17.76|
000042  6108              STR      r0,[r1,#0x10]
                  |L17.68|
;;;441        }
;;;442      }    
;;;443      /* Return the Option Byte Data Program Status */
;;;444      return status;
000044  4620              MOV      r0,r4
;;;445    }
000046  bd70              POP      {r4-r6,pc}
;;;446    
                          ENDP

                  |L17.72|
                          DCD      0x45670123
                  |L17.76|
                          DCD      0x40022000
                  |L17.80|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_ProgramWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramWord PROC
;;;330      */
;;;331    FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;332    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;333      FLASH_Status status = FLASH_COMPLETE;
000006  2404              MOVS     r4,#4
;;;334      /* Check the parameters */
;;;335      assert_param(IS_FLASH_ADDRESS(Address));
;;;336      /* Wait for last operation to be completed */
;;;337      status = FLASH_WaitForLastOperation(ProgramTimeout);
000008  200f              MOVS     r0,#0xf
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;338      
;;;339      if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d125              BNE      |L18.96|
;;;340      {
;;;341        /* if the previous operation is completed, proceed to program the new first 
;;;342        half word */
;;;343        FLASH->CR |= CR_PG_Set;
000014  4813              LDR      r0,|L18.100|
000016  6900              LDR      r0,[r0,#0x10]
000018  f0400001          ORR      r0,r0,#1
00001c  4911              LDR      r1,|L18.100|
00001e  6108              STR      r0,[r1,#0x10]
;;;344      
;;;345        *(__IO uint16_t*)Address = (uint16_t)Data;
000020  802e              STRH     r6,[r5,#0]
;;;346        /* Wait for last operation to be completed */
;;;347        status = FLASH_WaitForLastOperation(ProgramTimeout);
000022  200f              MOVS     r0,#0xf
000024  f7fffffe          BL       FLASH_WaitForLastOperation
000028  4604              MOV      r4,r0
;;;348     
;;;349        if(status == FLASH_COMPLETE)
00002a  2c04              CMP      r4,#4
00002c  d10f              BNE      |L18.78|
;;;350        {
;;;351          /* if the previous operation is completed, proceed to program the new second 
;;;352          half word */
;;;353          *(__IO uint16_t*)(Address + 2) = Data >> 16;
00002e  0c30              LSRS     r0,r6,#16
000030  8068              STRH     r0,[r5,#2]
;;;354        
;;;355          /* Wait for last operation to be completed */
;;;356          status = FLASH_WaitForLastOperation(ProgramTimeout);
000032  200f              MOVS     r0,#0xf
000034  f7fffffe          BL       FLASH_WaitForLastOperation
000038  4604              MOV      r4,r0
;;;357            
;;;358          if(status != FLASH_BUSY)
00003a  2c01              CMP      r4,#1
00003c  d010              BEQ      |L18.96|
;;;359          {
;;;360            /* Disable the PG Bit */
;;;361            FLASH->CR &= CR_PG_Reset;
00003e  4809              LDR      r0,|L18.100|
000040  6900              LDR      r0,[r0,#0x10]
000042  f64171fe          MOV      r1,#0x1ffe
000046  4008              ANDS     r0,r0,r1
000048  4906              LDR      r1,|L18.100|
00004a  6108              STR      r0,[r1,#0x10]
00004c  e008              B        |L18.96|
                  |L18.78|
;;;362          }
;;;363        }
;;;364        else
;;;365        {
;;;366          if (status != FLASH_BUSY)
00004e  2c01              CMP      r4,#1
000050  d006              BEQ      |L18.96|
;;;367          {
;;;368            /* Disable the PG Bit */
;;;369            FLASH->CR &= CR_PG_Reset;
000052  4804              LDR      r0,|L18.100|
000054  6900              LDR      r0,[r0,#0x10]
000056  f64171fe          MOV      r1,#0x1ffe
00005a  4008              ANDS     r0,r0,r1
00005c  4901              LDR      r1,|L18.100|
00005e  6108              STR      r0,[r1,#0x10]
                  |L18.96|
;;;370          }
;;;371         }
;;;372      }
;;;373      /* Return the Program Status */
;;;374      return status;
000060  4620              MOV      r0,r4
;;;375    }
000062  bd70              POP      {r4-r6,pc}
;;;376    
                          ENDP

                  |L18.100|
                          DCD      0x40022000

                          AREA ||i.FLASH_ReadOutProtection||, CODE, READONLY, ALIGN=2

                  FLASH_ReadOutProtection PROC
;;;535      */
;;;536    FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;537    {
000002  4605              MOV      r5,r0
;;;538      FLASH_Status status = FLASH_COMPLETE;
000004  2404              MOVS     r4,#4
;;;539      /* Check the parameters */
;;;540      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;541      status = FLASH_WaitForLastOperation(EraseTimeout);
000006  f64070ff          MOV      r0,#0xfff
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4604              MOV      r4,r0
;;;542      if(status == FLASH_COMPLETE)
000010  2c04              CMP      r4,#4
000012  d141              BNE      |L19.152|
;;;543      {
;;;544        /* Authorizes the small information block programming */
;;;545        FLASH->OPTKEYR = FLASH_KEY1;
000014  4821              LDR      r0,|L19.156|
000016  4922              LDR      r1,|L19.160|
000018  6088              STR      r0,[r1,#8]
;;;546        FLASH->OPTKEYR = FLASH_KEY2;
00001a  4822              LDR      r0,|L19.164|
00001c  6088              STR      r0,[r1,#8]
;;;547        FLASH->CR |= CR_OPTER_Set;
00001e  4608              MOV      r0,r1
000020  6900              LDR      r0,[r0,#0x10]
000022  f0400020          ORR      r0,r0,#0x20
000026  6108              STR      r0,[r1,#0x10]
;;;548        FLASH->CR |= CR_STRT_Set;
000028  4608              MOV      r0,r1
00002a  6900              LDR      r0,[r0,#0x10]
00002c  f0400040          ORR      r0,r0,#0x40
000030  6108              STR      r0,[r1,#0x10]
;;;549        /* Wait for last operation to be completed */
;;;550        status = FLASH_WaitForLastOperation(EraseTimeout);
000032  f64070ff          MOV      r0,#0xfff
000036  f7fffffe          BL       FLASH_WaitForLastOperation
00003a  4604              MOV      r4,r0
;;;551        if(status == FLASH_COMPLETE)
00003c  2c04              CMP      r4,#4
00003e  d122              BNE      |L19.134|
;;;552        {
;;;553          /* if the erase operation is completed, disable the OPTER Bit */
;;;554          FLASH->CR &= CR_OPTER_Reset;
000040  4817              LDR      r0,|L19.160|
000042  6900              LDR      r0,[r0,#0x10]
000044  f64171df          MOV      r1,#0x1fdf
000048  4008              ANDS     r0,r0,r1
00004a  4915              LDR      r1,|L19.160|
00004c  6108              STR      r0,[r1,#0x10]
;;;555          /* Enable the Option Bytes Programming operation */
;;;556          FLASH->CR |= CR_OPTPG_Set; 
00004e  4608              MOV      r0,r1
000050  6900              LDR      r0,[r0,#0x10]
000052  f0400010          ORR      r0,r0,#0x10
000056  6108              STR      r0,[r1,#0x10]
;;;557          if(NewState != DISABLE)
000058  b11d              CBZ      r5,|L19.98|
;;;558          {
;;;559            OB->RDP = 0x00;
00005a  2000              MOVS     r0,#0
00005c  4912              LDR      r1,|L19.168|
00005e  8008              STRH     r0,[r1,#0]
000060  e002              B        |L19.104|
                  |L19.98|
;;;560          }
;;;561          else
;;;562          {
;;;563            OB->RDP = RDP_Key;  
000062  20a5              MOVS     r0,#0xa5
000064  4910              LDR      r1,|L19.168|
000066  8008              STRH     r0,[r1,#0]
                  |L19.104|
;;;564          }
;;;565          /* Wait for last operation to be completed */
;;;566          status = FLASH_WaitForLastOperation(EraseTimeout); 
000068  f64070ff          MOV      r0,#0xfff
00006c  f7fffffe          BL       FLASH_WaitForLastOperation
000070  4604              MOV      r4,r0
;;;567        
;;;568          if(status != FLASH_BUSY)
000072  2c01              CMP      r4,#1
000074  d010              BEQ      |L19.152|
;;;569          {
;;;570            /* if the program operation is completed, disable the OPTPG Bit */
;;;571            FLASH->CR &= CR_OPTPG_Reset;
000076  480a              LDR      r0,|L19.160|
000078  6900              LDR      r0,[r0,#0x10]
00007a  f64171ef          MOV      r1,#0x1fef
00007e  4008              ANDS     r0,r0,r1
000080  4907              LDR      r1,|L19.160|
000082  6108              STR      r0,[r1,#0x10]
000084  e008              B        |L19.152|
                  |L19.134|
;;;572          }
;;;573        }
;;;574        else 
;;;575        {
;;;576          if(status != FLASH_BUSY)
000086  2c01              CMP      r4,#1
000088  d006              BEQ      |L19.152|
;;;577          {
;;;578            /* Disable the OPTER Bit */
;;;579            FLASH->CR &= CR_OPTER_Reset;
00008a  4805              LDR      r0,|L19.160|
00008c  6900              LDR      r0,[r0,#0x10]
00008e  f64171df          MOV      r1,#0x1fdf
000092  4008              ANDS     r0,r0,r1
000094  4902              LDR      r1,|L19.160|
000096  6108              STR      r0,[r1,#0x10]
                  |L19.152|
;;;580          }
;;;581        }
;;;582      }
;;;583      /* Return the protection operation Status */
;;;584      return status;      
000098  4620              MOV      r0,r4
;;;585    }
00009a  bd70              POP      {r4-r6,pc}
;;;586    
                          ENDP

                  |L19.156|
                          DCD      0x45670123
                  |L19.160|
                          DCD      0x40022000
                  |L19.164|
                          DCD      0xcdef89ab
                  |L19.168|
                          DCD      0x1ffff800

                          AREA ||i.FLASH_SetLatency||, CODE, READONLY, ALIGN=2

                  FLASH_SetLatency PROC
;;;124      */
;;;125    void FLASH_SetLatency(uint32_t FLASH_Latency)
000000  4601              MOV      r1,r0
;;;126    {
;;;127      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;128      
;;;129      /* Check the parameters */
;;;130      assert_param(IS_FLASH_LATENCY(FLASH_Latency));
;;;131      
;;;132      /* Read the ACR register */
;;;133      tmpreg = FLASH->ACR;  
000004  4a03              LDR      r2,|L20.20|
000006  6810              LDR      r0,[r2,#0]
;;;134      
;;;135      /* Sets the Latency value */
;;;136      tmpreg &= ACR_LATENCY_Mask;
000008  f0000038          AND      r0,r0,#0x38
;;;137      tmpreg |= FLASH_Latency;
00000c  4308              ORRS     r0,r0,r1
;;;138      
;;;139      /* Write the ACR register */
;;;140      FLASH->ACR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;141    }
000010  4770              BX       lr
;;;142    
                          ENDP

000012  0000              DCW      0x0000
                  |L20.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_Unlock||, CODE, READONLY, ALIGN=2

                  FLASH_Unlock PROC
;;;183      */
;;;184    void FLASH_Unlock(void)
000000  4802              LDR      r0,|L21.12|
;;;185    {
;;;186      /* Authorize the FPEC Access */
;;;187      FLASH->KEYR = FLASH_KEY1;
000002  4903              LDR      r1,|L21.16|
000004  6048              STR      r0,[r1,#4]
;;;188      FLASH->KEYR = FLASH_KEY2;
000006  4803              LDR      r0,|L21.20|
000008  6048              STR      r0,[r1,#4]
;;;189    }
00000a  4770              BX       lr
;;;190    
                          ENDP

                  |L21.12|
                          DCD      0x45670123
                  |L21.16|
                          DCD      0x40022000
                  |L21.20|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_UserOptionByteConfig||, CODE, READONLY, ALIGN=2

                  FLASH_UserOptionByteConfig PROC
;;;605      */
;;;606    FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;607    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;608      FLASH_Status status = FLASH_COMPLETE; 
00000a  2404              MOVS     r4,#4
;;;609      /* Check the parameters */
;;;610      assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
;;;611      assert_param(IS_OB_STOP_SOURCE(OB_STOP));
;;;612      assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
;;;613      /* Authorize the small information block programming */
;;;614      FLASH->OPTKEYR = FLASH_KEY1;
00000c  4813              LDR      r0,|L22.92|
00000e  4914              LDR      r1,|L22.96|
000010  6088              STR      r0,[r1,#8]
;;;615      FLASH->OPTKEYR = FLASH_KEY2;
000012  4814              LDR      r0,|L22.100|
000014  6088              STR      r0,[r1,#8]
;;;616      
;;;617      /* Wait for last operation to be completed */
;;;618      status = FLASH_WaitForLastOperation(ProgramTimeout);
000016  200f              MOVS     r0,#0xf
000018  f7fffffe          BL       FLASH_WaitForLastOperation
00001c  4604              MOV      r4,r0
;;;619      
;;;620      if(status == FLASH_COMPLETE)
00001e  2c04              CMP      r4,#4
000020  d119              BNE      |L22.86|
;;;621      {  
;;;622        /* Enable the Option Bytes Programming operation */
;;;623        FLASH->CR |= CR_OPTPG_Set; 
000022  480f              LDR      r0,|L22.96|
000024  6900              LDR      r0,[r0,#0x10]
000026  f0400010          ORR      r0,r0,#0x10
00002a  490d              LDR      r1,|L22.96|
00002c  6108              STR      r0,[r1,#0x10]
;;;624               
;;;625        OB->USER = ( OB_IWDG | OB_STOP |OB_STDBY) | (uint16_t)0xF8; 
00002e  ea470005          ORR      r0,r7,r5
000032  4330              ORRS     r0,r0,r6
000034  f04000f8          ORR      r0,r0,#0xf8
000038  490b              LDR      r1,|L22.104|
00003a  8008              STRH     r0,[r1,#0]
;;;626      
;;;627        /* Wait for last operation to be completed */
;;;628        status = FLASH_WaitForLastOperation(ProgramTimeout);
00003c  200f              MOVS     r0,#0xf
00003e  f7fffffe          BL       FLASH_WaitForLastOperation
000042  4604              MOV      r4,r0
;;;629        if(status != FLASH_BUSY)
000044  2c01              CMP      r4,#1
000046  d006              BEQ      |L22.86|
;;;630        {
;;;631          /* if the program operation is completed, disable the OPTPG Bit */
;;;632          FLASH->CR &= CR_OPTPG_Reset;
000048  4805              LDR      r0,|L22.96|
00004a  6900              LDR      r0,[r0,#0x10]
00004c  f64171ef          MOV      r1,#0x1fef
000050  4008              ANDS     r0,r0,r1
000052  4903              LDR      r1,|L22.96|
000054  6108              STR      r0,[r1,#0x10]
                  |L22.86|
;;;633        }
;;;634      }    
;;;635      /* Return the Option Byte program Status */
;;;636      return status;
000056  4620              MOV      r0,r4
;;;637    }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;638    
                          ENDP

                  |L22.92|
                          DCD      0x45670123
                  |L22.96|
                          DCD      0x40022000
                  |L22.100|
                          DCD      0xcdef89ab
                  |L22.104|
                          DCD      0x1ffff802

                          AREA ||i.FLASH_WaitForLastOperation||, CODE, READONLY, ALIGN=1

                  FLASH_WaitForLastOperation PROC
;;;834      */
;;;835    FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;836    { 
000002  4604              MOV      r4,r0
;;;837      FLASH_Status status = FLASH_COMPLETE;
000004  2504              MOVS     r5,#4
;;;838       
;;;839      /* Check for the Flash Status */
;;;840      status = FLASH_GetStatus();
000006  f7fffffe          BL       FLASH_GetStatus
00000a  4605              MOV      r5,r0
;;;841      /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;842      while((status == FLASH_BUSY) && (Timeout != 0x00))
00000c  e005              B        |L23.26|
                  |L23.14|
;;;843      {
;;;844        delay();
00000e  f7fffffe          BL       delay
;;;845        status = FLASH_GetStatus();
000012  f7fffffe          BL       FLASH_GetStatus
000016  4605              MOV      r5,r0
;;;846        Timeout--;
000018  1e64              SUBS     r4,r4,#1
                  |L23.26|
00001a  2d01              CMP      r5,#1                 ;842
00001c  d101              BNE      |L23.34|
00001e  2c00              CMP      r4,#0                 ;842
000020  d1f5              BNE      |L23.14|
                  |L23.34|
;;;847      }
;;;848      if(Timeout == 0x00 )
000022  b904              CBNZ     r4,|L23.38|
;;;849      {
;;;850        status = FLASH_TIMEOUT;
000024  2505              MOVS     r5,#5
                  |L23.38|
;;;851      }
;;;852      /* Return the operation status */
;;;853      return status;
000026  4628              MOV      r0,r5
;;;854    }
000028  bd70              POP      {r4-r6,pc}
;;;855    
                          ENDP


                          AREA ||i.delay||, CODE, READONLY, ALIGN=1

                  delay PROC
;;;860      */
;;;861    static void delay(void)
000000  b508              PUSH     {r3,lr}
;;;862    {
;;;863      __IO uint32_t i = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;864      for(i = 0xFF; i != 0; i--)
000006  20ff              MOVS     r0,#0xff
000008  9000              STR      r0,[sp,#0]
00000a  e002              B        |L24.18|
                  |L24.12|
00000c  9800              LDR      r0,[sp,#0]
00000e  1e40              SUBS     r0,r0,#1
000010  9000              STR      r0,[sp,#0]
                  |L24.18|
000012  9800              LDR      r0,[sp,#0]
000014  2800              CMP      r0,#0
000016  d1f9              BNE      |L24.12|
;;;865      {
;;;866      }
;;;867    }
000018  bd08              POP      {r3,pc}
;;;868    
                          ENDP

