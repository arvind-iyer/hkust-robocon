; generated by ARM C/C++ Compiler, 4.1 [Build 713]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\configuration.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\configuration.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -IE:\UST\Robocon2012\KEIL\ARM\CMSIS\Include -IE:\UST\Robocon2012\KEIL\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\obj\configuration.crf user\configuration.c]
                          THUMB

                          AREA ||i.ADC_Configuration||, CODE, READONLY, ALIGN=2

                  ADC_Configuration PROC
;;;52     
;;;53     void ADC_Configuration()
000000  b500              PUSH     {lr}
;;;54     {
000002  b085              SUB      sp,sp,#0x14
;;;55     	ADC_InitTypeDef ADC_InitStructure;
;;;56     	/* ADC1 configuration ------------------------------------------------------*/
;;;57     	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
000004  f04f0000          MOV      r0,#0
000008  9000              STR      r0,[sp,#0]
;;;58     	ADC_InitStructure.ADC_ScanConvMode = ENABLE;
00000a  f04f0001          MOV      r0,#1
00000e  f88d0004          STRB     r0,[sp,#4]
;;;59     	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
000012  f88d0005          STRB     r0,[sp,#5]
;;;60     	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; 	//转换由软件而不是外部触发
000016  f44f2060          MOV      r0,#0xe0000
00001a  9002              STR      r0,[sp,#8]
;;;61     	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
00001c  f04f0000          MOV      r0,#0
000020  9003              STR      r0,[sp,#0xc]
;;;62     	ADC_InitStructure.ADC_NbrOfChannel = 16;
000022  f04f0010          MOV      r0,#0x10
000026  f88d0010          STRB     r0,[sp,#0x10]
;;;63     	ADC_Init(ADC1, &ADC_InitStructure);
00002a  4669              MOV      r1,sp
00002c  4841              LDR      r0,|L1.308|
00002e  f7fffffe          BL       ADC_Init
;;;64     	
;;;65     	/* Config all the channels --------------------------------------------------*/
;;;66     	ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_239Cycles5);
000032  2307              MOVS     r3,#7
000034  2201              MOVS     r2,#1
000036  2100              MOVS     r1,#0
000038  483e              LDR      r0,|L1.308|
00003a  f7fffffe          BL       ADC_RegularChannelConfig
;;;67     	ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 2, ADC_SampleTime_239Cycles5);
00003e  2307              MOVS     r3,#7
000040  2202              MOVS     r2,#2
000042  2101              MOVS     r1,#1
000044  483b              LDR      r0,|L1.308|
000046  f7fffffe          BL       ADC_RegularChannelConfig
;;;68     	ADC_RegularChannelConfig(ADC1, ADC_Channel_2, 3, ADC_SampleTime_239Cycles5);
00004a  2307              MOVS     r3,#7
00004c  2203              MOVS     r2,#3
00004e  2102              MOVS     r1,#2
000050  4838              LDR      r0,|L1.308|
000052  f7fffffe          BL       ADC_RegularChannelConfig
;;;69     	ADC_RegularChannelConfig(ADC1, ADC_Channel_3, 4, ADC_SampleTime_239Cycles5);
000056  2307              MOVS     r3,#7
000058  2204              MOVS     r2,#4
00005a  2103              MOVS     r1,#3
00005c  4835              LDR      r0,|L1.308|
00005e  f7fffffe          BL       ADC_RegularChannelConfig
;;;70     	ADC_RegularChannelConfig(ADC1, ADC_Channel_4, 5, ADC_SampleTime_239Cycles5);
000062  2307              MOVS     r3,#7
000064  2205              MOVS     r2,#5
000066  2104              MOVS     r1,#4
000068  4832              LDR      r0,|L1.308|
00006a  f7fffffe          BL       ADC_RegularChannelConfig
;;;71     	ADC_RegularChannelConfig(ADC1, ADC_Channel_5, 6, ADC_SampleTime_239Cycles5);
00006e  2307              MOVS     r3,#7
000070  2206              MOVS     r2,#6
000072  2105              MOVS     r1,#5
000074  482f              LDR      r0,|L1.308|
000076  f7fffffe          BL       ADC_RegularChannelConfig
;;;72     	ADC_RegularChannelConfig(ADC1, ADC_Channel_6, 7, ADC_SampleTime_239Cycles5);
00007a  2307              MOVS     r3,#7
00007c  461a              MOV      r2,r3
00007e  2106              MOVS     r1,#6
000080  482c              LDR      r0,|L1.308|
000082  f7fffffe          BL       ADC_RegularChannelConfig
;;;73     	ADC_RegularChannelConfig(ADC1, ADC_Channel_7, 8, ADC_SampleTime_239Cycles5);
000086  2307              MOVS     r3,#7
000088  2208              MOVS     r2,#8
00008a  4619              MOV      r1,r3
00008c  4829              LDR      r0,|L1.308|
00008e  f7fffffe          BL       ADC_RegularChannelConfig
;;;74     	ADC_RegularChannelConfig(ADC1, ADC_Channel_8, 9, ADC_SampleTime_239Cycles5);
000092  2307              MOVS     r3,#7
000094  2209              MOVS     r2,#9
000096  2108              MOVS     r1,#8
000098  4826              LDR      r0,|L1.308|
00009a  f7fffffe          BL       ADC_RegularChannelConfig
;;;75     	ADC_RegularChannelConfig(ADC1, ADC_Channel_9, 10, ADC_SampleTime_239Cycles5);
00009e  2307              MOVS     r3,#7
0000a0  220a              MOVS     r2,#0xa
0000a2  2109              MOVS     r1,#9
0000a4  4823              LDR      r0,|L1.308|
0000a6  f7fffffe          BL       ADC_RegularChannelConfig
;;;76     	ADC_RegularChannelConfig(ADC1, ADC_Channel_10, 11, ADC_SampleTime_239Cycles5);
0000aa  2307              MOVS     r3,#7
0000ac  220b              MOVS     r2,#0xb
0000ae  210a              MOVS     r1,#0xa
0000b0  4820              LDR      r0,|L1.308|
0000b2  f7fffffe          BL       ADC_RegularChannelConfig
;;;77     	ADC_RegularChannelConfig(ADC1, ADC_Channel_11, 12, ADC_SampleTime_239Cycles5);
0000b6  2307              MOVS     r3,#7
0000b8  220c              MOVS     r2,#0xc
0000ba  210b              MOVS     r1,#0xb
0000bc  481d              LDR      r0,|L1.308|
0000be  f7fffffe          BL       ADC_RegularChannelConfig
;;;78     	ADC_RegularChannelConfig(ADC1, ADC_Channel_12, 13, ADC_SampleTime_239Cycles5);
0000c2  2307              MOVS     r3,#7
0000c4  220d              MOVS     r2,#0xd
0000c6  210c              MOVS     r1,#0xc
0000c8  481a              LDR      r0,|L1.308|
0000ca  f7fffffe          BL       ADC_RegularChannelConfig
;;;79     	ADC_RegularChannelConfig(ADC1, ADC_Channel_13, 14, ADC_SampleTime_239Cycles5);
0000ce  2307              MOVS     r3,#7
0000d0  220e              MOVS     r2,#0xe
0000d2  210d              MOVS     r1,#0xd
0000d4  4817              LDR      r0,|L1.308|
0000d6  f7fffffe          BL       ADC_RegularChannelConfig
;;;80     	ADC_RegularChannelConfig(ADC1, ADC_Channel_14, 15, ADC_SampleTime_239Cycles5);
0000da  2307              MOVS     r3,#7
0000dc  220f              MOVS     r2,#0xf
0000de  210e              MOVS     r1,#0xe
0000e0  4814              LDR      r0,|L1.308|
0000e2  f7fffffe          BL       ADC_RegularChannelConfig
;;;81     	ADC_RegularChannelConfig(ADC1, ADC_Channel_15, 16, ADC_SampleTime_239Cycles5);
0000e6  2307              MOVS     r3,#7
0000e8  2210              MOVS     r2,#0x10
0000ea  210f              MOVS     r1,#0xf
0000ec  4811              LDR      r0,|L1.308|
0000ee  f7fffffe          BL       ADC_RegularChannelConfig
;;;82     
;;;83     	/* Enable ADC1 DMA */
;;;84     	ADC_DMACmd(ADC1, ENABLE);
0000f2  2101              MOVS     r1,#1
0000f4  480f              LDR      r0,|L1.308|
0000f6  f7fffffe          BL       ADC_DMACmd
;;;85     	
;;;86     	/* Enable ADC1 */
;;;87     	ADC_Cmd(ADC1, ENABLE);
0000fa  2101              MOVS     r1,#1
0000fc  480d              LDR      r0,|L1.308|
0000fe  f7fffffe          BL       ADC_Cmd
;;;88     
;;;89     	/******************************************CALIBRATION******************************************/
;;;90     	/* Enable ADC1 reset calibaration register */   
;;;91     	ADC_ResetCalibration(ADC1);
000102  480c              LDR      r0,|L1.308|
000104  f7fffffe          BL       ADC_ResetCalibration
;;;92     	/* Check the end of ADC1 reset calibration register */
;;;93     	while(ADC_GetResetCalibrationStatus(ADC1));
000108  bf00              NOP      
                  |L1.266|
00010a  480a              LDR      r0,|L1.308|
00010c  f7fffffe          BL       ADC_GetResetCalibrationStatus
000110  2800              CMP      r0,#0
000112  d1fa              BNE      |L1.266|
;;;94     	/* Start ADC1 calibaration */
;;;95     	ADC_StartCalibration(ADC1);
000114  4807              LDR      r0,|L1.308|
000116  f7fffffe          BL       ADC_StartCalibration
;;;96     
;;;97     	/* Check the end of ADC1 calibration */
;;;98     	while(ADC_GetCalibrationStatus(ADC1));
00011a  bf00              NOP      
                  |L1.284|
00011c  4805              LDR      r0,|L1.308|
00011e  f7fffffe          BL       ADC_GetCalibrationStatus
000122  2800              CMP      r0,#0
000124  d1fa              BNE      |L1.284|
;;;99     	/************************************************************************************************/
;;;100    
;;;101    	/* Start ADC1 Software Conversion */ 
;;;102    	ADC_SoftwareStartConvCmd(ADC1, ENABLE);
000126  2101              MOVS     r1,#1
000128  4802              LDR      r0,|L1.308|
00012a  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;103    }
00012e  b005              ADD      sp,sp,#0x14
000130  bd00              POP      {pc}
;;;104    
                          ENDP

000132  0000              DCW      0x0000
                  |L1.308|
                          DCD      0x40012400

                          AREA ||i.DMA_Configuration||, CODE, READONLY, ALIGN=2

                  DMA_Configuration PROC
;;;15     
;;;16     void DMA_Configuration()
000000  b500              PUSH     {lr}
;;;17     {
000002  b08b              SUB      sp,sp,#0x2c
;;;18     	DMA_InitTypeDef DMA_InitStructure;
;;;19     	/* DMA channel1 configuration ----------------------------------------------*/
;;;20     	DMA_DeInit(DMA1_Channel1);
000004  4828              LDR      r0,|L2.168|
000006  f7fffffe          BL       DMA_DeInit
;;;21     	DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address;
00000a  4828              LDR      r0,|L2.172|
00000c  9000              STR      r0,[sp,#0]
;;;22     	DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&ADC_ConvertedValue;
00000e  4828              LDR      r0,|L2.176|
000010  9001              STR      r0,[sp,#4]
;;;23     	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
000012  f04f0000          MOV      r0,#0
000016  9002              STR      r0,[sp,#8]
;;;24     	DMA_InitStructure.DMA_BufferSize = 160;
000018  f04f00a0          MOV      r0,#0xa0
00001c  9003              STR      r0,[sp,#0xc]
;;;25     	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
00001e  f04f0000          MOV      r0,#0
000022  9004              STR      r0,[sp,#0x10]
;;;26     	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;		//内存地址寄存器递增！
000024  f04f0080          MOV      r0,#0x80
000028  9005              STR      r0,[sp,#0x14]
;;;27     	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
00002a  f44f7080          MOV      r0,#0x100
00002e  9006              STR      r0,[sp,#0x18]
;;;28     	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
000030  f44f6080          MOV      r0,#0x400
000034  9007              STR      r0,[sp,#0x1c]
;;;29     	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
000036  f04f0020          MOV      r0,#0x20
00003a  9008              STR      r0,[sp,#0x20]
;;;30     	DMA_InitStructure.DMA_Priority = DMA_Priority_High;
00003c  f44f5000          MOV      r0,#0x2000
000040  9009              STR      r0,[sp,#0x24]
;;;31     	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
000042  f04f0000          MOV      r0,#0
000046  900a              STR      r0,[sp,#0x28]
;;;32     	DMA_Init(DMA1_Channel1, &DMA_InitStructure);
000048  4669              MOV      r1,sp
00004a  4817              LDR      r0,|L2.168|
00004c  f7fffffe          BL       DMA_Init
;;;33     	//Enable DMA channel1
;;;34     	DMA_Cmd(DMA1_Channel1, ENABLE);
000050  2101              MOVS     r1,#1
000052  4815              LDR      r0,|L2.168|
000054  f7fffffe          BL       DMA_Cmd
;;;35     
;;;36     	
;;;37     	DMA_DeInit(DMA1_Channel4);
000058  4813              LDR      r0,|L2.168|
00005a  303c              ADDS     r0,r0,#0x3c
00005c  f7fffffe          BL       DMA_DeInit
;;;38     	DMA_InitStructure.DMA_PeripheralBaseAddr = SPI2_DR_Base;//(u32)&SPI2->DR;			 //该参数用以定义 DMA外设基地址 
000060  4814              LDR      r0,|L2.180|
000062  9000              STR      r0,[sp,#0]
;;;39     	DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&ADC_ConvertedValue2_raw;				 //该参数用以定义 DMA内存基地址
000064  4814              LDR      r0,|L2.184|
000066  9001              STR      r0,[sp,#4]
;;;40     	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;								 //	DMA_DIR_PeripheralDST  外设作为数据传输的目的地																					 //DMA_DIR_PeripheralSRC  外设作为数据传输的来源  
000068  f04f0000          MOV      r0,#0
00006c  9002              STR      r0,[sp,#8]
;;;41     	DMA_InitStructure.DMA_BufferSize = 32;									 //DMA_BufferSize 用以定义指定 DMA通道的 DMA缓存的大小，单位为数据单位。根据传输方向，数据单																					 //位等于结构中参数 DMA_PeripheralDataSize 或者参数 DMA_MemoryDataSize 的值。
00006e  f04f0020          MOV      r0,#0x20
000072  9003              STR      r0,[sp,#0xc]
;;;42     	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;					 //DMA_PeripheralInc_Enable  外设地址寄存器递增 																				 //DMA_PeripheralInc_Disable  外设地址寄存器不变 
000074  f04f0000          MOV      r0,#0
000078  9004              STR      r0,[sp,#0x10]
;;;43     	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
00007a  f04f0080          MOV      r0,#0x80
00007e  9005              STR      r0,[sp,#0x14]
;;;44     	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;			 //DMA_PeripheralDataSize设定了外设数据宽度DMA_PeripheralDataSize_Byte  数据宽度为 8 位 ,DMA_PeripheralDataSize_HalfWord  数据宽度为 16 位, DMA_PeripheralDataSize_Word  数据宽度为 32 位 
000080  f04f0000          MOV      r0,#0
000084  9006              STR      r0,[sp,#0x18]
;;;45     	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;					 //DMA_MemoryDataSize 设定了外设数据宽度。
000086  9007              STR      r0,[sp,#0x1c]
;;;46     	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;										 //DMA_Mode设置了 CAN的工作模式,DMA_Mode_Circular  工作在循环缓存模式 ,DMA_Mode_Normal  工作在正常缓存模式 
000088  f04f0020          MOV      r0,#0x20
00008c  9008              STR      r0,[sp,#0x20]
;;;47     	DMA_InitStructure.DMA_Priority = DMA_Priority_High;							 //DMA_Priority设定 DMA通道SPI_SLAVE_Rx_DMA_Channel的软件优先级
00008e  f44f5000          MOV      r0,#0x2000
000092  9009              STR      r0,[sp,#0x24]
;;;48     	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;										 //DMA_M2M使能 DMA通道的内存到内存传输。
000094  f04f0000          MOV      r0,#0
000098  900a              STR      r0,[sp,#0x28]
;;;49     	DMA_Init(DMA1_Channel4, &DMA_InitStructure);
00009a  4669              MOV      r1,sp
00009c  4807              LDR      r0,|L2.188|
00009e  f7fffffe          BL       DMA_Init
;;;50     	
;;;51     }
0000a2  b00b              ADD      sp,sp,#0x2c
0000a4  bd00              POP      {pc}
;;;52     
                          ENDP

0000a6  0000              DCW      0x0000
                  |L2.168|
                          DCD      0x40020008
                  |L2.172|
                          DCD      0x4001244c
                  |L2.176|
                          DCD      ADC_ConvertedValue
                  |L2.180|
                          DCD      0x4000380c
                  |L2.184|
                          DCD      ADC_ConvertedValue2_raw
                  |L2.188|
                          DCD      0x40020044

                          AREA ||i.GPIO_Configuration||, CODE, READONLY, ALIGN=2

                  GPIO_Configuration PROC
;;;197    *******************************************************************************/
;;;198    void GPIO_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;199    {
;;;200    	GPIO_InitTypeDef GPIO_InitStructure;
;;;201    
;;;202     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000002  f04f0003          MOV      r0,#3
000006  f88d0002          STRB     r0,[sp,#2]
;;;203    
;;;204    
;;;205    	/*SPI2 GPIO configuration*/
;;;206      	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12|GPIO_Pin_14;		
00000a  f44f40a0          MOV      r0,#0x5000
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;207      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	
000012  f04f0018          MOV      r0,#0x18
000016  f88d0003          STRB     r0,[sp,#3]
;;;208      	GPIO_Init(GPIOB , &GPIO_InitStructure);
00001a  4669              MOV      r1,sp
00001c  4813              LDR      r0,|L3.108|
00001e  f7fffffe          BL       GPIO_Init
;;;209    	
;;;210    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13|GPIO_Pin_15;
000022  f44f4020          MOV      r0,#0xa000
000026  f8ad0000          STRH     r0,[sp,#0]
;;;211        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00002a  f04f0004          MOV      r0,#4
00002e  f88d0003          STRB     r0,[sp,#3]
;;;212        GPIO_Init(GPIOB, &GPIO_InitStructure);
000032  4669              MOV      r1,sp
000034  480d              LDR      r0,|L3.108|
000036  f7fffffe          BL       GPIO_Init
;;;213    
;;;214    	
;;;215    	/*Button IO configuration --- commented because of CAN test*/
;;;216    	/*
;;;217    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11|GPIO_Pin_12;
;;;218        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
;;;219        GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;220    	*/
;;;221    
;;;222        /* uart1 tx */ 
;;;223      	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
00003a  f44f7000          MOV      r0,#0x200
00003e  f8ad0000          STRH     r0,[sp,#0]
;;;224      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;			
000042  f04f0018          MOV      r0,#0x18
000046  f88d0003          STRB     r0,[sp,#3]
;;;225      	GPIO_Init(GPIOA , &GPIO_InitStructure); 
00004a  4669              MOV      r1,sp
00004c  4808              LDR      r0,|L3.112|
00004e  f7fffffe          BL       GPIO_Init
;;;226    	
;;;227    	/* uart1 rx */
;;;228      	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000052  f44f6080          MOV      r0,#0x400
000056  f8ad0000          STRH     r0,[sp,#0]
;;;229      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;			
00005a  f04f0004          MOV      r0,#4
00005e  f88d0003          STRB     r0,[sp,#3]
;;;230      	GPIO_Init(GPIOA , &GPIO_InitStructure); 
000062  4669              MOV      r1,sp
000064  4802              LDR      r0,|L3.112|
000066  f7fffffe          BL       GPIO_Init
;;;231    }
00006a  bd08              POP      {r3,pc}
;;;232    
                          ENDP

                  |L3.108|
                          DCD      0x40010c00
                  |L3.112|
                          DCD      0x40010800

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;239    *******************************************************************************/
;;;240    void NVIC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;241    {
;;;242    	NVIC_InitTypeDef NVIC_InitStructure;
;;;243    	NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0); 
000002  2100              MOVS     r1,#0
000004  f04f6000          MOV      r0,#0x8000000
000008  f7fffffe          BL       NVIC_SetVectorTable
;;;244    	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
00000c  f44f60e0          MOV      r0,#0x700
000010  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;245    	//NVIC_PriorityGroupConfig(NVIC_PriorityGroup_3);
;;;246    	/*
;;;247    	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
;;;248    	
;;;249    	NVIC_InitStructure.NVIC_IRQChannel = SPI2_IRQn;
;;;250    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
;;;251    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
;;;252    	NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;
;;;253    	NVIC_Init(&NVIC_InitStructure);
;;;254    	*/
;;;255    
;;;256    	/*
;;;257    	NVIC_InitStructure.NVIC_IRQChannel=DMA1_Channel4_IRQn;
;;;258    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=0;
;;;259    	NVIC_InitStructure.NVIC_IRQChannelSubPriority=1;
;;;260    	NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;
;;;261    	NVIC_Init(&NVIC_InitStructure);
;;;262    	*/
;;;263    }
000014  bd10              POP      {r4,pc}
;;;264    
                          ENDP


                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=2

                  RCC_Configuration PROC
;;;137    *******************************************************************************/
;;;138    void RCC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;139    {
;;;140    	/* RCC system reset(for debug purpose) */
;;;141    	RCC_DeInit();
000002  f7fffffe          BL       RCC_DeInit
;;;142    	/* Enable HSE */
;;;143    	RCC_HSEConfig(RCC_HSE_ON);
000006  f44f3080          MOV      r0,#0x10000
00000a  f7fffffe          BL       RCC_HSEConfig
;;;144    	/* Wait till HSE is ready */
;;;145    	HSEStartUpStatus = RCC_WaitForHSEStartUp();
00000e  f7fffffe          BL       RCC_WaitForHSEStartUp
000012  4925              LDR      r1,|L5.168|
000014  7008              STRB     r0,[r1,#0]
;;;146    	if(HSEStartUpStatus == SUCCESS)
000016  4608              MOV      r0,r1
000018  7800              LDRB     r0,[r0,#0]  ; HSEStartUpStatus
00001a  2801              CMP      r0,#1
00001c  d12a              BNE      |L5.116|
;;;147    	{
;;;148    		/* HCLK = SYSCLK */
;;;149    		RCC_HCLKConfig(RCC_SYSCLK_Div1); 		//设置AHB时钟
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       RCC_HCLKConfig
;;;150    		/* PCLK2 = HCLK */				  		
;;;151    		RCC_PCLK2Config(RCC_HCLK_Div1); 		//设置高速AHB时钟
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       RCC_PCLK2Config
;;;152    		/* PCLK1 = HCLK/2 */
;;;153    		RCC_PCLK1Config(RCC_HCLK_Div2);		  	//设置低速AHB时钟
00002a  f44f6080          MOV      r0,#0x400
00002e  f7fffffe          BL       RCC_PCLK1Config
;;;154    		/* ADCCLK = PCLK2/4 */
;;;155    		RCC_ADCCLKConfig(RCC_PCLK2_Div4); 	  	
000032  f44f4080          MOV      r0,#0x4000
000036  f7fffffe          BL       RCC_ADCCLKConfig
;;;156    		/* Flash 2 wait state */
;;;157    		FLASH_SetLatency(FLASH_Latency_2);
00003a  2002              MOVS     r0,#2
00003c  f7fffffe          BL       FLASH_SetLatency
;;;158    		/* Enable Prefetch Buffer */
;;;159    		FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
000040  2010              MOVS     r0,#0x10
000042  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;160    		/* PLLCLK = 8MHz * 9 = 72 MHz */
;;;161    		RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);	//设置PLL
000046  f44f11e0          MOV      r1,#0x1c0000
00004a  f44f3080          MOV      r0,#0x10000
00004e  f7fffffe          BL       RCC_PLLConfig
;;;162    		/* Enable PLL */ 
;;;163    		RCC_PLLCmd(ENABLE);							  			//打开PLL
000052  2001              MOVS     r0,#1
000054  f7fffffe          BL       RCC_PLLCmd
;;;164    		/* Wait till PLL is ready */
;;;165    		while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);
000058  bf00              NOP      
                  |L5.90|
00005a  2039              MOVS     r0,#0x39
00005c  f7fffffe          BL       RCC_GetFlagStatus
000060  2800              CMP      r0,#0
000062  d0fa              BEQ      |L5.90|
;;;166    		/* Select PLL as system clock source */
;;;167    		RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);	  			//设置系统时钟
000064  2002              MOVS     r0,#2
000066  f7fffffe          BL       RCC_SYSCLKConfig
;;;168    		/* Wait till PLL is used as system clock source */
;;;169    		while(RCC_GetSYSCLKSource() != 0x08);
00006a  bf00              NOP      
                  |L5.108|
00006c  f7fffffe          BL       RCC_GetSYSCLKSource
000070  2808              CMP      r0,#8
000072  d1fb              BNE      |L5.108|
                  |L5.116|
;;;170    	}
;;;171    
;;;172    	/* Enable peripheral clocks --------------------------------------------------*/	 //打开要使用的外设时钟
;;;173    	/* Enable DMA clock */
;;;174    	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
000074  2101              MOVS     r1,#1
000076  4608              MOV      r0,r1
000078  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;175    	/* Enable ADC1 and GPIOC clock */
;;;176    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_GPIOC, ENABLE);
00007c  2101              MOVS     r1,#1
00007e  f44f7004          MOV      r0,#0x210
000082  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;177    	/* Enable USART1 and GPIOA clock */
;;;178    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB, ENABLE);
000086  2101              MOVS     r1,#1
000088  f244000c          MOV      r0,#0x400c
00008c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;179    	/* Enable SPI2 as slave */
;;;180    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
000090  2101              MOVS     r1,#1
000092  0388              LSLS     r0,r1,#14
000094  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;181    	//RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
;;;182    
;;;183    	/* This line of code is quite important when doing spi1 remapping */
;;;184    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
000098  2101              MOVS     r1,#1
00009a  4608              MOV      r0,r1
00009c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;185    
;;;186    	/* Enable Internal High Speed oscillator */ 	
;;;187    	RCC_HSICmd(ENABLE);	   //used in flash access
0000a0  2001              MOVS     r0,#1
0000a2  f7fffffe          BL       RCC_HSICmd
;;;188    
;;;189    }
0000a6  bd10              POP      {r4,pc}
;;;190    
                          ENDP

                  |L5.168|
                          DCD      HSEStartUpStatus

                          AREA ||i.SPI_Configuration||, CODE, READONLY, ALIGN=2

                  SPI_Configuration PROC
;;;104    
;;;105    void SPI_Configuration(void)
000000  b500              PUSH     {lr}
;;;106    {
000002  b085              SUB      sp,sp,#0x14
;;;107        SPI_InitTypeDef SPI_InitStructure;
;;;108    
;;;109    	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
000004  f04f0000          MOV      r0,#0
000008  f8ad0000          STRH     r0,[sp,#0]
;;;110    	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
00000c  f8ad0004          STRH     r0,[sp,#4]
;;;111    	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
000010  f8ad0006          STRH     r0,[sp,#6]
;;;112    	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;
000014  f04f0001          MOV      r0,#1
000018  f8ad0008          STRH     r0,[sp,#8]
;;;113    	SPI_InitStructure.SPI_NSS = SPI_NSS_Hard;
00001c  f04f0000          MOV      r0,#0
000020  f8ad000a          STRH     r0,[sp,#0xa]
;;;114    	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
000024  f04f0010          MOV      r0,#0x10
000028  f8ad000c          STRH     r0,[sp,#0xc]
;;;115    	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
00002c  f04f0000          MOV      r0,#0
000030  f8ad000e          STRH     r0,[sp,#0xe]
;;;116    	SPI_InitStructure.SPI_CRCPolynomial = 7;
000034  f04f0007          MOV      r0,#7
000038  f8ad0010          STRH     r0,[sp,#0x10]
;;;117    	
;;;118    	SPI_InitStructure.SPI_Mode = SPI_Mode_Slave;
00003c  f04f0000          MOV      r0,#0
000040  f8ad0002          STRH     r0,[sp,#2]
;;;119    	SPI_Init(SPI2,&SPI_InitStructure);
000044  4669              MOV      r1,sp
000046  480b              LDR      r0,|L6.116|
000048  f7fffffe          BL       SPI_Init
;;;120    	
;;;121    	DMA_Cmd(DMA1_Channel4, ENABLE);	//Enable DMA
00004c  2101              MOVS     r1,#1
00004e  480a              LDR      r0,|L6.120|
000050  f7fffffe          BL       DMA_Cmd
;;;122    	/* Enable SPI_SLAVE Rx request */
;;;123      	SPI_I2S_DMACmd(SPI2, SPI_I2S_DMAReq_Rx, ENABLE);	//SPI DMA request
000054  2201              MOVS     r2,#1
000056  4611              MOV      r1,r2
000058  4806              LDR      r0,|L6.116|
00005a  f7fffffe          BL       SPI_I2S_DMACmd
;;;124    	
;;;125    	SPI_Cmd(SPI2,ENABLE);	//Enable SPI
00005e  2101              MOVS     r1,#1
000060  4804              LDR      r0,|L6.116|
000062  f7fffffe          BL       SPI_Cmd
;;;126    
;;;127    	DMA_ITConfig(DMA1_Channel4, DMA_IT_TC, ENABLE);	//DMA Interrupt config	
000066  2201              MOVS     r2,#1
000068  2102              MOVS     r1,#2
00006a  4803              LDR      r0,|L6.120|
00006c  f7fffffe          BL       DMA_ITConfig
;;;128    }
000070  b005              ADD      sp,sp,#0x14
000072  bd00              POP      {pc}
;;;129    
                          ENDP

                  |L6.116|
                          DCD      0x40003800
                  |L6.120|
                          DCD      0x40020044

                          AREA ||i.USART1_Configuration||, CODE, READONLY, ALIGN=2

                  USART1_Configuration PROC
;;;293    *******************************************************************************/
;;;294    void USART1_Configuration(void)
000000  b500              PUSH     {lr}
;;;295    {
000002  b087              SUB      sp,sp,#0x1c
;;;296    	USART_InitTypeDef USART_InitStructure;
;;;297    	USART_ClockInitTypeDef  USART_ClockInitStructure;
;;;298    	/* USART1 configuration ------------------------------------------------------*/
;;;299    	/* USART1 configured as follow:
;;;300    		- BaudRate = 9600 baud  
;;;301    		- Word Length = 8 Bits
;;;302    		- One Stop Bit
;;;303    		- No parity
;;;304    		- Hardware flow control disabled (RTS and CTS signals)
;;;305    		- Receive and transmit enabled
;;;306    		- USART Clock disabled
;;;307    		- USART CPOL: Clock is active low
;;;308    		- USART CPHA: Data is captured on the middle 
;;;309    		- USART LastBit: The clock pulse of the last data bit is not output to 
;;;310    						 the SCLK pin
;;;311    	*/
;;;312    	USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;
000004  f04f0000          MOV      r0,#0
000008  f8ad0004          STRH     r0,[sp,#4]
;;;313    	USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;
00000c  f8ad0006          STRH     r0,[sp,#6]
;;;314    	USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;
000010  f44f7000          MOV      r0,#0x200
000014  f8ad0008          STRH     r0,[sp,#8]
;;;315    	USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;
000018  f04f0000          MOV      r0,#0
00001c  f8ad000a          STRH     r0,[sp,#0xa]
;;;316    	
;;;317    	/* Configure the USART1 synchronous paramters */
;;;318    	USART_ClockInit(USART1, &USART_ClockInitStructure);
000020  a901              ADD      r1,sp,#4
000022  480f              LDR      r0,|L7.96|
000024  f7fffffe          BL       USART_ClockInit
;;;319    	USART_InitStructure.USART_BaudRate = 9600;
000028  f44f5016          MOV      r0,#0x2580
00002c  9003              STR      r0,[sp,#0xc]
;;;320    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00002e  f04f0000          MOV      r0,#0
000032  f8ad0010          STRH     r0,[sp,#0x10]
;;;321    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000036  f8ad0012          STRH     r0,[sp,#0x12]
;;;322    	USART_InitStructure.USART_Parity = USART_Parity_No ;
00003a  f8ad0014          STRH     r0,[sp,#0x14]
;;;323    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00003e  f8ad0018          STRH     r0,[sp,#0x18]
;;;324    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000042  f04f000c          MOV      r0,#0xc
000046  f8ad0016          STRH     r0,[sp,#0x16]
;;;325    	
;;;326    	/* Configure USART1 basic and asynchronous paramters */
;;;327    	USART_Init(USART1, &USART_InitStructure);
00004a  a903              ADD      r1,sp,#0xc
00004c  4804              LDR      r0,|L7.96|
00004e  f7fffffe          BL       USART_Init
;;;328    	/* Enable USART1 */
;;;329    	USART_Cmd(USART1, ENABLE);
000052  2101              MOVS     r1,#1
000054  4802              LDR      r0,|L7.96|
000056  f7fffffe          BL       USART_Cmd
;;;330    }
00005a  b007              ADD      sp,sp,#0x1c
00005c  bd00              POP      {pc}
;;;331    
                          ENDP

00005e  0000              DCW      0x0000
                  |L7.96|
                          DCD      0x40013800

                          AREA ||i.USART_OUT||, CODE, READONLY, ALIGN=1

                  USART_OUT PROC
;;;344    
;;;345    void USART_OUT(USART_TypeDef* USARTx, uc8 *Data,uint16_t Len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;346    { 
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;347    	uint16_t i;
;;;348    	for(i=0; i<Len; i++)
00000a  f04f0400          MOV      r4,#0
00000e  e010              B        |L8.50|
                  |L8.16|
;;;349    	{
;;;350    		USART_SendData(USARTx, Data[i]);
000010  5d29              LDRB     r1,[r5,r4]
000012  4638              MOV      r0,r7
000014  f7fffffe          BL       USART_SendData
;;;351    		while(USART_GetFlagStatus(USARTx, USART_FLAG_TC)==RESET);
000018  bf00              NOP      
                  |L8.26|
00001a  2140              MOVS     r1,#0x40
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       USART_GetFlagStatus
000022  2800              CMP      r0,#0
000024  d0f9              BEQ      |L8.26|
;;;352    		//for(tick=0;tick<5000;tick++);
;;;353    		_delay_ms(2);
000026  2002              MOVS     r0,#2
000028  f7fffffe          BL       _delay_ms
00002c  f1040001          ADD      r0,r4,#1              ;348
000030  b284              UXTH     r4,r0                 ;348
                  |L8.50|
000032  42b4              CMP      r4,r6                 ;348
000034  dbec              BLT      |L8.16|
;;;354    	}
;;;355    }
000036  e8bd81f0          POP      {r4-r8,pc}
;;;356    
                          ENDP


                          AREA ||i.USART_OUT16||, CODE, READONLY, ALIGN=2

                  USART_OUT16 PROC
;;;332    
;;;333    void USART_OUT16(USART_TypeDef* USARTx, uc16 *Data,uint16_t Len)
000000  b5f8              PUSH     {r3-r7,lr}
;;;334    {
000002  4607              MOV      r7,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;335    	uint8_t temp[2];
;;;336    	uint16_t i;
;;;337    	for(i=0; i<Len; i++)
000008  f04f0400          MOV      r4,#0
00000c  e013              B        |L9.54|
                  |L9.14|
;;;338    	{
;;;339    		temp[0] = (uint8_t)(Data[i] >> 8);
00000e  f8350014          LDRH     r0,[r5,r4,LSL #1]
000012  ea4f2020          ASR      r0,r0,#8
000016  f88d0000          STRB     r0,[sp,#0]
;;;340    		temp[1] = (uint8_t)(Data[i] & 0xff);
00001a  f8350014          LDRH     r0,[r5,r4,LSL #1]
00001e  b2c0              UXTB     r0,r0
000020  f88d0001          STRB     r0,[sp,#1]
;;;341    		USART_OUT(USART1, &temp[0],2);
000024  f04f0202          MOV      r2,#2
000028  4669              MOV      r1,sp
00002a  4804              LDR      r0,|L9.60|
00002c  f7fffffe          BL       USART_OUT
000030  f1040001          ADD      r0,r4,#1              ;337
000034  b284              UXTH     r4,r0                 ;337
                  |L9.54|
000036  42b4              CMP      r4,r6                 ;337
000038  dbe9              BLT      |L9.14|
;;;342    	}
;;;343    }
00003a  bdf8              POP      {r3-r7,pc}
;;;344    
                          ENDP

                  |L9.60|
                          DCD      0x40013800

                          AREA ||i.USART_TX_BYTE||, CODE, READONLY, ALIGN=1

                  USART_TX_BYTE PROC
;;;356    
;;;357    void USART_TX_BYTE(USART_TypeDef* USARTx, uc8 Data)
000000  b570              PUSH     {r4-r6,lr}
;;;358    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;359     	USART_SendData(USARTx, Data);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       USART_SendData
;;;360    	while(USART_GetFlagStatus(USARTx, USART_FLAG_TC)==RESET);
00000e  bf00              NOP      
                  |L10.16|
000010  2140              MOVS     r1,#0x40
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       USART_GetFlagStatus
000018  2800              CMP      r0,#0
00001a  d0f9              BEQ      |L10.16|
;;;361    }
00001c  bd70              POP      {r4-r6,pc}
;;;362    
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;372    
;;;373    int fputc(int ch, FILE *f)
000000  b570              PUSH     {r4-r6,lr}
;;;374    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;375    	USART_SendData(USART1, (unsigned char) ch);
000006  b2e1              UXTB     r1,r4
000008  4805              LDR      r0,|L11.32|
00000a  f7fffffe          BL       USART_SendData
;;;376    	while (!(USART1->SR & USART_FLAG_TXE));
00000e  bf00              NOP      
                  |L11.16|
000010  4803              LDR      r0,|L11.32|
000012  8800              LDRH     r0,[r0,#0]
000014  f0100f80          TST      r0,#0x80
000018  d0fa              BEQ      |L11.16|
;;;377    	return (ch);
00001a  4620              MOV      r0,r4
;;;378    }
00001c  bd70              POP      {r4-r6,pc}
;;;379    
                          ENDP

00001e  0000              DCW      0x0000
                  |L11.32|
                          DCD      0x40013800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  ADC_ConvertedValue
                          %        320
                  ADC_ConvertedValue2
                          %        32
                  ADC_ConvertedValue2_raw
                          %        32

                          AREA ||.data||, DATA, ALIGN=0

                  calibration_flag_high
000000  00                DCB      0x00
                  calibration_flag_low
000001  00                DCB      0x00
                  prev_calibration_flag
000002  00                DCB      0x00
                  HSEStartUpStatus
000003  00                DCB      0x00
