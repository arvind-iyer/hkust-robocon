; generated by ARM C/C++ Compiler, 4.1 [Build 713]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\delay.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\delay.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -IE:\UST\Robocon2012\KEIL\ARM\CMSIS\Include -IE:\UST\Robocon2012\KEIL\ARM\INC\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\obj\delay.crf user\delay.c]
                          THUMB

                          AREA ||i._delay_ms||, CODE, READONLY, ALIGN=2

                  _delay_ms PROC
;;;41     }
;;;42     void _delay_ms( u16 nms )
000000  b570              PUSH     {r4-r6,lr}
;;;43     {
000002  4604              MOV      r4,r0
;;;44     	u32 temp;
;;;45     	u16 ms ; 
;;;46     	if( using_delay == 0 ){
000004  481f              LDR      r0,|L1.132|
000006  7800              LDRB     r0,[r0,#0]  ; using_delay
000008  bb90              CBNZ     r0,|L1.112|
;;;47     		using_delay = 1;
00000a  f04f0001          MOV      r0,#1
00000e  491d              LDR      r1,|L1.132|
000010  7008              STRB     r0,[r1,#0]
;;;48     		while( nms ){
000012  e027              B        |L1.100|
                  |L1.20|
;;;49     		
;;;50     		ms = ( nms > 1000 ) ? 1000 : nms;
000014  f5b47f7a          CMP      r4,#0x3e8
000018  dd02              BLE      |L1.32|
00001a  f44f707a          MOV      r0,#0x3e8
00001e  e000              B        |L1.34|
                  |L1.32|
000020  4620              MOV      r0,r4
                  |L1.34|
000022  b286              UXTH     r6,r0
;;;51     		
;;;52     		SysTick->LOAD = 9000*ms;
000024  f2423028          MOV      r0,#0x2328
000028  fb06f000          MUL      r0,r6,r0
00002c  f04f21e0          MOV      r1,#0xe000e000
000030  6148              STR      r0,[r1,#0x14]
;;;53     		SysTick->VAL = 0x00;
000032  f04f0000          MOV      r0,#0
000036  6188              STR      r0,[r1,#0x18]
;;;54     		SysTick->CTRL = 0x01;
000038  f04f0001          MOV      r0,#1
00003c  6108              STR      r0,[r1,#0x10]
;;;55     		do
00003e  bf00              NOP      
                  |L1.64|
;;;56     		{
;;;57     			temp = SysTick->CTRL;
000040  f04f20e0          MOV      r0,#0xe000e000
000044  6905              LDR      r5,[r0,#0x10]
;;;58     		}while((temp&0x01)&&(!(temp&(1<<16))));
000046  f0150f01          TST      r5,#1
00004a  d002              BEQ      |L1.82|
00004c  f4153f80          TST      r5,#0x10000
000050  d0f6              BEQ      |L1.64|
                  |L1.82|
;;;59     		SysTick->CTRL=0x00;
000052  f04f0000          MOV      r0,#0
000056  f04f21e0          MOV      r1,#0xe000e000
00005a  6108              STR      r0,[r1,#0x10]
;;;60     		SysTick->VAL=0x00;
00005c  6188              STR      r0,[r1,#0x18]
;;;61     		
;;;62     		nms -= ms;
00005e  eba40006          SUB      r0,r4,r6
000062  b284              UXTH     r4,r0
                  |L1.100|
000064  2c00              CMP      r4,#0                 ;48
000066  d1d5              BNE      |L1.20|
;;;63     		}
;;;64     		using_delay = 0;
000068  4620              MOV      r0,r4
00006a  4906              LDR      r1,|L1.132|
00006c  7008              STRB     r0,[r1,#0]
00006e  e008              B        |L1.130|
                  |L1.112|
000070  e7ff              B        |L1.114|
                  |L1.114|
;;;65     	}
;;;66     	else{
;;;67     		while( nms -- ){
000072  e001              B        |L1.120|
                  |L1.116|
;;;68     			simple_delay1_ms();
000074  f7fffffe          BL       simple_delay1_ms
                  |L1.120|
000078  0020              MOVS     r0,r4                 ;67
00007a  f1a40101          SUB      r1,r4,#1              ;67
00007e  b28c              UXTH     r4,r1                 ;67
000080  d1f8              BNE      |L1.116|
                  |L1.130|
;;;69     		}
;;;70     			
;;;71     	}
;;;72     }
000082  bd70              POP      {r4-r6,pc}
;;;73     
                          ENDP

                  |L1.132|
                          DCD      using_delay

                          AREA ||i._delay_us||, CODE, READONLY, ALIGN=2

                  _delay_us PROC
;;;16     
;;;17     void _delay_us( u32 nus)
000000  b570              PUSH     {r4-r6,lr}
;;;18     {
000002  4604              MOV      r4,r0
;;;19     	
;;;20     	u32 temp;
;;;21     	if( using_delay == 0 ){
000004  4818              LDR      r0,|L2.104|
000006  7800              LDRB     r0,[r0,#0]  ; using_delay
000008  bb08              CBNZ     r0,|L2.78|
;;;22     		using_delay = 1;
00000a  f04f0001          MOV      r0,#1
00000e  4916              LDR      r1,|L2.104|
000010  7008              STRB     r0,[r1,#0]
;;;23     		SysTick->LOAD = 9*nus;
000012  eb0400c4          ADD      r0,r4,r4,LSL #3
000016  f04f21e0          MOV      r1,#0xe000e000
00001a  6148              STR      r0,[r1,#0x14]
;;;24     		SysTick->VAL = 0x00;
00001c  f04f0000          MOV      r0,#0
000020  6188              STR      r0,[r1,#0x18]
;;;25     		SysTick->CTRL = 0x01;
000022  f04f0001          MOV      r0,#1
000026  6108              STR      r0,[r1,#0x10]
;;;26     		do
000028  bf00              NOP      
                  |L2.42|
;;;27     		{
;;;28     			temp=SysTick->CTRL;
00002a  f04f20e0          MOV      r0,#0xe000e000
00002e  6905              LDR      r5,[r0,#0x10]
;;;29     		}while((temp&0x01)&&(!(temp&(1<<16))));
000030  f0150f01          TST      r5,#1
000034  d002              BEQ      |L2.60|
000036  f4153f80          TST      r5,#0x10000
00003a  d0f6              BEQ      |L2.42|
                  |L2.60|
;;;30     		SysTick->CTRL = 0x00;
00003c  f04f0000          MOV      r0,#0
000040  f04f21e0          MOV      r1,#0xe000e000
000044  6108              STR      r0,[r1,#0x10]
;;;31     		SysTick->VAL = 0x00;
000046  6188              STR      r0,[r1,#0x18]
;;;32     		using_delay = 0;
000048  4907              LDR      r1,|L2.104|
00004a  7008              STRB     r0,[r1,#0]
00004c  e00a              B        |L2.100|
                  |L2.78|
;;;33     	}
;;;34     	else{
;;;35     		nus = nus / 10;
00004e  f04f000a          MOV      r0,#0xa
000052  fbb4f4f0          UDIV     r4,r4,r0
;;;36     		while( nus -- ){
000056  e001              B        |L2.92|
                  |L2.88|
;;;37     			simple_delay10_us();
000058  f7fffffe          BL       simple_delay10_us
                  |L2.92|
00005c  0020              MOVS     r0,r4                 ;36
00005e  f1a40401          SUB      r4,r4,#1              ;36
000062  d1f9              BNE      |L2.88|
                  |L2.100|
;;;38     		}
;;;39     	}
;;;40     	
;;;41     }
000064  bd70              POP      {r4-r6,pc}
;;;42     void _delay_ms( u16 nms )
                          ENDP

000066  0000              DCW      0x0000
                  |L2.104|
                          DCD      using_delay

                          AREA ||i.simple_delay1_ms||, CODE, READONLY, ALIGN=1

                  simple_delay1_ms PROC
;;;83     
;;;84     void simple_delay1_ms(){
000000  b510              PUSH     {r4,lr}
;;;85     	u8 i = 0 ; 
000002  f04f0400          MOV      r4,#0
;;;86     	for( i = 0 ; i < 100 ; i ++ )
000006  bf00              NOP      
000008  e004              B        |L3.20|
                  |L3.10|
;;;87     		simple_delay10_us();
00000a  f7fffffe          BL       simple_delay10_us
00000e  f1040001          ADD      r0,r4,#1              ;86
000012  b2c4              UXTB     r4,r0                 ;86
                  |L3.20|
000014  2c64              CMP      r4,#0x64              ;86
000016  dbf8              BLT      |L3.10|
;;;88     }
000018  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  using_delay
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  TimingDelay
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "user\\delay.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |simple_delay10_us|
#line 75
|simple_delay10_us| PROC
#line 75

 MOV R0, #115
loop
 SUB R0, R0, #1
 CMP R0, #0
 BNE loop
 BX LR
	ENDP

;*** End   embedded assembler ***
