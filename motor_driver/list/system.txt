; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\system.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\system.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I"C:\Users\Kenneth Au\Desktop\toKenneth\Complicated Big Motor Control\(encoder)24V Big Blue Black Motor Control June 7\RTE" -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=513 -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=.\obj\system.crf user\system.c]
                          THUMB

                          AREA ||i.ADC_Calibaration||, CODE, READONLY, ALIGN=2

                  ADC_Calibaration PROC
;;;303    
;;;304    void ADC_Calibaration(void)
000000  b510              PUSH     {r4,lr}
;;;305    {
;;;306        /* Enable ADC1 reset calibaration register */   
;;;307        ADC_ResetCalibration(ADC1);
000002  480b              LDR      r0,|L1.48|
000004  f7fffffe          BL       ADC_ResetCalibration
;;;308        /* Check the end of ADC1 reset calibration register */
;;;309        while(ADC_GetResetCalibrationStatus(ADC1));
000008  bf00              NOP      
                  |L1.10|
00000a  4809              LDR      r0,|L1.48|
00000c  f7fffffe          BL       ADC_GetResetCalibrationStatus
000010  2800              CMP      r0,#0
000012  d1fa              BNE      |L1.10|
;;;310    
;;;311        /* Start ADC1 calibaration */
;;;312        ADC_StartCalibration(ADC1);
000014  4806              LDR      r0,|L1.48|
000016  f7fffffe          BL       ADC_StartCalibration
;;;313    
;;;314        /* Check the end of ADC1 calibration */
;;;315        while(ADC_GetCalibrationStatus(ADC1));
00001a  bf00              NOP      
                  |L1.28|
00001c  4804              LDR      r0,|L1.48|
00001e  f7fffffe          BL       ADC_GetCalibrationStatus
000022  2800              CMP      r0,#0
000024  d1fa              BNE      |L1.28|
;;;316    
;;;317        ADC_SoftwareStartConvCmd(ADC1, ENABLE);
000026  2101              MOVS     r1,#1
000028  4801              LDR      r0,|L1.48|
00002a  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;318    }
00002e  bd10              POP      {r4,pc}
;;;319    
                          ENDP

                  |L1.48|
                          DCD      0x40012400

                          AREA ||i.Encoder_init1||, CODE, READONLY, ALIGN=2

                  Encoder_init1 PROC
;;;205    */
;;;206    void Encoder_init1(void)
000000  b500              PUSH     {lr}
;;;207    {
000002  b087              SUB      sp,sp,#0x1c
;;;208    	GPIO_InitTypeDef GPIO_InitStructure; 
;;;209    	TIM_TimeBaseInitTypeDef encoder_TIM_TimeBaseStructure;
;;;210    	TIM_ICInitTypeDef TIM_ICInitStructure;
;;;211    
;;;212    	
;;;213    	/* GPIOA Configuration: TIM5 ch1, input float*/
;;;214    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
000004  2001              MOVS     r0,#1
000006  f8ad0018          STRH     r0,[sp,#0x18]
;;;215    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00000a  2004              MOVS     r0,#4
00000c  f88d001b          STRB     r0,[sp,#0x1b]
;;;216    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000010  2003              MOVS     r0,#3
000012  f88d001a          STRB     r0,[sp,#0x1a]
;;;217    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000016  a906              ADD      r1,sp,#0x18
000018  4820              LDR      r0,|L2.156|
00001a  f7fffffe          BL       GPIO_Init
;;;218    	
;;;219    	/* GPIOB Configuration:TIM5 ch2, input float*/
;;;220    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
00001e  2002              MOVS     r0,#2
000020  f8ad0018          STRH     r0,[sp,#0x18]
;;;221    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000024  2004              MOVS     r0,#4
000026  f88d001b          STRB     r0,[sp,#0x1b]
;;;222    	GPIO_Init(GPIOA, &GPIO_InitStructure); 
00002a  a906              ADD      r1,sp,#0x18
00002c  481b              LDR      r0,|L2.156|
00002e  f7fffffe          BL       GPIO_Init
;;;223    
;;;224    
;;;225    	/* Timer configuration in Encoder mode */
;;;226    	encoder_TIM_TimeBaseStructure.TIM_Prescaler = 0x0; // No prescaling
000032  2000              MOVS     r0,#0
000034  f8ad000c          STRH     r0,[sp,#0xc]
;;;227    	encoder_TIM_TimeBaseStructure.TIM_Period = 65535;
000038  f64f70ff          MOV      r0,#0xffff
00003c  f8ad0010          STRH     r0,[sp,#0x10]
;;;228    	encoder_TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
000040  2000              MOVS     r0,#0
000042  f8ad0012          STRH     r0,[sp,#0x12]
;;;229    	encoder_TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  
000046  f8ad000e          STRH     r0,[sp,#0xe]
;;;230    	TIM_TimeBaseInit(TIM2, &encoder_TIM_TimeBaseStructure);
00004a  a903              ADD      r1,sp,#0xc
00004c  f04f4080          MOV      r0,#0x40000000
000050  f7fffffe          BL       TIM_TimeBaseInit
;;;231    	
;;;232    	TIM_EncoderInterfaceConfig(TIM2, TIM_EncoderMode_TI12,//TIM_EncoderMode_TI12->count on 4 edge per cycle
000054  2300              MOVS     r3,#0
000056  461a              MOV      r2,r3
000058  2103              MOVS     r1,#3
00005a  f04f4080          MOV      r0,#0x40000000
00005e  f7fffffe          BL       TIM_EncoderInterfaceConfig
;;;233    	                         TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);
;;;234    	TIM_ICStructInit(&TIM_ICInitStructure);
000062  4668              MOV      r0,sp
000064  f7fffffe          BL       TIM_ICStructInit
;;;235    	TIM_ICInitStructure.TIM_ICFilter = 8;//ICx_FILTER:1000£º²ÉÑùÆµÂÊfSAMPLING=fDTS/8£¬N=6;
000068  2008              MOVS     r0,#8
00006a  f8ad0008          STRH     r0,[sp,#8]
;;;236    	TIM_ICInit(TIM2, &TIM_ICInitStructure);
00006e  4669              MOV      r1,sp
000070  06c0              LSLS     r0,r0,#27
000072  f7fffffe          BL       TIM_ICInit
;;;237    	
;;;238    	// Clear all pending interrupts
;;;239    	TIM_ClearFlag(TIM2, TIM_FLAG_Update);
000076  2101              MOVS     r1,#1
000078  0788              LSLS     r0,r1,#30
00007a  f7fffffe          BL       TIM_ClearFlag
;;;240    	TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);
00007e  2201              MOVS     r2,#1
000080  4611              MOV      r1,r2
000082  0790              LSLS     r0,r2,#30
000084  f7fffffe          BL       TIM_ITConfig
;;;241    	//Reset counter
;;;242    	TIM2->CNT = 32768;
000088  f44f4000          MOV      r0,#0x8000
00008c  03c1              LSLS     r1,r0,#15
00008e  8488              STRH     r0,[r1,#0x24]
;;;243    	
;;;244    	TIM_Cmd(TIM2, ENABLE);
000090  2101              MOVS     r1,#1
000092  03c0              LSLS     r0,r0,#15
000094  f7fffffe          BL       TIM_Cmd
;;;245    }
000098  b007              ADD      sp,sp,#0x1c
00009a  bd00              POP      {pc}
;;;246    vu16 ADC_ConvertedValue[2];
                          ENDP

                  |L2.156|
                          DCD      0x40010800

                          AREA ||i.GPIO_init||, CODE, READONLY, ALIGN=2

                  GPIO_init PROC
;;;64     
;;;65     void GPIO_init(void){
000000  b510              PUSH     {r4,lr}
;;;66     /*
;;;67       GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0|GPIO_Pin_1;
;;;68       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; 
;;;69       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
;;;70       GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;71     */
;;;72     
;;;73       GPIO_InitStructure.GPIO_Pin=GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7|GPIO_Pin_0|GPIO_Pin_1;
000002  20f3              MOVS     r0,#0xf3
000004  490f              LDR      r1,|L3.68|
000006  8008              STRH     r0,[r1,#0]
;;;74       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; 
000008  2002              MOVS     r0,#2
00000a  7088              STRB     r0,[r1,#2]
;;;75       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00000c  2010              MOVS     r0,#0x10
00000e  70c8              STRB     r0,[r1,#3]
;;;76       GPIO_Init(GPIOC, &GPIO_InitStructure);
000010  480d              LDR      r0,|L3.72|
000012  f7fffffe          BL       GPIO_Init
;;;77     
;;;78       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz; 
000016  2001              MOVS     r0,#1
000018  490a              LDR      r1,|L3.68|
00001a  7088              STRB     r0,[r1,#2]
;;;79       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
00001c  2048              MOVS     r0,#0x48
00001e  70c8              STRB     r0,[r1,#3]
;;;80       GPIO_InitStructure.GPIO_Pin=GPIO_Pin_15;
000020  f44f4000          MOV      r0,#0x8000
000024  8008              STRH     r0,[r1,#0]
;;;81       GPIO_Init(GPIOB, &GPIO_InitStructure);
000026  4809              LDR      r0,|L3.76|
000028  f7fffffe          BL       GPIO_Init
;;;82     
;;;83       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz; 
00002c  2001              MOVS     r0,#1
00002e  4905              LDR      r1,|L3.68|
000030  7088              STRB     r0,[r1,#2]
;;;84       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
000032  2048              MOVS     r0,#0x48
000034  70c8              STRB     r0,[r1,#3]
;;;85       GPIO_InitStructure.GPIO_Pin=GPIO_Pin_8;
000036  f44f7080          MOV      r0,#0x100
00003a  8008              STRH     r0,[r1,#0]
;;;86       GPIO_Init(GPIOC, &GPIO_InitStructure);
00003c  4802              LDR      r0,|L3.72|
00003e  f7fffffe          BL       GPIO_Init
;;;87     }
000042  bd10              POP      {r4,pc}
;;;88     
                          ENDP

                  |L3.68|
                          DCD      GPIO_InitStructure
                  |L3.72|
                          DCD      0x40011000
                  |L3.76|
                          DCD      0x40010c00

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;126    
;;;127    void NVIC_Configuration(void){ 
000000  b508              PUSH     {r3,lr}
;;;128    	NVIC_InitTypeDef NVIC_InitStructure;
;;;129    
;;;130    #ifdef  VECT_TAB_RAM  
;;;131      /* Set the Vector Table base location at 0x20000000 */ 
;;;132      NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0); 
;;;133    #else  /* VECT_TAB_FLASH  */
;;;134      /* Set the Vector Table base location at 0x08000000 */ 
;;;135      NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);   
000002  2100              MOVS     r1,#0
000004  f04f6000          MOV      r0,#0x8000000
000008  f7fffffe          BL       NVIC_SetVectorTable
;;;136    #endif
;;;137    
;;;138      /* Configure the NVIC Preemption Priority Bits */  
;;;139      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
00000c  f44f60e0          MOV      r0,#0x700
000010  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;140    
;;;141       NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
000014  2027              MOVS     r0,#0x27
000016  f88d0000          STRB     r0,[sp,#0]
;;;142       NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00001a  2000              MOVS     r0,#0
00001c  f88d0001          STRB     r0,[sp,#1]
;;;143       NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000020  f88d0002          STRB     r0,[sp,#2]
;;;144       NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000024  2001              MOVS     r0,#1
000026  f88d0003          STRB     r0,[sp,#3]
;;;145       NVIC_Init(&NVIC_InitStructure);
00002a  4668              MOV      r0,sp
00002c  f7fffffe          BL       NVIC_Init
;;;146    }
000030  bd08              POP      {r3,pc}
;;;147    
                          ENDP


                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=2

                  RCC_Configuration PROC
;;;44     
;;;45     void RCC_Configuration(void){
000000  b510              PUSH     {r4,lr}
;;;46       /* TIM3 clock enable */
;;;47       RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2|
000002  2101              MOVS     r1,#1
000004  4804              LDR      r0,|L5.24|
000006  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;48       						 RCC_APB1Periph_TIM3|
;;;49     						 RCC_APB1Periph_TIM4|
;;;50     						 RCC_APB1Periph_TIM5|
;;;51     						 RCC_APB1Periph_USART3 , ENABLE);
;;;52     
;;;53       /* GPIOC clock enable */
;;;54       RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|
00000a  2101              MOVS     r1,#1
00000c  f642003d          MOV      r0,#0x283d
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;55       						 RCC_APB2Periph_GPIOB|
;;;56      						 RCC_APB2Periph_GPIOC|
;;;57     						 RCC_APB2Periph_GPIOD|
;;;58     						 RCC_APB2Periph_AFIO |	  //alternate function clock
;;;59     						 //RCC_APB2Periph_USART1|
;;;60     						 RCC_APB2Periph_TIM1|
;;;61     						 RCC_APB2Periph_TIM8,ENABLE);
;;;62     }
000014  bd10              POP      {r4,pc}
;;;63     
                          ENDP

000016  0000              DCW      0x0000
                  |L5.24|
                          DCD      0x0004000f

                          AREA ||i.SetupClock||, CODE, READONLY, ALIGN=1

                  SetupClock PROC
;;;21     
;;;22     void SetupClock (void){
000000  b510              PUSH     {r4,lr}
;;;23     	ErrorStatus HSEStartUpStatus;	/* RCC system reset(for debug purpose) */
;;;24     	RCC_DeInit();	/* Enable HSE */
000002  f7fffffe          BL       RCC_DeInit
;;;25     	RCC_HSEConfig(RCC_HSE_ON); /* Wait till HSE is ready */
000006  f44f3080          MOV      r0,#0x10000
00000a  f7fffffe          BL       RCC_HSEConfig
;;;26     	HSEStartUpStatus = RCC_WaitForHSEStartUp();
00000e  f7fffffe          BL       RCC_WaitForHSEStartUp
000012  4604              MOV      r4,r0
;;;27     
;;;28     	if (HSEStartUpStatus == SUCCESS)
000014  2c01              CMP      r4,#1
000016  d127              BNE      |L6.104|
;;;29     	{
;;;30     	   FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);  		/* Enable Prefetch Buffer */
000018  2010              MOVS     r0,#0x10
00001a  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;31     	   FLASH_SetLatency(FLASH_Latency_2);		   					/* Flash 2 wait state */
00001e  2002              MOVS     r0,#2
000020  f7fffffe          BL       FLASH_SetLatency
;;;32     	   RCC_HCLKConfig(RCC_SYSCLK_Div1);								/* HCLK = SYSCLK  */
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       RCC_HCLKConfig
;;;33     	   RCC_PCLK2Config(RCC_HCLK_Div1);								/* PCLK2 = HCLK , high speed AHB2=72MHz*/
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       RCC_PCLK2Config
;;;34     	   RCC_PCLK1Config(RCC_HCLK_Div2);								/* PCLK1 = HCLK/2  low speed AHB1=36MHz */
000030  02a0              LSLS     r0,r4,#10
000032  f7fffffe          BL       RCC_PCLK1Config
;;;35     	   RCC_ADCCLKConfig(RCC_PCLK2_Div6); 
000036  03e0              LSLS     r0,r4,#15
000038  f7fffffe          BL       RCC_ADCCLKConfig
;;;36     	   RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9); //	  ((uint32_t)0x00010000)
00003c  f44f11e0          MOV      r1,#0x1c0000
000040  0420              LSLS     r0,r4,#16
000042  f7fffffe          BL       RCC_PLLConfig
;;;37     	   																/* PLLCLK = 8MHz * 9 = 72 MHz */
;;;38     	   RCC_PLLCmd(ENABLE);											/* Enable PLL */
000046  2001              MOVS     r0,#1
000048  f7fffffe          BL       RCC_PLLCmd
;;;39     	   while (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);			/* Wait till PLL is ready */
00004c  bf00              NOP      
                  |L6.78|
00004e  2039              MOVS     r0,#0x39
000050  f7fffffe          BL       RCC_GetFlagStatus
000054  2800              CMP      r0,#0
000056  d0fa              BEQ      |L6.78|
;;;40     	   RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);					/* Select PLL as system clock source */
000058  2002              MOVS     r0,#2
00005a  f7fffffe          BL       RCC_SYSCLKConfig
;;;41     	   while (RCC_GetSYSCLKSource() != 0x08);						/* Wait till PLL is used as system clock source */
00005e  bf00              NOP      
                  |L6.96|
000060  f7fffffe          BL       RCC_GetSYSCLKSource
000064  2808              CMP      r0,#8
000066  d1fb              BNE      |L6.96|
                  |L6.104|
;;;42     	}
;;;43     }
000068  bd10              POP      {r4,pc}
;;;44     
                          ENDP


                          AREA ||i.SysTick_Configuration||, CODE, READONLY, ALIGN=2

                  SysTick_Configuration PROC
;;;189    
;;;190    void SysTick_Configuration(u16 freq){
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;191    	SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       SysTick_CLKSourceConfig
;;;192    	SysTick_Config(72000000 / freq);
00000a  4813              LDR      r0,|L7.88|
00000c  fb90f1f4          SDIV     r1,r0,r4
000010  f1b17f80          CMP      r1,#0x1000000
000014  d300              BCC      |L7.24|
000016  e01d              B        |L7.84|
                  |L7.24|
000018  f021407f          BIC      r0,r1,#0xff000000
00001c  1e40              SUBS     r0,r0,#1
00001e  f04f22e0          MOV      r2,#0xe000e000
000022  6150              STR      r0,[r2,#0x14]
000024  1750              ASRS     r0,r2,#29
000026  220f              MOVS     r2,#0xf
000028  2800              CMP      r0,#0
00002a  da07              BGE      |L7.60|
00002c  0713              LSLS     r3,r2,#28
00002e  0e1e              LSRS     r6,r3,#24
000030  4b0a              LDR      r3,|L7.92|
000032  f000050f          AND      r5,r0,#0xf
000036  1f2d              SUBS     r5,r5,#4
000038  555e              STRB     r6,[r3,r5]
00003a  e003              B        |L7.68|
                  |L7.60|
00003c  0713              LSLS     r3,r2,#28
00003e  0e1d              LSRS     r5,r3,#24
000040  4b07              LDR      r3,|L7.96|
000042  541d              STRB     r5,[r3,r0]
                  |L7.68|
000044  bf00              NOP      
000046  2000              MOVS     r0,#0
000048  f04f22e0          MOV      r2,#0xe000e000
00004c  6190              STR      r0,[r2,#0x18]
00004e  2007              MOVS     r0,#7
000050  6110              STR      r0,[r2,#0x10]
000052  bf00              NOP      
                  |L7.84|
;;;193    }
000054  bd70              POP      {r4-r6,pc}
;;;194    /*
                          ENDP

000056  0000              DCW      0x0000
                  |L7.88|
                          DCD      0x044aa200
                  |L7.92|
                          DCD      0xe000ed18
                  |L7.96|
                          DCD      0xe000e400

                          AREA ||i.USART3_Configuration||, CODE, READONLY, ALIGN=2

                  USART3_Configuration PROC
;;;148    
;;;149    void USART3_Configuration(void){
000000  b510              PUSH     {r4,lr}
;;;150    	/* Configure USART2 Tx (PC_10) as alternate function push-pull */
;;;151    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
000002  2001              MOVS     r0,#1
000004  491d              LDR      r1,|L8.124|
000006  7088              STRB     r0,[r1,#2]
;;;152    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000008  0280              LSLS     r0,r0,#10
00000a  8008              STRH     r0,[r1,#0]
;;;153    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00000c  2018              MOVS     r0,#0x18
00000e  70c8              STRB     r0,[r1,#3]
;;;154    	GPIO_Init(GPIOC, &GPIO_InitStructure);
000010  481b              LDR      r0,|L8.128|
000012  f7fffffe          BL       GPIO_Init
;;;155    	
;;;156    	/* Configure USART2 Rx (PC_11) as input floating */
;;;157    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
000016  f44f6000          MOV      r0,#0x800
00001a  4918              LDR      r1,|L8.124|
00001c  8008              STRH     r0,[r1,#0]
;;;158    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00001e  2004              MOVS     r0,#4
000020  70c8              STRB     r0,[r1,#3]
;;;159    	GPIO_Init(GPIOC, &GPIO_InitStructure);
000022  4817              LDR      r0,|L8.128|
000024  f7fffffe          BL       GPIO_Init
;;;160    	
;;;161    	GPIO_PinRemapConfig(GPIO_PartialRemap_USART3,ENABLE);
000028  2101              MOVS     r1,#1
00002a  4816              LDR      r0,|L8.132|
00002c  f7fffffe          BL       GPIO_PinRemapConfig
;;;162    	
;;;163    	USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;
000030  2000              MOVS     r0,#0
000032  4915              LDR      r1,|L8.136|
000034  8008              STRH     r0,[r1,#0]
;;;164    	USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;
000036  8048              STRH     r0,[r1,#2]
;;;165    	USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;
000038  f44f7000          MOV      r0,#0x200
00003c  8088              STRH     r0,[r1,#4]
;;;166    	USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;
00003e  2000              MOVS     r0,#0
000040  80c8              STRH     r0,[r1,#6]
;;;167    	/* Configure the USART3 synchronous paramters */
;;;168    	USART_ClockInit(USART3, &USART_ClockInitStructure);
000042  4812              LDR      r0,|L8.140|
000044  f7fffffe          BL       USART_ClockInit
;;;169    	
;;;170    	USART_InitStructure.USART_BaudRate = 115200;
000048  f44f30e1          MOV      r0,#0x1c200
00004c  4910              LDR      r1,|L8.144|
00004e  6008              STR      r0,[r1,#0]  ; USART_InitStructure
;;;171    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000050  2000              MOVS     r0,#0
000052  8088              STRH     r0,[r1,#4]
;;;172    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000054  80c8              STRH     r0,[r1,#6]
;;;173    	USART_InitStructure.USART_Parity = USART_Parity_No ;
000056  8108              STRH     r0,[r1,#8]
;;;174    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000058  8188              STRH     r0,[r1,#0xc]
;;;175    	
;;;176    	
;;;177    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00005a  200c              MOVS     r0,#0xc
00005c  8148              STRH     r0,[r1,#0xa]
;;;178    	/* Configure USART1 basic and asynchronous paramters */
;;;179    	USART_Init(USART3, &USART_InitStructure);
00005e  480b              LDR      r0,|L8.140|
000060  f7fffffe          BL       USART_Init
;;;180    	
;;;181    	/* Enable USART1 Receive and Transmit interrupts */
;;;182    	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
000064  2201              MOVS     r2,#1
000066  f2405125          MOV      r1,#0x525
00006a  4808              LDR      r0,|L8.140|
00006c  f7fffffe          BL       USART_ITConfig
;;;183    //	USART_ITConfig(USART3, USART_IT_TC, ENABLE);
;;;184    	/* Enable USART1 */
;;;185    	USART_Cmd(USART3, ENABLE);
000070  2101              MOVS     r1,#1
000072  4806              LDR      r0,|L8.140|
000074  f7fffffe          BL       USART_Cmd
;;;186    }
000078  bd10              POP      {r4,pc}
;;;187    
                          ENDP

00007a  0000              DCW      0x0000
                  |L8.124|
                          DCD      GPIO_InitStructure
                  |L8.128|
                          DCD      0x40011000
                  |L8.132|
                          DCD      0x00140010
                  |L8.136|
                          DCD      USART_ClockInitStructure
                  |L8.140|
                          DCD      0x40004800
                  |L8.144|
                          DCD      USART_InitStructure

                          AREA ||i._ADC_Configuration||, CODE, READONLY, ALIGN=2

                  _ADC_Configuration PROC
;;;247    
;;;248    void _ADC_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;249    {
;;;250    	GPIO_InitTypeDef GPIO_InitStructure;
;;;251     	/* Configure PC.04 (ADC Channel14) as analog input -------------------------*/
;;;252      	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7;
000002  20f0              MOVS     r0,#0xf0
000004  f8ad0000          STRH     r0,[sp,#0]
;;;253      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
000008  2000              MOVS     r0,#0
00000a  f88d0003          STRB     r0,[sp,#3]
;;;254     	GPIO_Init(GPIOA, &GPIO_InitStructure);
00000e  4669              MOV      r1,sp
000010  4804              LDR      r0,|L9.36|
000012  f7fffffe          BL       GPIO_Init
;;;255    
;;;256    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_GPIOA, ENABLE);
000016  2101              MOVS     r1,#1
000018  f44f7001          MOV      r0,#0x204
00001c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;257    }
000020  bd08              POP      {r3,pc}
;;;258    
                          ENDP

000022  0000              DCW      0x0000
                  |L9.36|
                          DCD      0x40010800

                          AREA ||i._ADC_Initialization||, CODE, READONLY, ALIGN=2

                  _ADC_Initialization PROC
;;;283    
;;;284    void _ADC_Initialization(void)
000000  b500              PUSH     {lr}
;;;285    {
000002  b085              SUB      sp,sp,#0x14
;;;286    	ADC_InitTypeDef ADC_InitStructure;
;;;287    	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;288    	ADC_InitStructure.ADC_ScanConvMode = ENABLE;
000008  2001              MOVS     r0,#1
00000a  f88d0004          STRB     r0,[sp,#4]
;;;289    	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
00000e  f88d0005          STRB     r0,[sp,#5]
;;;290        ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; 	//×ª»»ÓÉÈí¼þ¶ø²»ÊÇÍâ²¿´¥·¢
000012  f44f2060          MOV      r0,#0xe0000
000016  9002              STR      r0,[sp,#8]
;;;291        ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
000018  2000              MOVS     r0,#0
00001a  9003              STR      r0,[sp,#0xc]
;;;292        ADC_InitStructure.ADC_NbrOfChannel = 2;
00001c  2002              MOVS     r0,#2
00001e  f88d0010          STRB     r0,[sp,#0x10]
;;;293        ADC_Init(ADC1, &ADC_InitStructure);
000022  4669              MOV      r1,sp
000024  480c              LDR      r0,|L10.88|
000026  f7fffffe          BL       ADC_Init
;;;294    	  
;;;295        ADC_RegularChannelConfig(ADC1, ADC_Channel_4, 1, ADC_SampleTime_239Cycles5);	   //12M/(239.5+12.5)=47.62 KHz
00002a  2307              MOVS     r3,#7
00002c  2201              MOVS     r2,#1
00002e  2104              MOVS     r1,#4
000030  4809              LDR      r0,|L10.88|
000032  f7fffffe          BL       ADC_RegularChannelConfig
;;;296    	ADC_RegularChannelConfig(ADC1, ADC_Channel_6, 2, ADC_SampleTime_239Cycles5);	
000036  2307              MOVS     r3,#7
000038  2202              MOVS     r2,#2
00003a  2106              MOVS     r1,#6
00003c  4806              LDR      r0,|L10.88|
00003e  f7fffffe          BL       ADC_RegularChannelConfig
;;;297        /* Enable ADC1 DMA */
;;;298        ADC_DMACmd(ADC1, ENABLE);
000042  2101              MOVS     r1,#1
000044  4804              LDR      r0,|L10.88|
000046  f7fffffe          BL       ADC_DMACmd
;;;299    	  
;;;300        /* Enable ADC1 */
;;;301        ADC_Cmd(ADC1, ENABLE);
00004a  2101              MOVS     r1,#1
00004c  4802              LDR      r0,|L10.88|
00004e  f7fffffe          BL       ADC_Cmd
;;;302    }
000052  b005              ADD      sp,sp,#0x14
000054  bd00              POP      {pc}
;;;303    
                          ENDP

000056  0000              DCW      0x0000
                  |L10.88|
                          DCD      0x40012400

                          AREA ||i._DMA_Configuration||, CODE, READONLY, ALIGN=1

                  _DMA_Configuration PROC
;;;258    
;;;259    void _DMA_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;260    {
;;;261    	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
000002  2101              MOVS     r1,#1
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;262    }
00000a  bd10              POP      {r4,pc}
;;;263    
                          ENDP


                          AREA ||i._DMA_Initialization||, CODE, READONLY, ALIGN=2

                  _DMA_Initialization PROC
;;;263    
;;;264    void _DMA_Initialization(void)
000000  b500              PUSH     {lr}
;;;265    {
000002  b08b              SUB      sp,sp,#0x2c
;;;266    	DMA_InitTypeDef DMA_InitStructure;
;;;267    	DMA_DeInit(DMA1_Channel1);
000004  4811              LDR      r0,|L12.76|
000006  f7fffffe          BL       DMA_DeInit
;;;268        DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address;
00000a  4811              LDR      r0,|L12.80|
00000c  9000              STR      r0,[sp,#0]
;;;269        DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&ADC_ConvertedValue;
00000e  4811              LDR      r0,|L12.84|
000010  9001              STR      r0,[sp,#4]
;;;270        DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
000012  2000              MOVS     r0,#0
000014  9002              STR      r0,[sp,#8]
;;;271        DMA_InitStructure.DMA_BufferSize = 2;
000016  2002              MOVS     r0,#2
000018  9003              STR      r0,[sp,#0xc]
;;;272        DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
00001a  2000              MOVS     r0,#0
00001c  9004              STR      r0,[sp,#0x10]
;;;273        DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;		//ÄÚ´æµØÖ·¼Ä´æÆ÷µÝÔö£¡
00001e  2080              MOVS     r0,#0x80
000020  9005              STR      r0,[sp,#0x14]
;;;274        DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
000022  0040              LSLS     r0,r0,#1
000024  9006              STR      r0,[sp,#0x18]
;;;275        DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
000026  0080              LSLS     r0,r0,#2
000028  9007              STR      r0,[sp,#0x1c]
;;;276        DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
00002a  2020              MOVS     r0,#0x20
00002c  9008              STR      r0,[sp,#0x20]
;;;277        DMA_InitStructure.DMA_Priority = DMA_Priority_High;
00002e  0200              LSLS     r0,r0,#8
000030  9009              STR      r0,[sp,#0x24]
;;;278        DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
000032  2000              MOVS     r0,#0
000034  900a              STR      r0,[sp,#0x28]
;;;279        DMA_Init(DMA1_Channel1, &DMA_InitStructure);
000036  4669              MOV      r1,sp
000038  4804              LDR      r0,|L12.76|
00003a  f7fffffe          BL       DMA_Init
;;;280    
;;;281    	DMA_Cmd(DMA1_Channel1, ENABLE);
00003e  2101              MOVS     r1,#1
000040  4802              LDR      r0,|L12.76|
000042  f7fffffe          BL       DMA_Cmd
;;;282    }
000046  b00b              ADD      sp,sp,#0x2c
000048  bd00              POP      {pc}
;;;283    
                          ENDP

00004a  0000              DCW      0x0000
                  |L12.76|
                          DCD      0x40020008
                  |L12.80|
                          DCD      0x4001244c
                  |L12.84|
                          DCD      ADC_ConvertedValue

                          AREA ||i.system_init||, CODE, READONLY, ALIGN=2

                  system_init PROC
;;;321    
;;;322    void system_init(u16 sysFreq) //in Hz
000000  b510              PUSH     {r4,lr}
;;;323    {
000002  4604              MOV      r4,r0
;;;324    	SetupClock();
000004  f7fffffe          BL       SetupClock
;;;325    	RCC_Configuration();
000008  f7fffffe          BL       RCC_Configuration
;;;326    
;;;327    	GPIO_init();
00000c  f7fffffe          BL       GPIO_init
;;;328    
;;;329    	timer3_pwm_init();
000010  f7fffffe          BL       timer3_pwm_init
;;;330    	
;;;331    	USART3_Configuration();
000014  f7fffffe          BL       USART3_Configuration
;;;332    
;;;333    	Encoder_init1();
000018  f7fffffe          BL       Encoder_init1
;;;334    										
;;;335    	SysTick_Configuration(sysFreq);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       SysTick_Configuration
;;;336    	
;;;337    	NVIC_Configuration();
000022  f7fffffe          BL       NVIC_Configuration
;;;338      
;;;339    	connect_state = 0;
000026  2000              MOVS     r0,#0
000028  4906              LDR      r1,|L13.68|
00002a  7008              STRB     r0,[r1,#0]
;;;340    
;;;341    	_ADC_Configuration();
00002c  f7fffffe          BL       _ADC_Configuration
;;;342    
;;;343    	_DMA_Configuration();
000030  f7fffffe          BL       _DMA_Configuration
;;;344    
;;;345    	_DMA_Initialization();
000034  f7fffffe          BL       _DMA_Initialization
;;;346    
;;;347        _ADC_Initialization();
000038  f7fffffe          BL       _ADC_Initialization
;;;348    
;;;349        ADC_Calibaration();
00003c  f7fffffe          BL       ADC_Calibaration
;;;350     
;;;351    }
000040  bd10              POP      {r4,pc}
;;;352    
                          ENDP

000042  0000              DCW      0x0000
                  |L13.68|
                          DCD      connect_state

                          AREA ||i.system_para_init||, CODE, READONLY, ALIGN=2

                  system_para_init PROC
;;;357    
;;;358    void system_para_init(void)
000000  b510              PUSH     {r4,lr}
;;;359    {
;;;360     	motion_set_motor(0 , 1);
000002  2101              MOVS     r1,#1
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       motion_set_motor
;;;361    
;;;362    	connect_state = 0;
00000a  2000              MOVS     r0,#0
00000c  4901              LDR      r1,|L14.20|
00000e  7008              STRB     r0,[r1,#0]
;;;363    }
000010  bd10              POP      {r4,pc}
                          ENDP

000012  0000              DCW      0x0000
                  |L14.20|
                          DCD      connect_state

                          AREA ||i.system_pwm_enable||, CODE, READONLY, ALIGN=2

                  system_pwm_enable PROC
;;;352    
;;;353    void system_pwm_enable(void)
000000  b510              PUSH     {r4,lr}
;;;354    {
;;;355    	TIM_CtrlPWMOutputs(TIM1, ENABLE);
000002  2101              MOVS     r1,#1
000004  4801              LDR      r0,|L15.12|
000006  f7fffffe          BL       TIM_CtrlPWMOutputs
;;;356    }
00000a  bd10              POP      {r4,pc}
;;;357    
                          ENDP

                  |L15.12|
                          DCD      0x40012c00

                          AREA ||i.timer3_pwm_init||, CODE, READONLY, ALIGN=2

                  timer3_pwm_init PROC
;;;88     
;;;89     void timer3_pwm_init(void){
000000  b500              PUSH     {lr}
000002  b087              SUB      sp,sp,#0x1c
;;;90     
;;;91        TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;92        TIM_OCInitTypeDef  TIM_OCInitStructure;
;;;93        //GPIO_InitTypeDef GPIO_InitStructure;
;;;94     /* GPIOA Configuration:TIM1 ch1 2 3 4, output pp*/
;;;95       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
000004  2001              MOVS     r0,#1
000006  491e              LDR      r1,|L16.128|
000008  8008              STRH     r0,[r1,#0]
;;;96       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	//OD;
00000a  2018              MOVS     r0,#0x18
00000c  70c8              STRB     r0,[r1,#3]
;;;97       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
00000e  2001              MOVS     r0,#1
000010  7088              STRB     r0,[r1,#2]
;;;98       GPIO_Init(GPIOB, &GPIO_InitStructure);
000012  481c              LDR      r0,|L16.132|
000014  f7fffffe          BL       GPIO_Init
;;;99     
;;;100    
;;;101      /* Time base configuration */
;;;102      TIM_TimeBaseStructure.TIM_Period = 1799;  // 40KHZ    4500;	  //16KHz
000018  f2407007          MOV      r0,#0x707
00001c  f8ad0014          STRH     r0,[sp,#0x14]
;;;103      TIM_TimeBaseStructure.TIM_ClockDivision =  TIM_CKD_DIV1;
000020  2000              MOVS     r0,#0
000022  f8ad0016          STRH     r0,[sp,#0x16]
;;;104      TIM_TimeBaseStructure.TIM_Prescaler = 0;
000026  f8ad0010          STRH     r0,[sp,#0x10]
;;;105      TIM_TimeBaseStructure.TIM_ClockDivision = 0;
00002a  f8ad0016          STRH     r0,[sp,#0x16]
;;;106      TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
00002e  f8ad0012          STRH     r0,[sp,#0x12]
;;;107    
;;;108      TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
000032  a904              ADD      r1,sp,#0x10
000034  4814              LDR      r0,|L16.136|
000036  f7fffffe          BL       TIM_TimeBaseInit
;;;109    
;;;110      /* PWM1 Mode configuration: Channel1 */
;;;111      TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;  
00003a  2060              MOVS     r0,#0x60
00003c  f8ad0000          STRH     r0,[sp,#0]
;;;112      TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
000040  2000              MOVS     r0,#0
000042  f8ad0008          STRH     r0,[sp,#8]
;;;113      TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
000046  2001              MOVS     r0,#1
000048  f8ad0002          STRH     r0,[sp,#2]
;;;114      TIM_OCInitStructure.TIM_Pulse = 0;
00004c  2000              MOVS     r0,#0
00004e  f8ad0006          STRH     r0,[sp,#6]
;;;115      TIM_OC3Init(TIM3, &TIM_OCInitStructure);
000052  4669              MOV      r1,sp
000054  480c              LDR      r0,|L16.136|
000056  f7fffffe          BL       TIM_OC3Init
;;;116      TIM_OC3PreloadConfig(TIM3, TIM_OCPreload_Enable);
00005a  2108              MOVS     r1,#8
00005c  480a              LDR      r0,|L16.136|
00005e  f7fffffe          BL       TIM_OC3PreloadConfig
;;;117    
;;;118    
;;;119      TIM_ARRPreloadConfig(TIM3, ENABLE);
000062  2101              MOVS     r1,#1
000064  4808              LDR      r0,|L16.136|
000066  f7fffffe          BL       TIM_ARRPreloadConfig
;;;120    
;;;121      /* TIM enable counter */
;;;122      TIM_Cmd(TIM3, ENABLE);
00006a  2101              MOVS     r1,#1
00006c  4806              LDR      r0,|L16.136|
00006e  f7fffffe          BL       TIM_Cmd
;;;123      TIM_CtrlPWMOutputs(TIM3, ENABLE);
000072  2101              MOVS     r1,#1
000074  4804              LDR      r0,|L16.136|
000076  f7fffffe          BL       TIM_CtrlPWMOutputs
;;;124    
;;;125    }
00007a  b007              ADD      sp,sp,#0x1c
00007c  bd00              POP      {pc}
;;;126    
                          ENDP

00007e  0000              DCW      0x0000
                  |L16.128|
                          DCD      GPIO_InitStructure
                  |L16.132|
                          DCD      0x40010c00
                  |L16.136|
                          DCD      0x40000400

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  USART_InitStructure
                          %        16

                          AREA ||.data||, DATA, ALIGN=1

                  USART_ClockInitStructure
                          %        8
                  GPIO_InitStructure
                          DCDU     0x00000000
                  CCR1_Val
00000c  0000              DCW      0x0000
                  CCR2_Val
00000e  0000              DCW      0x0000
                  CCR3_Val
000010  0000              DCW      0x0000
                  CCR4_Val
000012  0000              DCW      0x0000
                  PrescalerValue
000014  0000              DCW      0x0000
                  connect_state
000016  00                DCB      0x00
                  control_state
000017  00                DCB      0x00
                  ADC_ConvertedValue
                          DCDU     0x00000000
