; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\stm32f10x_tim.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\stm32f10x_tim.d --cpu=Cortex-M3 --apcs=interwork -O0 -I.\FWlib\inc -I.\user -I"C:\Users\Kenneth Au\Desktop\toKenneth\Complicated Big Motor Control\(encoder)24V Big Blue Black Motor Control June 7\RTE" -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=513 -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=.\obj\stm32f10x_tim.crf FWlib\SRC\stm32f10x_tim.c]
                          THUMB

                          AREA ||i.TI1_Config||, CODE, READONLY, ALIGN=1

                  TI1_Config PROC
;;;2695     */
;;;2696   static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2697                          uint16_t TIM_ICFilter)
;;;2698   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;2699     uint16_t tmpccmr1 = 0, tmpccer = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
;;;2700     /* Disable the Channel 1: Reset the CC1E Bit */
;;;2701     TIMx->CCER &= CCER_CC1E_Reset;
00000a  8c06              LDRH     r6,[r0,#0x20]
00000c  f64f77fe          MOV      r7,#0xfffe
000010  403e              ANDS     r6,r6,r7
000012  8406              STRH     r6,[r0,#0x20]
;;;2702     tmpccmr1 = TIMx->CCMR1;
000014  8b01              LDRH     r1,[r0,#0x18]
;;;2703     tmpccer = TIMx->CCER;
000016  8c02              LDRH     r2,[r0,#0x20]
;;;2704     /* Select the Input and set the filter */
;;;2705     tmpccmr1 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
000018  f64f760c          MOV      r6,#0xff0c
00001c  4031              ANDS     r1,r1,r6
;;;2706     tmpccmr1 |= TIM_ICSelection | (uint16_t)(TIM_ICFilter << 4);
00001e  1c7e              ADDS     r6,r7,#1
000020  ea061603          AND      r6,r6,r3,LSL #4
000024  432e              ORRS     r6,r6,r5
000026  4331              ORRS     r1,r1,r6
;;;2707     /* Select the Polarity and set the CC1E Bit */
;;;2708     tmpccer &= CCER_CC1P_Reset;
000028  1e7e              SUBS     r6,r7,#1
00002a  4032              ANDS     r2,r2,r6
;;;2709     tmpccer |= TIM_ICPolarity | CCER_CC1E_Set;
00002c  f0440601          ORR      r6,r4,#1
000030  4332              ORRS     r2,r2,r6
;;;2710     /* Write to TIMx CCMR1 and CCER registers */
;;;2711     TIMx->CCMR1 = tmpccmr1;
000032  8301              STRH     r1,[r0,#0x18]
;;;2712     TIMx->CCER = tmpccer;
000034  8402              STRH     r2,[r0,#0x20]
;;;2713   }
000036  bdf0              POP      {r4-r7,pc}
;;;2714   
                          ENDP


                          AREA ||i.TI2_Config||, CODE, READONLY, ALIGN=1

                  TI2_Config PROC
;;;2734     */
;;;2735   static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2736                          uint16_t TIM_ICFilter)
;;;2737   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;2738     uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
00000a  2600              MOVS     r6,#0
;;;2739     /* Disable the Channel 2: Reset the CC2E Bit */
;;;2740     TIMx->CCER &= CCER_CC2E_Reset;
00000c  8c07              LDRH     r7,[r0,#0x20]
00000e  f64f7cef          MOV      r12,#0xffef
000012  ea07070c          AND      r7,r7,r12
000016  8407              STRH     r7,[r0,#0x20]
;;;2741     tmpccmr1 = TIMx->CCMR1;
000018  8b01              LDRH     r1,[r0,#0x18]
;;;2742     tmpccer = TIMx->CCER;
00001a  8c02              LDRH     r2,[r0,#0x20]
;;;2743     tmp = (uint16_t)(TIM_ICPolarity << 4);
00001c  f64f77ff          MOV      r7,#0xffff
000020  ea071604          AND      r6,r7,r4,LSL #4
;;;2744     /* Select the Input and set the filter */
;;;2745     tmpccmr1 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
000024  f64047ff          MOV      r7,#0xcff
000028  4039              ANDS     r1,r1,r7
;;;2746     tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
00002a  f64f77ff          MOV      r7,#0xffff
00002e  ea073703          AND      r7,r7,r3,LSL #12
000032  4339              ORRS     r1,r1,r7
;;;2747     tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
000034  f64f77ff          MOV      r7,#0xffff
000038  ea072705          AND      r7,r7,r5,LSL #8
00003c  4339              ORRS     r1,r1,r7
;;;2748     /* Select the Polarity and set the CC2E Bit */
;;;2749     tmpccer &= CCER_CC2P_Reset;
00003e  f64f77df          MOV      r7,#0xffdf
000042  403a              ANDS     r2,r2,r7
;;;2750     tmpccer |=  tmp | CCER_CC2E_Set;
000044  f0460710          ORR      r7,r6,#0x10
000048  433a              ORRS     r2,r2,r7
;;;2751     /* Write to TIMx CCMR1 and CCER registers */
;;;2752     TIMx->CCMR1 = tmpccmr1 ;
00004a  8301              STRH     r1,[r0,#0x18]
;;;2753     TIMx->CCER = tmpccer;
00004c  8402              STRH     r2,[r0,#0x20]
;;;2754   }
00004e  bdf0              POP      {r4-r7,pc}
;;;2755   
                          ENDP


                          AREA ||i.TI3_Config||, CODE, READONLY, ALIGN=1

                  TI3_Config PROC
;;;2775     */
;;;2776   static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2777                          uint16_t TIM_ICFilter)
;;;2778   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;2779     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
00000a  2600              MOVS     r6,#0
;;;2780     /* Disable the Channel 3: Reset the CC3E Bit */
;;;2781     TIMx->CCER &= CCER_CC3E_Reset;
00000c  8c07              LDRH     r7,[r0,#0x20]
00000e  f64f6cff          MOV      r12,#0xfeff
000012  ea07070c          AND      r7,r7,r12
000016  8407              STRH     r7,[r0,#0x20]
;;;2782     tmpccmr2 = TIMx->CCMR2;
000018  8b81              LDRH     r1,[r0,#0x1c]
;;;2783     tmpccer = TIMx->CCER;
00001a  8c02              LDRH     r2,[r0,#0x20]
;;;2784     tmp = (uint16_t)(TIM_ICPolarity << 8);
00001c  f64f77ff          MOV      r7,#0xffff
000020  ea072604          AND      r6,r7,r4,LSL #8
;;;2785     /* Select the Input and set the filter */
;;;2786     tmpccmr2 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
000024  f64f770c          MOV      r7,#0xff0c
000028  4039              ANDS     r1,r1,r7
;;;2787     tmpccmr2 |= TIM_ICSelection | (uint16_t)(TIM_ICFilter << 4);
00002a  f64f77ff          MOV      r7,#0xffff
00002e  ea071703          AND      r7,r7,r3,LSL #4
000032  432f              ORRS     r7,r7,r5
000034  4339              ORRS     r1,r1,r7
;;;2788     /* Select the Polarity and set the CC3E Bit */
;;;2789     tmpccer &= CCER_CC3P_Reset;
000036  f64f57ff          MOV      r7,#0xfdff
00003a  403a              ANDS     r2,r2,r7
;;;2790     tmpccer |= tmp | CCER_CC3E_Set;
00003c  f4467780          ORR      r7,r6,#0x100
000040  433a              ORRS     r2,r2,r7
;;;2791     /* Write to TIMx CCMR2 and CCER registers */
;;;2792     TIMx->CCMR2 = tmpccmr2;
000042  8381              STRH     r1,[r0,#0x1c]
;;;2793     TIMx->CCER = tmpccer;
000044  8402              STRH     r2,[r0,#0x20]
;;;2794   }
000046  bdf0              POP      {r4-r7,pc}
;;;2795   
                          ENDP


                          AREA ||i.TI4_Config||, CODE, READONLY, ALIGN=1

                  TI4_Config PROC
;;;2815     */
;;;2816   static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2817                          uint16_t TIM_ICFilter)
;;;2818   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;2819     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000006  2100              MOVS     r1,#0
000008  2200              MOVS     r2,#0
00000a  2600              MOVS     r6,#0
;;;2820     /* Disable the Channel 4: Reset the CC4E Bit */
;;;2821     TIMx->CCER &= CCER_CC4E_Reset;
00000c  8c07              LDRH     r7,[r0,#0x20]
00000e  f64e7cff          MOV      r12,#0xefff
000012  ea07070c          AND      r7,r7,r12
000016  8407              STRH     r7,[r0,#0x20]
;;;2822     tmpccmr2 = TIMx->CCMR2;
000018  8b81              LDRH     r1,[r0,#0x1c]
;;;2823     tmpccer = TIMx->CCER;
00001a  8c02              LDRH     r2,[r0,#0x20]
;;;2824     tmp = (uint16_t)(TIM_ICPolarity << 12);
00001c  f64f77ff          MOV      r7,#0xffff
000020  ea073604          AND      r6,r7,r4,LSL #12
;;;2825     /* Select the Input and set the filter */
;;;2826     tmpccmr2 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
000024  f64047ff          MOV      r7,#0xcff
000028  4039              ANDS     r1,r1,r7
;;;2827     tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8) | (uint16_t)(TIM_ICFilter << 12);
00002a  f64f77ff          MOV      r7,#0xffff
00002e  ea072705          AND      r7,r7,r5,LSL #8
000032  f64f7cff          MOV      r12,#0xffff
000036  ea0c3c03          AND      r12,r12,r3,LSL #12
00003a  ea47070c          ORR      r7,r7,r12
00003e  4339              ORRS     r1,r1,r7
;;;2828     /* Select the Polarity and set the CC4E Bit */
;;;2829     tmpccer &= CCER_CC4P_Reset;
000040  f64d77ff          MOV      r7,#0xdfff
000044  403a              ANDS     r2,r2,r7
;;;2830     tmpccer |= tmp | CCER_CC4E_Set;
000046  f4465780          ORR      r7,r6,#0x1000
00004a  433a              ORRS     r2,r2,r7
;;;2831     /* Write to TIMx CCMR2 and CCER registers */
;;;2832     TIMx->CCMR2 = tmpccmr2;
00004c  8381              STRH     r1,[r0,#0x1c]
;;;2833     TIMx->CCER = tmpccer ;
00004e  8402              STRH     r2,[r0,#0x20]
;;;2834   }
000050  bdf0              POP      {r4-r7,pc}
;;;2835   
                          ENDP


                          AREA ||i.TIM_ARRPreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_ARRPreloadConfig PROC
;;;1417     */
;;;1418   void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L5.12|
;;;1419   {
;;;1420     /* Check the parameters */
;;;1421     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1422     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1423     if (NewState != DISABLE)
;;;1424     {
;;;1425       /* Set the ARR Preload Bit */
;;;1426       TIMx->CR1 |= CR1_ARPE_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420280          ORR      r2,r2,#0x80
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L5.22|
                  |L5.12|
;;;1427     }
;;;1428     else
;;;1429     {
;;;1430       /* Reset the ARR Preload Bit */
;;;1431       TIMx->CR1 &= CR1_ARPE_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f240337f          MOV      r3,#0x37f
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L5.22|
;;;1432     }
;;;1433   }
000016  4770              BX       lr
;;;1434   
                          ENDP


                          AREA ||i.TIM_BDTRConfig||, CODE, READONLY, ALIGN=1

                  TIM_BDTRConfig PROC
;;;712      */
;;;713    void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
000000  880a              LDRH     r2,[r1,#0]
;;;714    {
;;;715      /* Check the parameters */
;;;716      assert_param(IS_TIM_18_PERIPH(TIMx));
;;;717      assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;718      assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;719      assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;720      assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;721      assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;722      assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;723      /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
;;;724         the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;725      TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
000002  884b              LDRH     r3,[r1,#2]
000004  431a              ORRS     r2,r2,r3
000006  888b              LDRH     r3,[r1,#4]
000008  431a              ORRS     r2,r2,r3
00000a  88cb              LDRH     r3,[r1,#6]
00000c  431a              ORRS     r2,r2,r3
00000e  890b              LDRH     r3,[r1,#8]
000010  431a              ORRS     r2,r2,r3
000012  894b              LDRH     r3,[r1,#0xa]
000014  431a              ORRS     r2,r2,r3
000016  898b              LDRH     r3,[r1,#0xc]
000018  431a              ORRS     r2,r2,r3
00001a  f8a02044          STRH     r2,[r0,#0x44]
;;;726                 TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;727                 TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;728                 TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;729    }
00001e  4770              BX       lr
;;;730    
                          ENDP


                          AREA ||i.TIM_BDTRStructInit||, CODE, READONLY, ALIGN=1

                  TIM_BDTRStructInit PROC
;;;787      */
;;;788    void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
000000  2100              MOVS     r1,#0
;;;789    {
;;;790      /* Set the default configuration */
;;;791      TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;792      TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;793      TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
000006  8081              STRH     r1,[r0,#4]
;;;794      TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
000008  80c1              STRH     r1,[r0,#6]
;;;795      TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
00000a  8101              STRH     r1,[r0,#8]
;;;796      TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
00000c  8141              STRH     r1,[r0,#0xa]
;;;797      TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
00000e  8181              STRH     r1,[r0,#0xc]
;;;798    }
000010  4770              BX       lr
;;;799    
                          ENDP


                          AREA ||i.TIM_CCPreloadControl||, CODE, READONLY, ALIGN=1

                  TIM_CCPreloadControl PROC
;;;1491     */
;;;1492   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L8.12|
;;;1493   { 
;;;1494     /* Check the parameters */
;;;1495     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1496     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1497     if (NewState != DISABLE)
;;;1498     {
;;;1499       /* Set the CCPC Bit */
;;;1500       TIMx->CR2 |= CR2_CCPC_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420201          ORR      r2,r2,#1
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L8.22|
                  |L8.12|
;;;1501     }
;;;1502     else
;;;1503     {
;;;1504       /* Reset the CCPC Bit */
;;;1505       TIMx->CR2 &= CR2_CCPC_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L8.22|
;;;1506     }
;;;1507   }
000016  4770              BX       lr
;;;1508   
                          ENDP


                          AREA ||i.TIM_CCxCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxCmd PROC
;;;1999     */
;;;2000   void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
000000  b510              PUSH     {r4,lr}
;;;2001   {
;;;2002     /* Check the parameters */
;;;2003     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2004     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;2005     assert_param(IS_TIM_CCX(TIM_CCx));
;;;2006     /* Reset the CCxE Bit */
;;;2007     TIMx->CCER &= (uint16_t)(~((uint16_t)(CCER_CCE_Set << TIM_Channel)));
000002  8c03              LDRH     r3,[r0,#0x20]
000004  2401              MOVS     r4,#1
000006  408c              LSLS     r4,r4,r1
000008  43a3              BICS     r3,r3,r4
00000a  8403              STRH     r3,[r0,#0x20]
;;;2008     /* Set or reset the CCxE Bit */ 
;;;2009     TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
00000c  8c03              LDRH     r3,[r0,#0x20]
00000e  fa02f401          LSL      r4,r2,r1
000012  b2a4              UXTH     r4,r4
000014  4323              ORRS     r3,r3,r4
000016  8403              STRH     r3,[r0,#0x20]
;;;2010   }
000018  bd10              POP      {r4,pc}
;;;2011   
                          ENDP


                          AREA ||i.TIM_CCxNCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxNCmd PROC
;;;2023     */
;;;2024   void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
000000  b510              PUSH     {r4,lr}
;;;2025   {
;;;2026     /* Check the parameters */
;;;2027     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;2028     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;2029     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;2030     /* Reset the CCxNE Bit */
;;;2031     TIMx->CCER &= (uint16_t)(~((uint16_t)(CCER_CCNE_Set << TIM_Channel)));
000002  8c03              LDRH     r3,[r0,#0x20]
000004  2404              MOVS     r4,#4
000006  408c              LSLS     r4,r4,r1
000008  43a3              BICS     r3,r3,r4
00000a  8403              STRH     r3,[r0,#0x20]
;;;2032     /* Set or reset the CCxNE Bit */ 
;;;2033     TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
00000c  8c03              LDRH     r3,[r0,#0x20]
00000e  fa02f401          LSL      r4,r2,r1
000012  b2a4              UXTH     r4,r4
000014  4323              ORRS     r3,r3,r4
000016  8403              STRH     r3,[r0,#0x20]
;;;2034   }
000018  bd10              POP      {r4,pc}
;;;2035   
                          ENDP


                          AREA ||i.TIM_ClearFlag||, CODE, READONLY, ALIGN=1

                  TIM_ClearFlag PROC
;;;2601     */
;;;2602   void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  43ca              MVNS     r2,r1
;;;2603   {  
;;;2604     /* Check the parameters */
;;;2605     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2606     assert_param(IS_TIM_CLEAR_FLAG(TIMx, TIM_FLAG));
;;;2607      
;;;2608     /* Clear the flags */
;;;2609     TIMx->SR = (uint16_t)~TIM_FLAG;
000002  8202              STRH     r2,[r0,#0x10]
;;;2610   }
000004  4770              BX       lr
;;;2611   
                          ENDP


                          AREA ||i.TIM_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  TIM_ClearITPendingBit PROC
;;;2666     */
;;;2667   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  43ca              MVNS     r2,r1
;;;2668   {
;;;2669     /* Check the parameters */
;;;2670     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2671     assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
;;;2672     /* Clear the IT pending Bit */
;;;2673     TIMx->SR = (uint16_t)~TIM_IT;
000002  8202              STRH     r2,[r0,#0x10]
;;;2674   }
000004  4770              BX       lr
;;;2675   
                          ENDP


                          AREA ||i.TIM_ClearOC1Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC1Ref PROC
;;;1726     */
;;;1727   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1728   {
;;;1729     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1730     /* Check the parameters */
;;;1731     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1732     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1733     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1734     /* Reset the OC1CE Bit */
;;;1735     tmpccmr1 &= CCMR_OC13CE_Reset;
000006  f64f737f          MOV      r3,#0xff7f
00000a  4019              ANDS     r1,r1,r3
;;;1736     /* Enable or Disable the Output Compare Clear Bit */
;;;1737     tmpccmr1 |= TIM_OCClear;
00000c  4311              ORRS     r1,r1,r2
;;;1738     /* Write to TIMx CCMR1 register */
;;;1739     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1740   }
000010  4770              BX       lr
;;;1741   
                          ENDP


                          AREA ||i.TIM_ClearOC2Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC2Ref PROC
;;;1751     */
;;;1752   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1753   {
;;;1754     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1755     /* Check the parameters */
;;;1756     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1757     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1758     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1759     /* Reset the OC2CE Bit */
;;;1760     tmpccmr1 &= CCMR_OC24CE_Reset;
000006  f3c1010e          UBFX     r1,r1,#0,#15
;;;1761     /* Enable or Disable the Output Compare Clear Bit */
;;;1762     tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
00000a  f64f73ff          MOV      r3,#0xffff
00000e  ea032302          AND      r3,r3,r2,LSL #8
000012  4319              ORRS     r1,r1,r3
;;;1763     /* Write to TIMx CCMR1 register */
;;;1764     TIMx->CCMR1 = tmpccmr1;
000014  8301              STRH     r1,[r0,#0x18]
;;;1765   }
000016  4770              BX       lr
;;;1766   
                          ENDP


                          AREA ||i.TIM_ClearOC3Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC3Ref PROC
;;;1776     */
;;;1777   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1778   {
;;;1779     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1780     /* Check the parameters */
;;;1781     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1782     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1783     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1784     /* Reset the OC3CE Bit */
;;;1785     tmpccmr2 &= CCMR_OC13CE_Reset;
000006  f64f737f          MOV      r3,#0xff7f
00000a  4019              ANDS     r1,r1,r3
;;;1786     /* Enable or Disable the Output Compare Clear Bit */
;;;1787     tmpccmr2 |= TIM_OCClear;
00000c  4311              ORRS     r1,r1,r2
;;;1788     /* Write to TIMx CCMR2 register */
;;;1789     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1790   }
000010  4770              BX       lr
;;;1791   
                          ENDP


                          AREA ||i.TIM_ClearOC4Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC4Ref PROC
;;;1801     */
;;;1802   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1803   {
;;;1804     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1805     /* Check the parameters */
;;;1806     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1807     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1808     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1809     /* Reset the OC4CE Bit */
;;;1810     tmpccmr2 &= CCMR_OC24CE_Reset;
000006  f3c1010e          UBFX     r1,r1,#0,#15
;;;1811     /* Enable or Disable the Output Compare Clear Bit */
;;;1812     tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
00000a  f64f73ff          MOV      r3,#0xffff
00000e  ea032302          AND      r3,r3,r2,LSL #8
000012  4319              ORRS     r1,r1,r3
;;;1813     /* Write to TIMx CCMR2 register */
;;;1814     TIMx->CCMR2 = tmpccmr2;
000014  8381              STRH     r1,[r0,#0x1c]
;;;1815   }
000016  4770              BX       lr
;;;1816   
                          ENDP


                          AREA ||i.TIM_Cmd||, CODE, READONLY, ALIGN=1

                  TIM_Cmd PROC
;;;806      */
;;;807    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L17.12|
;;;808    {
;;;809      /* Check the parameters */
;;;810      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;811      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;812      
;;;813      if (NewState != DISABLE)
;;;814      {
;;;815        /* Enable the TIM Counter */
;;;816        TIMx->CR1 |= CR1_CEN_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420201          ORR      r2,r2,#1
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L17.22|
                  |L17.12|
;;;817      }
;;;818      else
;;;819      {
;;;820        /* Disable the TIM Counter */
;;;821        TIMx->CR1 &= CR1_CEN_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f24033fe          MOV      r3,#0x3fe
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L17.22|
;;;822      }
;;;823    }
000016  4770              BX       lr
;;;824    
                          ENDP


                          AREA ||i.TIM_CounterModeConfig||, CODE, READONLY, ALIGN=1

                  TIM_CounterModeConfig PROC
;;;1197     */
;;;1198   void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
000000  460a              MOV      r2,r1
;;;1199   {
;;;1200     uint16_t tmpcr1 = 0;
000002  2100              MOVS     r1,#0
;;;1201     /* Check the parameters */
;;;1202     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1203     assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;1204     tmpcr1 = TIMx->CR1;
000004  8801              LDRH     r1,[r0,#0]
;;;1205     /* Reset the CMS and DIR Bits */
;;;1206     tmpcr1 &= CR1_CounterMode_Mask;
000006  f240338f          MOV      r3,#0x38f
00000a  4019              ANDS     r1,r1,r3
;;;1207     /* Set the Counter Mode */
;;;1208     tmpcr1 |= TIM_CounterMode;
00000c  4311              ORRS     r1,r1,r2
;;;1209     /* Write to TIMx CR1 register */
;;;1210     TIMx->CR1 = tmpcr1;
00000e  8001              STRH     r1,[r0,#0]
;;;1211   }
000010  4770              BX       lr
;;;1212   
                          ENDP


                          AREA ||i.TIM_CtrlPWMOutputs||, CODE, READONLY, ALIGN=1

                  TIM_CtrlPWMOutputs PROC
;;;831      */
;;;832    void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b131              CBZ      r1,|L19.16|
;;;833    {
;;;834      /* Check the parameters */
;;;835      assert_param(IS_TIM_18_PERIPH(TIMx));
;;;836      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;837      if (NewState != DISABLE)
;;;838      {
;;;839        /* Enable the TIM Main Output */
;;;840        TIMx->BDTR |= BDTR_MOE_Set;
000002  f8b02044          LDRH     r2,[r0,#0x44]
000006  f4424200          ORR      r2,r2,#0x8000
00000a  f8a02044          STRH     r2,[r0,#0x44]
00000e  e005              B        |L19.28|
                  |L19.16|
;;;841      }
;;;842      else
;;;843      {
;;;844        /* Disable the TIM Main Output */
;;;845        TIMx->BDTR &= BDTR_MOE_Reset;
000010  f8b02044          LDRH     r2,[r0,#0x44]
000014  f3c2020e          UBFX     r2,r2,#0,#15
000018  f8a02044          STRH     r2,[r0,#0x44]
                  |L19.28|
;;;846      }  
;;;847    }
00001c  4770              BX       lr
;;;848    
                          ENDP


                          AREA ||i.TIM_DMACmd||, CODE, READONLY, ALIGN=1

                  TIM_DMACmd PROC
;;;953      */
;;;954    void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
000000  b11a              CBZ      r2,|L20.10|
;;;955    { 
;;;956      /* Check the parameters */
;;;957      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;958      assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;959      assert_param(IS_TIM_PERIPH_DMA(TIMx, TIM_DMASource));
;;;960      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;961      
;;;962      if (NewState != DISABLE)
;;;963      {
;;;964        /* Enable the DMA sources */
;;;965        TIMx->DIER |= TIM_DMASource; 
000002  8983              LDRH     r3,[r0,#0xc]
000004  430b              ORRS     r3,r3,r1
000006  8183              STRH     r3,[r0,#0xc]
000008  e002              B        |L20.16|
                  |L20.10|
;;;966      }
;;;967      else
;;;968      {
;;;969        /* Disable the DMA sources */
;;;970        TIMx->DIER &= (uint16_t)~TIM_DMASource;
00000a  8983              LDRH     r3,[r0,#0xc]
00000c  438b              BICS     r3,r3,r1
00000e  8183              STRH     r3,[r0,#0xc]
                  |L20.16|
;;;971      }
;;;972    }
000010  4770              BX       lr
;;;973    
                          ENDP


                          AREA ||i.TIM_DMAConfig||, CODE, READONLY, ALIGN=1

                  TIM_DMAConfig PROC
;;;927      */
;;;928    void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
000000  ea410302          ORR      r3,r1,r2
;;;929    {
;;;930      /* Check the parameters */
;;;931      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;932      assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
;;;933      assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;934      /* Set the DMA Base and the DMA Burst Length */
;;;935      TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
000004  f8a03048          STRH     r3,[r0,#0x48]
;;;936    }
000008  4770              BX       lr
;;;937    
                          ENDP


                          AREA ||i.TIM_DeInit||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;187      */
;;;188    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  b510              PUSH     {r4,lr}
;;;189    {
000002  4604              MOV      r4,r0
;;;190      /* Check the parameters */
;;;191      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;192     
;;;193      switch (*(uint32_t*)&TIMx)
000004  4934              LDR      r1,|L22.216|
000006  1a60              SUBS     r0,r4,r1
000008  428c              CMP      r4,r1
00000a  d045              BEQ      |L22.152|
00000c  dc0c              BGT      |L22.40|
00000e  f1b44f80          CMP      r4,#0x40000000
000012  d01d              BEQ      |L22.80|
000014  4831              LDR      r0,|L22.220|
000016  4420              ADD      r0,r0,r4
000018  b318              CBZ      r0,|L22.98|
00001a  f5b06f80          CMP      r0,#0x400
00001e  d029              BEQ      |L22.116|
000020  f5b06f00          CMP      r0,#0x800
000024  d154              BNE      |L22.208|
000026  e02e              B        |L22.134|
                  |L22.40|
000028  f5b06f80          CMP      r0,#0x400
00002c  d03d              BEQ      |L22.170|
00002e  f5b03f8e          CMP      r0,#0x11c00
000032  d003              BEQ      |L22.60|
000034  f5b03f92          CMP      r0,#0x12400
000038  d14a              BNE      |L22.208|
00003a  e03f              B        |L22.188|
                  |L22.60|
;;;194      {
;;;195        case TIM1_BASE:
;;;196          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
00003c  2101              MOVS     r1,#1
00003e  02c8              LSLS     r0,r1,#11
000040  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;197          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
000044  2100              MOVS     r1,#0
000046  f44f6000          MOV      r0,#0x800
00004a  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;198          break; 
00004e  e040              B        |L22.210|
                  |L22.80|
;;;199          
;;;200        case TIM2_BASE:
;;;201          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
000050  2101              MOVS     r1,#1
000052  4608              MOV      r0,r1
000054  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;202          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
000058  2100              MOVS     r1,#0
00005a  2001              MOVS     r0,#1
00005c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;203          break;
000060  e037              B        |L22.210|
                  |L22.98|
;;;204     
;;;205        case TIM3_BASE:
;;;206          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
000062  2101              MOVS     r1,#1
000064  2002              MOVS     r0,#2
000066  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;207          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
00006a  2100              MOVS     r1,#0
00006c  2002              MOVS     r0,#2
00006e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;208          break;
000072  e02e              B        |L22.210|
                  |L22.116|
;;;209     
;;;210        case TIM4_BASE:
;;;211          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
000074  2101              MOVS     r1,#1
000076  2004              MOVS     r0,#4
000078  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;212          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
00007c  2100              MOVS     r1,#0
00007e  2004              MOVS     r0,#4
000080  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;213          break;
000084  e025              B        |L22.210|
                  |L22.134|
;;;214          
;;;215        case TIM5_BASE:
;;;216          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
000086  2101              MOVS     r1,#1
000088  2008              MOVS     r0,#8
00008a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;217          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
00008e  2100              MOVS     r1,#0
000090  2008              MOVS     r0,#8
000092  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;218          break;
000096  e01c              B        |L22.210|
                  |L22.152|
;;;219          
;;;220        case TIM6_BASE:
;;;221          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
000098  2101              MOVS     r1,#1
00009a  2010              MOVS     r0,#0x10
00009c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;222          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
0000a0  2100              MOVS     r1,#0
0000a2  2010              MOVS     r0,#0x10
0000a4  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;223          break;
0000a8  e013              B        |L22.210|
                  |L22.170|
;;;224          
;;;225        case TIM7_BASE:
;;;226          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
0000aa  2101              MOVS     r1,#1
0000ac  2020              MOVS     r0,#0x20
0000ae  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;227          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
0000b2  2100              MOVS     r1,#0
0000b4  2020              MOVS     r0,#0x20
0000b6  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;228          break;
0000ba  e00a              B        |L22.210|
                  |L22.188|
;;;229          
;;;230        case TIM8_BASE:
;;;231          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
0000bc  2101              MOVS     r1,#1
0000be  0348              LSLS     r0,r1,#13
0000c0  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;232          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
0000c4  2100              MOVS     r1,#0
0000c6  f44f5000          MOV      r0,#0x2000
0000ca  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;233          break; 
0000ce  e000              B        |L22.210|
                  |L22.208|
;;;234          
;;;235        default:
;;;236          break;
0000d0  bf00              NOP      
                  |L22.210|
0000d2  bf00              NOP                            ;198
;;;237      }
;;;238    }
0000d4  bd10              POP      {r4,pc}
;;;239    
                          ENDP

0000d6  0000              DCW      0x0000
                  |L22.216|
                          DCD      0x40001000
                  |L22.220|
                          DCD      0xbffffc00

                          AREA ||i.TIM_ETRClockMode1Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode1Config PROC
;;;1068     */
;;;1069   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1070                                uint16_t ExtTRGFilter)
;;;1071   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1072     uint16_t tmpsmcr = 0;
00000c  2400              MOVS     r4,#0
;;;1073     /* Check the parameters */
;;;1074     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1075     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1076     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1077     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1078     /* Configure the ETR Clock source */
;;;1079     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
00000e  4643              MOV      r3,r8
000010  463a              MOV      r2,r7
000012  4631              MOV      r1,r6
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       TIM_ETRConfig
;;;1080     
;;;1081     /* Get the TIMx SMCR register value */
;;;1082     tmpsmcr = TIMx->SMCR;
00001a  892c              LDRH     r4,[r5,#8]
;;;1083     /* Reset the SMS Bits */
;;;1084     tmpsmcr &= SMCR_SMS_Mask;
00001c  f64f70f8          MOV      r0,#0xfff8
000020  4004              ANDS     r4,r4,r0
;;;1085     /* Select the External clock mode1 */
;;;1086     tmpsmcr |= TIM_SlaveMode_External1;
000022  f0440407          ORR      r4,r4,#7
;;;1087     /* Select the Trigger selection : ETRF */
;;;1088     tmpsmcr &= SMCR_TS_Mask;
000026  f64f708f          MOV      r0,#0xff8f
00002a  4004              ANDS     r4,r4,r0
;;;1089     tmpsmcr |= TIM_TS_ETRF;
00002c  f0440470          ORR      r4,r4,#0x70
;;;1090     /* Write to TIMx SMCR */
;;;1091     TIMx->SMCR = tmpsmcr;
000030  812c              STRH     r4,[r5,#8]
;;;1092   }
000032  e8bd81f0          POP      {r4-r8,pc}
;;;1093   
                          ENDP


                          AREA ||i.TIM_ETRClockMode2Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode2Config PROC
;;;1111     */
;;;1112   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
000000  b5f0              PUSH     {r4-r7,lr}
;;;1113                                uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;1114   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;1115     /* Check the parameters */
;;;1116     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1117     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1118     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1119     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1120     /* Configure the ETR Clock source */
;;;1121     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
00000a  463b              MOV      r3,r7
00000c  4632              MOV      r2,r6
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       TIM_ETRConfig
;;;1122     /* Enable the External clock mode2 */
;;;1123     TIMx->SMCR |= SMCR_ECE_Set;
000016  8920              LDRH     r0,[r4,#8]
000018  f4404080          ORR      r0,r0,#0x4000
00001c  8120              STRH     r0,[r4,#8]
;;;1124   }
00001e  bdf0              POP      {r4-r7,pc}
;;;1125   
                          ENDP


                          AREA ||i.TIM_ETRConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETRConfig PROC
;;;1143     */
;;;1144   void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
000000  b570              PUSH     {r4-r6,lr}
;;;1145                      uint16_t ExtTRGFilter)
;;;1146   {
000002  460c              MOV      r4,r1
;;;1147     uint16_t tmpsmcr = 0;
000004  2100              MOVS     r1,#0
;;;1148     /* Check the parameters */
;;;1149     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1150     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1151     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1152     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1153     tmpsmcr = TIMx->SMCR;
000006  8901              LDRH     r1,[r0,#8]
;;;1154     /* Reset the ETR Bits */
;;;1155     tmpsmcr &= SMCR_ETR_Mask;
000008  b2c9              UXTB     r1,r1
;;;1156     /* Set the Prescaler, the Filter value and the Polarity */
;;;1157     tmpsmcr |= TIM_ExtTRGPrescaler | TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << 8);
00000a  ea440502          ORR      r5,r4,r2
00000e  f64f76ff          MOV      r6,#0xffff
000012  ea062603          AND      r6,r6,r3,LSL #8
000016  4335              ORRS     r5,r5,r6
000018  4329              ORRS     r1,r1,r5
;;;1158     /* Write to TIMx SMCR */
;;;1159     TIMx->SMCR = tmpsmcr;
00001a  8101              STRH     r1,[r0,#8]
;;;1160   }
00001c  bd70              POP      {r4-r6,pc}
;;;1161   
                          ENDP


                          AREA ||i.TIM_EncoderInterfaceConfig||, CODE, READONLY, ALIGN=1

                  TIM_EncoderInterfaceConfig PROC
;;;1266     */
;;;1267   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1268                                   uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
;;;1269   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
000006  461e              MOV      r6,r3
;;;1270     uint16_t tmpsmcr = 0;
000008  2100              MOVS     r1,#0
;;;1271     uint16_t tmpccmr1 = 0;
00000a  2200              MOVS     r2,#0
;;;1272     uint16_t tmpccer = 0;
00000c  2300              MOVS     r3,#0
;;;1273       
;;;1274     /* Check the parameters */
;;;1275     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1276     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;1277     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;1278     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;1279     /* Get the TIMx SMCR register value */
;;;1280     tmpsmcr = TIMx->SMCR;
00000e  8901              LDRH     r1,[r0,#8]
;;;1281     /* Get the TIMx CCMR1 register value */
;;;1282     tmpccmr1 = TIMx->CCMR1;
000010  8b02              LDRH     r2,[r0,#0x18]
;;;1283     /* Get the TIMx CCER register value */
;;;1284     tmpccer = TIMx->CCER;
000012  8c03              LDRH     r3,[r0,#0x20]
;;;1285     /* Set the encoder Mode */
;;;1286     tmpsmcr &= SMCR_SMS_Mask;
000014  f64f77f8          MOV      r7,#0xfff8
000018  4039              ANDS     r1,r1,r7
;;;1287     tmpsmcr |= TIM_EncoderMode;
00001a  4321              ORRS     r1,r1,r4
;;;1288     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;1289     tmpccmr1 &= CCMR_CC13S_Mask & CCMR_CC24S_Mask;
00001c  f64f47fc          MOV      r7,#0xfcfc
000020  403a              ANDS     r2,r2,r7
;;;1290     tmpccmr1 |= CCMR_TI13Direct_Set | CCMR_TI24Direct_Set;
000022  f2401701          MOV      r7,#0x101
000026  433a              ORRS     r2,r2,r7
;;;1291     /* Set the TI1 and the TI2 Polarities */
;;;1292     tmpccer &= CCER_CC1P_Reset & CCER_CC2P_Reset;
000028  f64f77dd          MOV      r7,#0xffdd
00002c  403b              ANDS     r3,r3,r7
;;;1293     tmpccer |= (TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << 4));
00002e  f64f77ff          MOV      r7,#0xffff
000032  ea071706          AND      r7,r7,r6,LSL #4
000036  432f              ORRS     r7,r7,r5
000038  433b              ORRS     r3,r3,r7
;;;1294     /* Write to TIMx SMCR */
;;;1295     TIMx->SMCR = tmpsmcr;
00003a  8101              STRH     r1,[r0,#8]
;;;1296     /* Write to TIMx CCMR1 */
;;;1297     TIMx->CCMR1 = tmpccmr1;
00003c  8302              STRH     r2,[r0,#0x18]
;;;1298     /* Write to TIMx CCER */
;;;1299     TIMx->CCER = tmpccer;
00003e  8403              STRH     r3,[r0,#0x20]
;;;1300   }
000040  bdf0              POP      {r4-r7,pc}
;;;1301   
                          ENDP


                          AREA ||i.TIM_ForcedOC1Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC1Config PROC
;;;1313     */
;;;1314   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1315   {
;;;1316     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1317     /* Check the parameters */
;;;1318     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1319     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1320     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1321     /* Reset the OC1M Bits */
;;;1322     tmpccmr1 &= CCMR_OC13M_Mask;
000006  f64f738f          MOV      r3,#0xff8f
00000a  4019              ANDS     r1,r1,r3
;;;1323     /* Configure The Forced output Mode */
;;;1324     tmpccmr1 |= TIM_ForcedAction;
00000c  4311              ORRS     r1,r1,r2
;;;1325     /* Write to TIMx CCMR1 register */
;;;1326     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1327   }
000010  4770              BX       lr
;;;1328   
                          ENDP


                          AREA ||i.TIM_ForcedOC2Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC2Config PROC
;;;1340     */
;;;1341   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1342   {
;;;1343     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1344     /* Check the parameters */
;;;1345     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1346     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1347     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1348     /* Reset the OC2M Bits */
;;;1349     tmpccmr1 &= CCMR_OC24M_Mask;
000006  f64873ff          MOV      r3,#0x8fff
00000a  4019              ANDS     r1,r1,r3
;;;1350     /* Configure The Forced output Mode */
;;;1351     tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1352     /* Write to TIMx CCMR1 register */
;;;1353     TIMx->CCMR1 = tmpccmr1;
000016  8301              STRH     r1,[r0,#0x18]
;;;1354   }
000018  4770              BX       lr
;;;1355   
                          ENDP


                          AREA ||i.TIM_ForcedOC3Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC3Config PROC
;;;1367     */
;;;1368   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1369   {
;;;1370     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1371     /* Check the parameters */
;;;1372     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1373     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1374     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1375     /* Reset the OC1M Bits */
;;;1376     tmpccmr2 &= CCMR_OC13M_Mask;
000006  f64f738f          MOV      r3,#0xff8f
00000a  4019              ANDS     r1,r1,r3
;;;1377     /* Configure The Forced output Mode */
;;;1378     tmpccmr2 |= TIM_ForcedAction;
00000c  4311              ORRS     r1,r1,r2
;;;1379     /* Write to TIMx CCMR2 register */
;;;1380     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1381   }
000010  4770              BX       lr
;;;1382   
                          ENDP


                          AREA ||i.TIM_ForcedOC4Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC4Config PROC
;;;1394     */
;;;1395   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1396   {
;;;1397     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1398     /* Check the parameters */
;;;1399     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1400     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1401     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1402     /* Reset the OC2M Bits */
;;;1403     tmpccmr2 &= CCMR_OC24M_Mask;
000006  f64873ff          MOV      r3,#0x8fff
00000a  4019              ANDS     r1,r1,r3
;;;1404     /* Configure The Forced output Mode */
;;;1405     tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1406     /* Write to TIMx CCMR2 register */
;;;1407     TIMx->CCMR2 = tmpccmr2;
000016  8381              STRH     r1,[r0,#0x1c]
;;;1408   }
000018  4770              BX       lr
;;;1409   
                          ENDP


                          AREA ||i.TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  TIM_GenerateEvent PROC
;;;899      */
;;;900    void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
000000  8281              STRH     r1,[r0,#0x14]
;;;901    { 
;;;902      /* Check the parameters */
;;;903      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;904      assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
;;;905      assert_param(IS_TIM_PERIPH_EVENT((TIMx), (TIM_EventSource)));
;;;906      /* Set the event sources */
;;;907      TIMx->EGR = TIM_EventSource;
;;;908    }
000002  4770              BX       lr
;;;909    
                          ENDP


                          AREA ||i.TIM_GetCapture1||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture1 PROC
;;;2468     */
;;;2469   uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2470   {
;;;2471     /* Check the parameters */
;;;2472     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2473     /* Get the Capture 1 Register value */
;;;2474     return TIMx->CCR1;
000002  8e88              LDRH     r0,[r1,#0x34]
;;;2475   }
000004  4770              BX       lr
;;;2476   
                          ENDP


                          AREA ||i.TIM_GetCapture2||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture2 PROC
;;;2482     */
;;;2483   uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2484   {
;;;2485     /* Check the parameters */
;;;2486     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2487     /* Get the Capture 2 Register value */
;;;2488     return TIMx->CCR2;
000002  8f08              LDRH     r0,[r1,#0x38]
;;;2489   }
000004  4770              BX       lr
;;;2490   
                          ENDP


                          AREA ||i.TIM_GetCapture3||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture3 PROC
;;;2496     */
;;;2497   uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2498   {
;;;2499     /* Check the parameters */
;;;2500     assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;2501     /* Get the Capture 3 Register value */
;;;2502     return TIMx->CCR3;
000002  8f88              LDRH     r0,[r1,#0x3c]
;;;2503   }
000004  4770              BX       lr
;;;2504   
                          ENDP


                          AREA ||i.TIM_GetCapture4||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture4 PROC
;;;2510     */
;;;2511   uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2512   {
;;;2513     /* Check the parameters */
;;;2514     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2515     /* Get the Capture 4 Register value */
;;;2516     return TIMx->CCR4;
000002  f8b10040          LDRH     r0,[r1,#0x40]
;;;2517   }
000006  4770              BX       lr
;;;2518   
                          ENDP


                          AREA ||i.TIM_GetCounter||, CODE, READONLY, ALIGN=1

                  TIM_GetCounter PROC
;;;2523     */
;;;2524   uint16_t TIM_GetCounter(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2525   {
;;;2526     /* Check the parameters */
;;;2527     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2528     /* Get the Counter Register value */
;;;2529     return TIMx->CNT;
000002  8c88              LDRH     r0,[r1,#0x24]
;;;2530   }
000004  4770              BX       lr
;;;2531   
                          ENDP


                          AREA ||i.TIM_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetFlagStatus PROC
;;;2563     */
;;;2564   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  4602              MOV      r2,r0
;;;2565   { 
;;;2566     ITStatus bitstatus = RESET;  
000002  2000              MOVS     r0,#0
;;;2567     /* Check the parameters */
;;;2568     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2569     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;2570     assert_param(IS_TIM_PERIPH_FLAG(TIMx, TIM_FLAG));
;;;2571     
;;;2572     if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
000004  8a13              LDRH     r3,[r2,#0x10]
000006  400b              ANDS     r3,r3,r1
000008  b10b              CBZ      r3,|L37.14|
;;;2573     {
;;;2574       bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L37.16|
                  |L37.14|
;;;2575     }
;;;2576     else
;;;2577     {
;;;2578       bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L37.16|
;;;2579     }
;;;2580     return bitstatus;
;;;2581   }
000010  4770              BX       lr
;;;2582   
                          ENDP


                          AREA ||i.TIM_GetITStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetITStatus PROC
;;;2627     */
;;;2628   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;2629   {
000002  4602              MOV      r2,r0
;;;2630     ITStatus bitstatus = RESET;  
000004  2000              MOVS     r0,#0
;;;2631     uint16_t itstatus = 0x0, itenable = 0x0;
000006  2300              MOVS     r3,#0
000008  2400              MOVS     r4,#0
;;;2632     /* Check the parameters */
;;;2633     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2634     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2635     assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
;;;2636      
;;;2637     itstatus = TIMx->SR & TIM_IT;
00000a  8a15              LDRH     r5,[r2,#0x10]
00000c  ea050301          AND      r3,r5,r1
;;;2638     
;;;2639     itenable = TIMx->DIER & TIM_IT;
000010  8995              LDRH     r5,[r2,#0xc]
000012  ea050401          AND      r4,r5,r1
;;;2640     if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
000016  b113              CBZ      r3,|L38.30|
000018  b10c              CBZ      r4,|L38.30|
;;;2641     {
;;;2642       bitstatus = SET;
00001a  2001              MOVS     r0,#1
00001c  e000              B        |L38.32|
                  |L38.30|
;;;2643     }
;;;2644     else
;;;2645     {
;;;2646       bitstatus = RESET;
00001e  2000              MOVS     r0,#0
                  |L38.32|
;;;2647     }
;;;2648     return bitstatus;
;;;2649   }
000020  bd30              POP      {r4,r5,pc}
;;;2650   
                          ENDP


                          AREA ||i.TIM_GetPrescaler||, CODE, READONLY, ALIGN=1

                  TIM_GetPrescaler PROC
;;;2536     */
;;;2537   uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;2538   {
;;;2539     /* Check the parameters */
;;;2540     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2541     /* Get the Prescaler Register value */
;;;2542     return TIMx->PSC;
000002  8d08              LDRH     r0,[r1,#0x28]
;;;2543   }
000004  4770              BX       lr
;;;2544   
                          ENDP


                          AREA ||i.TIM_ICInit||, CODE, READONLY, ALIGN=1

                  TIM_ICInit PROC
;;;594      */
;;;595    void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;596    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;597      /* Check the parameters */
;;;598      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;599      assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));
;;;600      assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;601      assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;602      assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;603      assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;604      
;;;605      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000006  8820              LDRH     r0,[r4,#0]
000008  b950              CBNZ     r0,|L40.32|
;;;606      {
;;;607        /* TI1 Configuration */
;;;608        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
00000a  8923              LDRH     r3,[r4,#8]
00000c  88a2              LDRH     r2,[r4,#4]
00000e  8861              LDRH     r1,[r4,#2]
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       TI1_Config
;;;609                   TIM_ICInitStruct->TIM_ICSelection,
;;;610                   TIM_ICInitStruct->TIM_ICFilter);
;;;611        /* Set the Input Capture Prescaler value */
;;;612        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000016  88e1              LDRH     r1,[r4,#6]
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       TIM_SetIC1Prescaler
00001e  e025              B        |L40.108|
                  |L40.32|
;;;613      }
;;;614      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
000020  8820              LDRH     r0,[r4,#0]
000022  2804              CMP      r0,#4
000024  d10a              BNE      |L40.60|
;;;615      {
;;;616        /* TI2 Configuration */
;;;617        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000026  8923              LDRH     r3,[r4,#8]
000028  88a2              LDRH     r2,[r4,#4]
00002a  8861              LDRH     r1,[r4,#2]
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       TI2_Config
;;;618                   TIM_ICInitStruct->TIM_ICSelection,
;;;619                   TIM_ICInitStruct->TIM_ICFilter);
;;;620        /* Set the Input Capture Prescaler value */
;;;621        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000032  88e1              LDRH     r1,[r4,#6]
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       TIM_SetIC2Prescaler
00003a  e017              B        |L40.108|
                  |L40.60|
;;;622      }
;;;623      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
00003c  8820              LDRH     r0,[r4,#0]
00003e  2808              CMP      r0,#8
000040  d10a              BNE      |L40.88|
;;;624      {
;;;625        /* TI3 Configuration */
;;;626        TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
000042  8923              LDRH     r3,[r4,#8]
000044  88a2              LDRH     r2,[r4,#4]
000046  8861              LDRH     r1,[r4,#2]
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       TI3_Config
;;;627                   TIM_ICInitStruct->TIM_ICSelection,
;;;628                   TIM_ICInitStruct->TIM_ICFilter);
;;;629        /* Set the Input Capture Prescaler value */
;;;630        TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00004e  88e1              LDRH     r1,[r4,#6]
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       TIM_SetIC3Prescaler
000056  e009              B        |L40.108|
                  |L40.88|
;;;631      }
;;;632      else
;;;633      {
;;;634        /* TI4 Configuration */
;;;635        TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000058  8923              LDRH     r3,[r4,#8]
00005a  88a2              LDRH     r2,[r4,#4]
00005c  8861              LDRH     r1,[r4,#2]
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       TI4_Config
;;;636                   TIM_ICInitStruct->TIM_ICSelection,
;;;637                   TIM_ICInitStruct->TIM_ICFilter);
;;;638        /* Set the Input Capture Prescaler value */
;;;639        TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000064  88e1              LDRH     r1,[r4,#6]
000066  4628              MOV      r0,r5
000068  f7fffffe          BL       TIM_SetIC4Prescaler
                  |L40.108|
;;;640      }
;;;641    }
00006c  bd70              POP      {r4-r6,pc}
;;;642    
                          ENDP


                          AREA ||i.TIM_ICStructInit||, CODE, READONLY, ALIGN=1

                  TIM_ICStructInit PROC
;;;771      */
;;;772    void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  2100              MOVS     r1,#0
;;;773    {
;;;774      /* Set the default configuration */
;;;775      TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
000002  8001              STRH     r1,[r0,#0]
;;;776      TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
000004  8041              STRH     r1,[r0,#2]
;;;777      TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
000006  2101              MOVS     r1,#1
000008  8081              STRH     r1,[r0,#4]
;;;778      TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
00000a  2100              MOVS     r1,#0
00000c  80c1              STRH     r1,[r0,#6]
;;;779      TIM_ICInitStruct->TIM_ICFilter = 0x00;
00000e  8101              STRH     r1,[r0,#8]
;;;780    }
000010  4770              BX       lr
;;;781    
                          ENDP


                          AREA ||i.TIM_ITConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITConfig PROC
;;;866      */
;;;867    void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L42.10|
;;;868    {  
;;;869      /* Check the parameters */
;;;870      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;871      assert_param(IS_TIM_IT(TIM_IT));
;;;872      assert_param(IS_TIM_PERIPH_IT((TIMx), (TIM_IT)));
;;;873      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;874      
;;;875      if (NewState != DISABLE)
;;;876      {
;;;877        /* Enable the Interrupt sources */
;;;878        TIMx->DIER |= TIM_IT;
000002  8983              LDRH     r3,[r0,#0xc]
000004  430b              ORRS     r3,r3,r1
000006  8183              STRH     r3,[r0,#0xc]
000008  e002              B        |L42.16|
                  |L42.10|
;;;879      }
;;;880      else
;;;881      {
;;;882        /* Disable the Interrupt sources */
;;;883        TIMx->DIER &= (uint16_t)~TIM_IT;
00000a  8983              LDRH     r3,[r0,#0xc]
00000c  438b              BICS     r3,r3,r1
00000e  8183              STRH     r3,[r0,#0xc]
                  |L42.16|
;;;884      }
;;;885    }
000010  4770              BX       lr
;;;886    
                          ENDP


                          AREA ||i.TIM_ITRxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRxExternalClockConfig PROC
;;;999      */
;;;1000   void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  b530              PUSH     {r4,r5,lr}
;;;1001   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1002     /* Check the parameters */
;;;1003     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1004     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1005     /* Select the Internal Trigger */
;;;1006     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       TIM_SelectInputTrigger
;;;1007     /* Select the External clock mode1 */
;;;1008     TIMx->SMCR |= TIM_SlaveMode_External1;
00000e  8920              LDRH     r0,[r4,#8]
000010  f0400007          ORR      r0,r0,#7
000014  8120              STRH     r0,[r4,#8]
;;;1009   }
000016  bd30              POP      {r4,r5,pc}
;;;1010   
                          ENDP


                          AREA ||i.TIM_InternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_InternalClockConfig PROC
;;;979      */
;;;980    void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
000000  8901              LDRH     r1,[r0,#8]
;;;981    {
;;;982      /* Check the parameters */
;;;983      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;984      /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;985      TIMx->SMCR &=  SMCR_SMS_Mask;
000002  f64f72f8          MOV      r2,#0xfff8
000006  4011              ANDS     r1,r1,r2
000008  8101              STRH     r1,[r0,#8]
;;;986    }
00000a  4770              BX       lr
;;;987    
                          ENDP


                          AREA ||i.TIM_OC1FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1FastConfig PROC
;;;1622     */
;;;1623   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1624   {
;;;1625     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1626     /* Check the parameters */
;;;1627     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1628     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1629     /* Get the TIMx CCMR1 register value */
;;;1630     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1631     /* Reset the OC1FE Bit */
;;;1632     tmpccmr1 &= CCMR_OC13FE_Reset;
000006  f64f73fb          MOV      r3,#0xfffb
00000a  4019              ANDS     r1,r1,r3
;;;1633     /* Enable or Disable the Output Compare Fast Bit */
;;;1634     tmpccmr1 |= TIM_OCFast;
00000c  4311              ORRS     r1,r1,r2
;;;1635     /* Write to TIMx CCMR1 */
;;;1636     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1637   }
000010  4770              BX       lr
;;;1638   
                          ENDP


                          AREA ||i.TIM_OC1Init||, CODE, READONLY, ALIGN=2

                  TIM_OC1Init PROC
;;;286      */
;;;287    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;288    {
;;;289      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;290       
;;;291      /* Check the parameters */
;;;292      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;293      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;294      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;295      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;296      /* Disable the Channel 1: Reset the CC1E Bit */
;;;297      TIMx->CCER &= CCER_CC1E_Reset;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64f76fe          MOV      r6,#0xfffe
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;298      
;;;299      /* Get the TIMx CCER register value */
;;;300      tmpccer = TIMx->CCER;
000012  8c02              LDRH     r2,[r0,#0x20]
;;;301      /* Get the TIMx CR2 register value */
;;;302      tmpcr2 =  TIMx->CR2;
000014  8883              LDRH     r3,[r0,#4]
;;;303      
;;;304      /* Get the TIMx CCMR1 register value */
;;;305      tmpccmrx = TIMx->CCMR1;
000016  8b04              LDRH     r4,[r0,#0x18]
;;;306        
;;;307      /* Reset the Output Compare Mode Bits */
;;;308      tmpccmrx &= CCMR_OC13M_Mask;
000018  f64f758f          MOV      r5,#0xff8f
00001c  402c              ANDS     r4,r4,r5
;;;309      
;;;310      /* Select the Output Compare Mode */
;;;311      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
00001e  880d              LDRH     r5,[r1,#0]
000020  432c              ORRS     r4,r4,r5
;;;312      
;;;313      /* Reset the Output Polarity level */
;;;314      tmpccer &= CCER_CC1P_Reset;
000022  1e75              SUBS     r5,r6,#1
000024  402a              ANDS     r2,r2,r5
;;;315      /* Set the Output Compare Polarity */
;;;316      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
000026  890d              LDRH     r5,[r1,#8]
000028  432a              ORRS     r2,r2,r5
;;;317      
;;;318      /* Set the Output State */
;;;319      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
00002a  884d              LDRH     r5,[r1,#2]
00002c  432a              ORRS     r2,r2,r5
;;;320      
;;;321      /* Set the Capture Compare Register value */
;;;322      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
00002e  88cd              LDRH     r5,[r1,#6]
000030  8685              STRH     r5,[r0,#0x34]
;;;323      
;;;324      if((*(uint32_t*)&TIMx == TIM1_BASE) || (*(uint32_t*)&TIMx == TIM8_BASE))
000032  4d0f              LDR      r5,|L46.112|
000034  42a8              CMP      r0,r5
000036  d002              BEQ      |L46.62|
000038  4d0e              LDR      r5,|L46.116|
00003a  42a8              CMP      r0,r5
00003c  d113              BNE      |L46.102|
                  |L46.62|
;;;325      {
;;;326        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;327        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;328        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;329        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;330        
;;;331        /* Reset the Output N Polarity level */
;;;332        tmpccer &= CCER_CC1NP_Reset;
00003e  f64f75f7          MOV      r5,#0xfff7
000042  402a              ANDS     r2,r2,r5
;;;333        /* Set the Output N Polarity */
;;;334        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
000044  894d              LDRH     r5,[r1,#0xa]
000046  432a              ORRS     r2,r2,r5
;;;335        /* Reset the Output N State */
;;;336        tmpccer &= CCER_CC1NE_Reset;
000048  f64f75fb          MOV      r5,#0xfffb
00004c  402a              ANDS     r2,r2,r5
;;;337        
;;;338        /* Set the Output N State */
;;;339        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
00004e  888d              LDRH     r5,[r1,#4]
000050  432a              ORRS     r2,r2,r5
;;;340        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;341        tmpcr2 &= CR2_OIS1_Reset;
000052  f64765ff          MOV      r5,#0x7eff
000056  402b              ANDS     r3,r3,r5
;;;342        tmpcr2 &= CR2_OIS1N_Reset;
000058  f64755ff          MOV      r5,#0x7dff
00005c  402b              ANDS     r3,r3,r5
;;;343        /* Set the Output Idle state */
;;;344        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
00005e  898d              LDRH     r5,[r1,#0xc]
000060  432b              ORRS     r3,r3,r5
;;;345        /* Set the Output N Idle state */
;;;346        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
000062  89cd              LDRH     r5,[r1,#0xe]
000064  432b              ORRS     r3,r3,r5
                  |L46.102|
;;;347      }
;;;348      /* Write to TIMx CR2 */
;;;349      TIMx->CR2 = tmpcr2;
000066  8083              STRH     r3,[r0,#4]
;;;350      
;;;351      /* Write to TIMx CCMR1 */
;;;352      TIMx->CCMR1 = tmpccmrx;
000068  8304              STRH     r4,[r0,#0x18]
;;;353      
;;;354      /* Write to TIMx CCER */
;;;355      TIMx->CCER = tmpccer;
00006a  8402              STRH     r2,[r0,#0x20]
;;;356    }
00006c  bd70              POP      {r4-r6,pc}
;;;357    
                          ENDP

00006e  0000              DCW      0x0000
                  |L46.112|
                          DCD      0x40012c00
                  |L46.116|
                          DCD      0x40013400

                          AREA ||i.TIM_OC1NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1NPolarityConfig PROC
;;;1849     */
;;;1850   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;1851   {
;;;1852     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1853     /* Check the parameters */
;;;1854     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1855     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1856      
;;;1857     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1858     /* Set or Reset the CC1NP Bit */
;;;1859     tmpccer &= CCER_CC1NP_Reset;
000006  f64f73f7          MOV      r3,#0xfff7
00000a  4019              ANDS     r1,r1,r3
;;;1860     tmpccer |= TIM_OCNPolarity;
00000c  4311              ORRS     r1,r1,r2
;;;1861     /* Write to TIMx CCER register */
;;;1862     TIMx->CCER = tmpccer;
00000e  8401              STRH     r1,[r0,#0x20]
;;;1863   }
000010  4770              BX       lr
;;;1864   
                          ENDP


                          AREA ||i.TIM_OC1PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PolarityConfig PROC
;;;1826     */
;;;1827   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1828   {
;;;1829     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1830     /* Check the parameters */
;;;1831     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1832     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1833     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1834     /* Set or Reset the CC1P Bit */
;;;1835     tmpccer &= CCER_CC1P_Reset;
000006  f64f73fd          MOV      r3,#0xfffd
00000a  4019              ANDS     r1,r1,r3
;;;1836     tmpccer |= TIM_OCPolarity;
00000c  4311              ORRS     r1,r1,r2
;;;1837     /* Write to TIMx CCER register */
;;;1838     TIMx->CCER = tmpccer;
00000e  8401              STRH     r1,[r0,#0x20]
;;;1839   }
000010  4770              BX       lr
;;;1840   
                          ENDP


                          AREA ||i.TIM_OC1PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PreloadConfig PROC
;;;1519     */
;;;1520   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1521   {
;;;1522     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1523     /* Check the parameters */
;;;1524     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1525     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1526     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1527     /* Reset the OC1PE Bit */
;;;1528     tmpccmr1 &= CCMR_OC13PE_Reset;
000006  f64f73f7          MOV      r3,#0xfff7
00000a  4019              ANDS     r1,r1,r3
;;;1529     /* Enable or Disable the Output Compare Preload feature */
;;;1530     tmpccmr1 |= TIM_OCPreload;
00000c  4311              ORRS     r1,r1,r2
;;;1531     /* Write to TIMx CCMR1 register */
;;;1532     TIMx->CCMR1 = tmpccmr1;
00000e  8301              STRH     r1,[r0,#0x18]
;;;1533   }
000010  4770              BX       lr
;;;1534   
                          ENDP


                          AREA ||i.TIM_OC2FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2FastConfig PROC
;;;1648     */
;;;1649   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1650   {
;;;1651     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1652     /* Check the parameters */
;;;1653     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1654     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1655     /* Get the TIMx CCMR1 register value */
;;;1656     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1657     /* Reset the OC2FE Bit */
;;;1658     tmpccmr1 &= CCMR_OC24FE_Reset;
000006  f64f33ff          MOV      r3,#0xfbff
00000a  4019              ANDS     r1,r1,r3
;;;1659     /* Enable or Disable the Output Compare Fast Bit */
;;;1660     tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1661     /* Write to TIMx CCMR1 */
;;;1662     TIMx->CCMR1 = tmpccmr1;
000016  8301              STRH     r1,[r0,#0x18]
;;;1663   }
000018  4770              BX       lr
;;;1664   
                          ENDP


                          AREA ||i.TIM_OC2Init||, CODE, READONLY, ALIGN=2

                  TIM_OC2Init PROC
;;;367      */
;;;368    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;369    {
;;;370      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;371       
;;;372      /* Check the parameters */
;;;373      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;374      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;375      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;376      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;377      /* Disable the Channel 2: Reset the CC2E Bit */
;;;378      TIMx->CCER &= CCER_CC2E_Reset;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64f76ef          MOV      r6,#0xffef
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;379      
;;;380      /* Get the TIMx CCER register value */  
;;;381      tmpccer = TIMx->CCER;
000012  8c02              LDRH     r2,[r0,#0x20]
;;;382      /* Get the TIMx CR2 register value */
;;;383      tmpcr2 =  TIMx->CR2;
000014  8883              LDRH     r3,[r0,#4]
;;;384      
;;;385      /* Get the TIMx CCMR1 register value */
;;;386      tmpccmrx = TIMx->CCMR1;
000016  8b04              LDRH     r4,[r0,#0x18]
;;;387        
;;;388      /* Reset the Output Compare Mode Bits */
;;;389      tmpccmrx &= CCMR_OC24M_Mask;
000018  f64875ff          MOV      r5,#0x8fff
00001c  402c              ANDS     r4,r4,r5
;;;390      
;;;391      /* Select the Output Compare Mode */
;;;392      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
00001e  880d              LDRH     r5,[r1,#0]
000020  f64f76ff          MOV      r6,#0xffff
000024  ea062505          AND      r5,r6,r5,LSL #8
000028  432c              ORRS     r4,r4,r5
;;;393      
;;;394      /* Reset the Output Polarity level */
;;;395      tmpccer &= CCER_CC2P_Reset;
00002a  f64f75df          MOV      r5,#0xffdf
00002e  402a              ANDS     r2,r2,r5
;;;396      /* Set the Output Compare Polarity */
;;;397      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
000030  890d              LDRH     r5,[r1,#8]
000032  ea061505          AND      r5,r6,r5,LSL #4
000036  432a              ORRS     r2,r2,r5
;;;398      
;;;399      /* Set the Output State */
;;;400      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
000038  884d              LDRH     r5,[r1,#2]
00003a  ea061505          AND      r5,r6,r5,LSL #4
00003e  432a              ORRS     r2,r2,r5
;;;401      
;;;402      /* Set the Capture Compare Register value */
;;;403      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
000040  88cd              LDRH     r5,[r1,#6]
000042  8705              STRH     r5,[r0,#0x38]
;;;404      
;;;405      if((*(uint32_t*)&TIMx == TIM1_BASE) || (*(uint32_t*)&TIMx == TIM8_BASE))
000044  4d13              LDR      r5,|L51.148|
000046  42a8              CMP      r0,r5
000048  d002              BEQ      |L51.80|
00004a  4d13              LDR      r5,|L51.152|
00004c  42a8              CMP      r0,r5
00004e  d11d              BNE      |L51.140|
                  |L51.80|
;;;406      {
;;;407        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;408        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;409        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;410        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;411        
;;;412        /* Reset the Output N Polarity level */
;;;413        tmpccer &= CCER_CC2NP_Reset;
000050  f64f757f          MOV      r5,#0xff7f
000054  402a              ANDS     r2,r2,r5
;;;414        /* Set the Output N Polarity */
;;;415        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
000056  894d              LDRH     r5,[r1,#0xa]
000058  f64f76ff          MOV      r6,#0xffff
00005c  ea061505          AND      r5,r6,r5,LSL #4
000060  432a              ORRS     r2,r2,r5
;;;416        /* Reset the Output N State */
;;;417        tmpccer &= CCER_CC2NE_Reset;
000062  f64f75bf          MOV      r5,#0xffbf
000066  402a              ANDS     r2,r2,r5
;;;418        
;;;419        /* Set the Output N State */
;;;420        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
000068  888d              LDRH     r5,[r1,#4]
00006a  ea061505          AND      r5,r6,r5,LSL #4
00006e  432a              ORRS     r2,r2,r5
;;;421        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;422        tmpcr2 &= CR2_OIS2_Reset;
000070  f64735ff          MOV      r5,#0x7bff
000074  402b              ANDS     r3,r3,r5
;;;423        tmpcr2 &= CR2_OIS2N_Reset;
000076  f24775ff          MOV      r5,#0x77ff
00007a  402b              ANDS     r3,r3,r5
;;;424        /* Set the Output Idle state */
;;;425        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
00007c  898d              LDRH     r5,[r1,#0xc]
00007e  ea060585          AND      r5,r6,r5,LSL #2
000082  432b              ORRS     r3,r3,r5
;;;426        /* Set the Output N Idle state */
;;;427        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
000084  89cd              LDRH     r5,[r1,#0xe]
000086  ea060585          AND      r5,r6,r5,LSL #2
00008a  432b              ORRS     r3,r3,r5
                  |L51.140|
;;;428      }
;;;429      /* Write to TIMx CR2 */
;;;430      TIMx->CR2 = tmpcr2;
00008c  8083              STRH     r3,[r0,#4]
;;;431      
;;;432      /* Write to TIMx CCMR1 */
;;;433      TIMx->CCMR1 = tmpccmrx;
00008e  8304              STRH     r4,[r0,#0x18]
;;;434      
;;;435      /* Write to TIMx CCER */
;;;436      TIMx->CCER = tmpccer;
000090  8402              STRH     r2,[r0,#0x20]
;;;437    }
000092  bd70              POP      {r4-r6,pc}
;;;438    
                          ENDP

                  |L51.148|
                          DCD      0x40012c00
                  |L51.152|
                          DCD      0x40013400

                          AREA ||i.TIM_OC2NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2NPolarityConfig PROC
;;;1897     */
;;;1898   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;1899   {
;;;1900     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1901     /* Check the parameters */
;;;1902     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1903     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1904     
;;;1905     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1906     /* Set or Reset the CC2NP Bit */
;;;1907     tmpccer &= CCER_CC2NP_Reset;
000006  f64f737f          MOV      r3,#0xff7f
00000a  4019              ANDS     r1,r1,r3
;;;1908     tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea031302          AND      r3,r3,r2,LSL #4
000014  4319              ORRS     r1,r1,r3
;;;1909     /* Write to TIMx CCER register */
;;;1910     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;1911   }
000018  4770              BX       lr
;;;1912   
                          ENDP


                          AREA ||i.TIM_OC2PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PolarityConfig PROC
;;;1874     */
;;;1875   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1876   {
;;;1877     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1878     /* Check the parameters */
;;;1879     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1880     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1881     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1882     /* Set or Reset the CC2P Bit */
;;;1883     tmpccer &= CCER_CC2P_Reset;
000006  f64f73df          MOV      r3,#0xffdf
00000a  4019              ANDS     r1,r1,r3
;;;1884     tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea031302          AND      r3,r3,r2,LSL #4
000014  4319              ORRS     r1,r1,r3
;;;1885     /* Write to TIMx CCER register */
;;;1886     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;1887   }
000018  4770              BX       lr
;;;1888   
                          ENDP


                          AREA ||i.TIM_OC2PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PreloadConfig PROC
;;;1545     */
;;;1546   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1547   {
;;;1548     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1549     /* Check the parameters */
;;;1550     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1551     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1552     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1553     /* Reset the OC2PE Bit */
;;;1554     tmpccmr1 &= CCMR_OC24PE_Reset;
000006  f24f73ff          MOV      r3,#0xf7ff
00000a  4019              ANDS     r1,r1,r3
;;;1555     /* Enable or Disable the Output Compare Preload feature */
;;;1556     tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1557     /* Write to TIMx CCMR1 register */
;;;1558     TIMx->CCMR1 = tmpccmr1;
000016  8301              STRH     r1,[r0,#0x18]
;;;1559   }
000018  4770              BX       lr
;;;1560   
                          ENDP


                          AREA ||i.TIM_OC3FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3FastConfig PROC
;;;1674     */
;;;1675   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1676   {
;;;1677     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1678     /* Check the parameters */
;;;1679     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1680     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1681     /* Get the TIMx CCMR2 register value */
;;;1682     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1683     /* Reset the OC3FE Bit */
;;;1684     tmpccmr2 &= CCMR_OC13FE_Reset;
000006  f64f73fb          MOV      r3,#0xfffb
00000a  4019              ANDS     r1,r1,r3
;;;1685     /* Enable or Disable the Output Compare Fast Bit */
;;;1686     tmpccmr2 |= TIM_OCFast;
00000c  4311              ORRS     r1,r1,r2
;;;1687     /* Write to TIMx CCMR2 */
;;;1688     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1689   }
000010  4770              BX       lr
;;;1690   
                          ENDP


                          AREA ||i.TIM_OC3Init||, CODE, READONLY, ALIGN=2

                  TIM_OC3Init PROC
;;;448      */
;;;449    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;450    {
;;;451      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;452       
;;;453      /* Check the parameters */
;;;454      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;455      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;456      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;457      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;458      /* Disable the Channel 2: Reset the CC2E Bit */
;;;459      TIMx->CCER &= CCER_CC3E_Reset;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64f66ff          MOV      r6,#0xfeff
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;460      
;;;461      /* Get the TIMx CCER register value */
;;;462      tmpccer = TIMx->CCER;
000012  8c02              LDRH     r2,[r0,#0x20]
;;;463      /* Get the TIMx CR2 register value */
;;;464      tmpcr2 =  TIMx->CR2;
000014  8883              LDRH     r3,[r0,#4]
;;;465      
;;;466      /* Get the TIMx CCMR2 register value */
;;;467      tmpccmrx = TIMx->CCMR2;
000016  8b84              LDRH     r4,[r0,#0x1c]
;;;468        
;;;469      /* Reset the Output Compare Mode Bits */
;;;470      tmpccmrx &= CCMR_OC13M_Mask;
000018  f64f758f          MOV      r5,#0xff8f
00001c  402c              ANDS     r4,r4,r5
;;;471      
;;;472      /* Select the Output Compare Mode */
;;;473      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
00001e  880d              LDRH     r5,[r1,#0]
000020  432c              ORRS     r4,r4,r5
;;;474      
;;;475      /* Reset the Output Polarity level */
;;;476      tmpccer &= CCER_CC3P_Reset;
000022  f64f55ff          MOV      r5,#0xfdff
000026  402a              ANDS     r2,r2,r5
;;;477      /* Set the Output Compare Polarity */
;;;478      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
000028  890d              LDRH     r5,[r1,#8]
00002a  f64f76ff          MOV      r6,#0xffff
00002e  ea062505          AND      r5,r6,r5,LSL #8
000032  432a              ORRS     r2,r2,r5
;;;479      
;;;480      /* Set the Output State */
;;;481      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
000034  884d              LDRH     r5,[r1,#2]
000036  ea062505          AND      r5,r6,r5,LSL #8
00003a  432a              ORRS     r2,r2,r5
;;;482      
;;;483      /* Set the Capture Compare Register value */
;;;484      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
00003c  88cd              LDRH     r5,[r1,#6]
00003e  8785              STRH     r5,[r0,#0x3c]
;;;485      
;;;486      if((*(uint32_t*)&TIMx == TIM1_BASE) || (*(uint32_t*)&TIMx == TIM8_BASE))
000040  4d13              LDR      r5,|L56.144|
000042  42a8              CMP      r0,r5
000044  d002              BEQ      |L56.76|
000046  4d13              LDR      r5,|L56.148|
000048  42a8              CMP      r0,r5
00004a  d11d              BNE      |L56.136|
                  |L56.76|
;;;487      {
;;;488        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;489        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;490        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;491        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;492        
;;;493        /* Reset the Output N Polarity level */
;;;494        tmpccer &= CCER_CC3NP_Reset;
00004c  f24f75ff          MOV      r5,#0xf7ff
000050  402a              ANDS     r2,r2,r5
;;;495        /* Set the Output N Polarity */
;;;496        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
000052  894d              LDRH     r5,[r1,#0xa]
000054  f64f76ff          MOV      r6,#0xffff
000058  ea062505          AND      r5,r6,r5,LSL #8
00005c  432a              ORRS     r2,r2,r5
;;;497        /* Reset the Output N State */
;;;498        tmpccer &= CCER_CC3NE_Reset;
00005e  f64f35ff          MOV      r5,#0xfbff
000062  402a              ANDS     r2,r2,r5
;;;499        
;;;500        /* Set the Output N State */
;;;501        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
000064  888d              LDRH     r5,[r1,#4]
000066  ea062505          AND      r5,r6,r5,LSL #8
00006a  432a              ORRS     r2,r2,r5
;;;502        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;503        tmpcr2 &= CR2_OIS3_Reset;
00006c  f64675ff          MOV      r5,#0x6fff
000070  402b              ANDS     r3,r3,r5
;;;504        tmpcr2 &= CR2_OIS3N_Reset;
000072  f64575ff          MOV      r5,#0x5fff
000076  402b              ANDS     r3,r3,r5
;;;505        /* Set the Output Idle state */
;;;506        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
000078  898d              LDRH     r5,[r1,#0xc]
00007a  ea061505          AND      r5,r6,r5,LSL #4
00007e  432b              ORRS     r3,r3,r5
;;;507        /* Set the Output N Idle state */
;;;508        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
000080  89cd              LDRH     r5,[r1,#0xe]
000082  ea061505          AND      r5,r6,r5,LSL #4
000086  432b              ORRS     r3,r3,r5
                  |L56.136|
;;;509      }
;;;510      /* Write to TIMx CR2 */
;;;511      TIMx->CR2 = tmpcr2;
000088  8083              STRH     r3,[r0,#4]
;;;512      
;;;513      /* Write to TIMx CCMR2 */
;;;514      TIMx->CCMR2 = tmpccmrx;
00008a  8384              STRH     r4,[r0,#0x1c]
;;;515      
;;;516      /* Write to TIMx CCER */
;;;517      TIMx->CCER = tmpccer;
00008c  8402              STRH     r2,[r0,#0x20]
;;;518    }
00008e  bd70              POP      {r4-r6,pc}
;;;519    
                          ENDP

                  |L56.144|
                          DCD      0x40012c00
                  |L56.148|
                          DCD      0x40013400

                          AREA ||i.TIM_OC3NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3NPolarityConfig PROC
;;;1945     */
;;;1946   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;1947   {
;;;1948     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1949    
;;;1950     /* Check the parameters */
;;;1951     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1952     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1953       
;;;1954     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1955     /* Set or Reset the CC3NP Bit */
;;;1956     tmpccer &= CCER_CC3NP_Reset;
000006  f24f73ff          MOV      r3,#0xf7ff
00000a  4019              ANDS     r1,r1,r3
;;;1957     tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1958     /* Write to TIMx CCER register */
;;;1959     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;1960   }
000018  4770              BX       lr
;;;1961   
                          ENDP


                          AREA ||i.TIM_OC3PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PolarityConfig PROC
;;;1922     */
;;;1923   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1924   {
;;;1925     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1926     /* Check the parameters */
;;;1927     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1928     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1929     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1930     /* Set or Reset the CC3P Bit */
;;;1931     tmpccer &= CCER_CC3P_Reset;
000006  f64f53ff          MOV      r3,#0xfdff
00000a  4019              ANDS     r1,r1,r3
;;;1932     tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1933     /* Write to TIMx CCER register */
;;;1934     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;1935   }
000018  4770              BX       lr
;;;1936   
                          ENDP


                          AREA ||i.TIM_OC3PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PreloadConfig PROC
;;;1571     */
;;;1572   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1573   {
;;;1574     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1575     /* Check the parameters */
;;;1576     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1577     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1578     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1579     /* Reset the OC3PE Bit */
;;;1580     tmpccmr2 &= CCMR_OC13PE_Reset;
000006  f64f73f7          MOV      r3,#0xfff7
00000a  4019              ANDS     r1,r1,r3
;;;1581     /* Enable or Disable the Output Compare Preload feature */
;;;1582     tmpccmr2 |= TIM_OCPreload;
00000c  4311              ORRS     r1,r1,r2
;;;1583     /* Write to TIMx CCMR2 register */
;;;1584     TIMx->CCMR2 = tmpccmr2;
00000e  8381              STRH     r1,[r0,#0x1c]
;;;1585   }
000010  4770              BX       lr
;;;1586   
                          ENDP


                          AREA ||i.TIM_OC4FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4FastConfig PROC
;;;1700     */
;;;1701   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1702   {
;;;1703     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1704     /* Check the parameters */
;;;1705     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1706     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1707     /* Get the TIMx CCMR2 register value */
;;;1708     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1709     /* Reset the OC4FE Bit */
;;;1710     tmpccmr2 &= CCMR_OC24FE_Reset;
000006  f64f33ff          MOV      r3,#0xfbff
00000a  4019              ANDS     r1,r1,r3
;;;1711     /* Enable or Disable the Output Compare Fast Bit */
;;;1712     tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1713     /* Write to TIMx CCMR2 */
;;;1714     TIMx->CCMR2 = tmpccmr2;
000016  8381              STRH     r1,[r0,#0x1c]
;;;1715   }
000018  4770              BX       lr
;;;1716   
                          ENDP


                          AREA ||i.TIM_OC4Init||, CODE, READONLY, ALIGN=2

                  TIM_OC4Init PROC
;;;529      */
;;;530    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;531    {
;;;532      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;533       
;;;534      /* Check the parameters */
;;;535      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;536      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;537      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;538      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;539      /* Disable the Channel 2: Reset the CC4E Bit */
;;;540      TIMx->CCER &= CCER_CC4E_Reset;
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  f64e76ff          MOV      r6,#0xefff
00000e  4035              ANDS     r5,r5,r6
000010  8405              STRH     r5,[r0,#0x20]
;;;541      
;;;542      /* Get the TIMx CCER register value */
;;;543      tmpccer = TIMx->CCER;
000012  8c02              LDRH     r2,[r0,#0x20]
;;;544      /* Get the TIMx CR2 register value */
;;;545      tmpcr2 =  TIMx->CR2;
000014  8883              LDRH     r3,[r0,#4]
;;;546      
;;;547      /* Get the TIMx CCMR2 register value */
;;;548      tmpccmrx = TIMx->CCMR2;
000016  8b84              LDRH     r4,[r0,#0x1c]
;;;549        
;;;550      /* Reset the Output Compare Mode Bits */
;;;551      tmpccmrx &= CCMR_OC24M_Mask;
000018  f64875ff          MOV      r5,#0x8fff
00001c  402c              ANDS     r4,r4,r5
;;;552      
;;;553      /* Select the Output Compare Mode */
;;;554      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
00001e  880d              LDRH     r5,[r1,#0]
000020  f64f76ff          MOV      r6,#0xffff
000024  ea062505          AND      r5,r6,r5,LSL #8
000028  432c              ORRS     r4,r4,r5
;;;555      
;;;556      /* Reset the Output Polarity level */
;;;557      tmpccer &= CCER_CC4P_Reset;
00002a  f64d75ff          MOV      r5,#0xdfff
00002e  402a              ANDS     r2,r2,r5
;;;558      /* Set the Output Compare Polarity */
;;;559      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
000030  890d              LDRH     r5,[r1,#8]
000032  ea063505          AND      r5,r6,r5,LSL #12
000036  432a              ORRS     r2,r2,r5
;;;560      
;;;561      /* Set the Output State */
;;;562      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
000038  884d              LDRH     r5,[r1,#2]
00003a  ea063505          AND      r5,r6,r5,LSL #12
00003e  432a              ORRS     r2,r2,r5
;;;563      
;;;564      /* Set the Capture Compare Register value */
;;;565      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
000040  88cd              LDRH     r5,[r1,#6]
000042  f8a05040          STRH     r5,[r0,#0x40]
;;;566      
;;;567      if((*(uint32_t*)&TIMx == TIM1_BASE) || (*(uint32_t*)&TIMx == TIM8_BASE))
000046  4d09              LDR      r5,|L61.108|
000048  42a8              CMP      r0,r5
00004a  d002              BEQ      |L61.82|
00004c  4d08              LDR      r5,|L61.112|
00004e  42a8              CMP      r0,r5
000050  d107              BNE      |L61.98|
                  |L61.82|
;;;568      {
;;;569        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;570        /* Reset the Ouput Compare IDLE State */
;;;571        tmpcr2 &= CR2_OIS4_Reset;
000052  f3c3030d          UBFX     r3,r3,#0,#14
;;;572        /* Set the Output Idle state */
;;;573        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
000056  898d              LDRH     r5,[r1,#0xc]
000058  f64f76ff          MOV      r6,#0xffff
00005c  ea061585          AND      r5,r6,r5,LSL #6
000060  432b              ORRS     r3,r3,r5
                  |L61.98|
;;;574      }
;;;575      /* Write to TIMx CR2 */
;;;576      TIMx->CR2 = tmpcr2;
000062  8083              STRH     r3,[r0,#4]
;;;577      
;;;578      /* Write to TIMx CCMR2 */  
;;;579      TIMx->CCMR2 = tmpccmrx;
000064  8384              STRH     r4,[r0,#0x1c]
;;;580      
;;;581      /* Write to TIMx CCER */
;;;582      TIMx->CCER = tmpccer;
000066  8402              STRH     r2,[r0,#0x20]
;;;583    }
000068  bd70              POP      {r4-r6,pc}
;;;584    
                          ENDP

00006a  0000              DCW      0x0000
                  |L61.108|
                          DCD      0x40012c00
                  |L61.112|
                          DCD      0x40013400

                          AREA ||i.TIM_OC4PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PolarityConfig PROC
;;;1971     */
;;;1972   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1973   {
;;;1974     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1975     /* Check the parameters */
;;;1976     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1977     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1978     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1979     /* Set or Reset the CC4P Bit */
;;;1980     tmpccer &= CCER_CC4P_Reset;
000006  f64d73ff          MOV      r3,#0xdfff
00000a  4019              ANDS     r1,r1,r3
;;;1981     tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea033302          AND      r3,r3,r2,LSL #12
000014  4319              ORRS     r1,r1,r3
;;;1982     /* Write to TIMx CCER register */
;;;1983     TIMx->CCER = tmpccer;
000016  8401              STRH     r1,[r0,#0x20]
;;;1984   }
000018  4770              BX       lr
;;;1985   
                          ENDP


                          AREA ||i.TIM_OC4PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PreloadConfig PROC
;;;1597     */
;;;1598   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1599   {
;;;1600     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1601     /* Check the parameters */
;;;1602     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1603     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1604     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1605     /* Reset the OC4PE Bit */
;;;1606     tmpccmr2 &= CCMR_OC24PE_Reset;
000006  f24f73ff          MOV      r3,#0xf7ff
00000a  4019              ANDS     r1,r1,r3
;;;1607     /* Enable or Disable the Output Compare Preload feature */
;;;1608     tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032302          AND      r3,r3,r2,LSL #8
000014  4319              ORRS     r1,r1,r3
;;;1609     /* Write to TIMx CCMR2 register */
;;;1610     TIMx->CCMR2 = tmpccmr2;
000016  8381              STRH     r1,[r0,#0x1c]
;;;1611   }
000018  4770              BX       lr
;;;1612   
                          ENDP


                          AREA ||i.TIM_OCStructInit||, CODE, READONLY, ALIGN=1

                  TIM_OCStructInit PROC
;;;752      */
;;;753    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  2100              MOVS     r1,#0
;;;754    {
;;;755      /* Set the default configuration */
;;;756      TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
000002  8001              STRH     r1,[r0,#0]
;;;757      TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;758      TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
000006  8081              STRH     r1,[r0,#4]
;;;759      TIM_OCInitStruct->TIM_Pulse = 0x0000;
000008  80c1              STRH     r1,[r0,#6]
;;;760      TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
00000a  8101              STRH     r1,[r0,#8]
;;;761      TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
00000c  8141              STRH     r1,[r0,#0xa]
;;;762      TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
00000e  8181              STRH     r1,[r0,#0xc]
;;;763      TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
000010  81c1              STRH     r1,[r0,#0xe]
;;;764    }
000012  4770              BX       lr
;;;765    
                          ENDP


                          AREA ||i.TIM_PWMIConfig||, CODE, READONLY, ALIGN=1

                  TIM_PWMIConfig PROC
;;;653      */
;;;654    void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;655    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;656      uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
000008  2600              MOVS     r6,#0
;;;657      uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
00000a  2701              MOVS     r7,#1
;;;658      /* Check the parameters */
;;;659      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;660      /* Select the Opposite Input Polarity */
;;;661      if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
00000c  8860              LDRH     r0,[r4,#2]
00000e  b908              CBNZ     r0,|L65.20|
;;;662      {
;;;663        icoppositepolarity = TIM_ICPolarity_Falling;
000010  2602              MOVS     r6,#2
000012  e000              B        |L65.22|
                  |L65.20|
;;;664      }
;;;665      else
;;;666      {
;;;667        icoppositepolarity = TIM_ICPolarity_Rising;
000014  2600              MOVS     r6,#0
                  |L65.22|
;;;668      }
;;;669      /* Select the Opposite Input */
;;;670      if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
000016  88a0              LDRH     r0,[r4,#4]
000018  2801              CMP      r0,#1
00001a  d101              BNE      |L65.32|
;;;671      {
;;;672        icoppositeselection = TIM_ICSelection_IndirectTI;
00001c  2702              MOVS     r7,#2
00001e  e000              B        |L65.34|
                  |L65.32|
;;;673      }
;;;674      else
;;;675      {
;;;676        icoppositeselection = TIM_ICSelection_DirectTI;
000020  2701              MOVS     r7,#1
                  |L65.34|
;;;677      }
;;;678      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000022  8820              LDRH     r0,[r4,#0]
000024  b9a0              CBNZ     r0,|L65.80|
;;;679      {
;;;680        /* TI1 Configuration */
;;;681        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000026  8923              LDRH     r3,[r4,#8]
000028  88a2              LDRH     r2,[r4,#4]
00002a  8861              LDRH     r1,[r4,#2]
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       TI1_Config
;;;682                   TIM_ICInitStruct->TIM_ICFilter);
;;;683        /* Set the Input Capture Prescaler value */
;;;684        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000032  88e1              LDRH     r1,[r4,#6]
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       TIM_SetIC1Prescaler
;;;685        /* TI2 Configuration */
;;;686        TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
00003a  8923              LDRH     r3,[r4,#8]
00003c  463a              MOV      r2,r7
00003e  4631              MOV      r1,r6
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       TI2_Config
;;;687        /* Set the Input Capture Prescaler value */
;;;688        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000046  88e1              LDRH     r1,[r4,#6]
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       TIM_SetIC2Prescaler
00004e  e013              B        |L65.120|
                  |L65.80|
;;;689      }
;;;690      else
;;;691      { 
;;;692        /* TI2 Configuration */
;;;693        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000050  8923              LDRH     r3,[r4,#8]
000052  88a2              LDRH     r2,[r4,#4]
000054  8861              LDRH     r1,[r4,#2]
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       TI2_Config
;;;694                   TIM_ICInitStruct->TIM_ICFilter);
;;;695        /* Set the Input Capture Prescaler value */
;;;696        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00005c  88e1              LDRH     r1,[r4,#6]
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       TIM_SetIC2Prescaler
;;;697        /* TI1 Configuration */
;;;698        TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
000064  8923              LDRH     r3,[r4,#8]
000066  463a              MOV      r2,r7
000068  4631              MOV      r1,r6
00006a  4628              MOV      r0,r5
00006c  f7fffffe          BL       TI1_Config
;;;699        /* Set the Input Capture Prescaler value */
;;;700        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000070  88e1              LDRH     r1,[r4,#6]
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       TIM_SetIC1Prescaler
                  |L65.120|
;;;701      }
;;;702    }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;703    
                          ENDP


                          AREA ||i.TIM_PrescalerConfig||, CODE, READONLY, ALIGN=1

                  TIM_PrescalerConfig PROC
;;;1173     */
;;;1174   void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
000000  8501              STRH     r1,[r0,#0x28]
;;;1175   {
;;;1176     /* Check the parameters */
;;;1177     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1178     assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;1179     /* Set the Prescaler value */
;;;1180     TIMx->PSC = Prescaler;
;;;1181     /* Set or reset the UG Bit */
;;;1182     TIMx->EGR = TIM_PSCReloadMode;
000002  8282              STRH     r2,[r0,#0x14]
;;;1183   }
000004  4770              BX       lr
;;;1184   
                          ENDP


                          AREA ||i.TIM_SelectCCDMA||, CODE, READONLY, ALIGN=1

                  TIM_SelectCCDMA PROC
;;;1466     */
;;;1467   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L67.12|
;;;1468   {
;;;1469     /* Check the parameters */
;;;1470     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1471     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1472     if (NewState != DISABLE)
;;;1473     {
;;;1474       /* Set the CCDS Bit */
;;;1475       TIMx->CR2 |= CR2_CCDS_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420208          ORR      r2,r2,#8
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L67.22|
                  |L67.12|
;;;1476     }
;;;1477     else
;;;1478     {
;;;1479       /* Reset the CCDS Bit */
;;;1480       TIMx->CR2 &= CR2_CCDS_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f73f7          MOV      r3,#0xfff7
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L67.22|
;;;1481     }
;;;1482   }
000016  4770              BX       lr
;;;1483   
                          ENDP


                          AREA ||i.TIM_SelectCOM||, CODE, READONLY, ALIGN=1

                  TIM_SelectCOM PROC
;;;1441     */
;;;1442   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L68.12|
;;;1443   {
;;;1444     /* Check the parameters */
;;;1445     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1446     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1447     if (NewState != DISABLE)
;;;1448     {
;;;1449       /* Set the COM Bit */
;;;1450       TIMx->CR2 |= CR2_CCUS_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420204          ORR      r2,r2,#4
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L68.22|
                  |L68.12|
;;;1451     }
;;;1452     else
;;;1453     {
;;;1454       /* Reset the COM Bit */
;;;1455       TIMx->CR2 &= CR2_CCUS_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f73fb          MOV      r3,#0xfffb
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L68.22|
;;;1456     }
;;;1457   }
000016  4770              BX       lr
;;;1458   
                          ENDP


                          AREA ||i.TIM_SelectHallSensor||, CODE, READONLY, ALIGN=1

                  TIM_SelectHallSensor PROC
;;;2143     */
;;;2144   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L69.12|
;;;2145   {
;;;2146     /* Check the parameters */
;;;2147     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2148     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2149     if (NewState != DISABLE)
;;;2150     {
;;;2151       /* Set the TI1S Bit */
;;;2152       TIMx->CR2 |= CR2_TI1S_Set;
000002  8882              LDRH     r2,[r0,#4]
000004  f0420280          ORR      r2,r2,#0x80
000008  8082              STRH     r2,[r0,#4]
00000a  e004              B        |L69.22|
                  |L69.12|
;;;2153     }
;;;2154     else
;;;2155     {
;;;2156       /* Reset the TI1S Bit */
;;;2157       TIMx->CR2 &= CR2_TI1S_Reset;
00000c  8882              LDRH     r2,[r0,#4]
00000e  f64f737f          MOV      r3,#0xff7f
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L69.22|
;;;2158     }
;;;2159   }
000016  4770              BX       lr
;;;2160   
                          ENDP


                          AREA ||i.TIM_SelectInputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectInputTrigger PROC
;;;1228     */
;;;1229   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  460a              MOV      r2,r1
;;;1230   {
;;;1231     uint16_t tmpsmcr = 0;
000002  2100              MOVS     r1,#0
;;;1232     /* Check the parameters */
;;;1233     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1234     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1235     /* Get the TIMx SMCR register value */
;;;1236     tmpsmcr = TIMx->SMCR;
000004  8901              LDRH     r1,[r0,#8]
;;;1237     /* Reset the TS Bits */
;;;1238     tmpsmcr &= SMCR_TS_Mask;
000006  f64f738f          MOV      r3,#0xff8f
00000a  4019              ANDS     r1,r1,r3
;;;1239     /* Set the Input Trigger source */
;;;1240     tmpsmcr |= TIM_InputTriggerSource;
00000c  4311              ORRS     r1,r1,r2
;;;1241     /* Write to TIMx SMCR */
;;;1242     TIMx->SMCR = tmpsmcr;
00000e  8101              STRH     r1,[r0,#8]
;;;1243   }
000010  4770              BX       lr
;;;1244   
                          ENDP


                          AREA ||i.TIM_SelectMasterSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectMasterSlaveMode PROC
;;;2244     */
;;;2245   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2246   {
;;;2247     /* Check the parameters */
;;;2248     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2249     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2250     /* Reset the MSM Bit */
;;;2251     TIMx->SMCR &= SMCR_MSM_Reset;
000002  f64f737f          MOV      r3,#0xff7f
000006  401a              ANDS     r2,r2,r3
000008  8102              STRH     r2,[r0,#8]
;;;2252     
;;;2253     /* Set or Reset the MSM Bit */
;;;2254     TIMx->SMCR |= TIM_MasterSlaveMode;
00000a  8902              LDRH     r2,[r0,#8]
00000c  430a              ORRS     r2,r2,r1
00000e  8102              STRH     r2,[r0,#8]
;;;2255   }
000010  4770              BX       lr
;;;2256   
                          ENDP


                          AREA ||i.TIM_SelectOCxM||, CODE, READONLY, ALIGN=1

                  TIM_SelectOCxM PROC
;;;2059     */
;;;2060   void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
000000  b530              PUSH     {r4,r5,lr}
;;;2061   {
;;;2062     /* Check the parameters */
;;;2063     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2064     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;2065     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;2066     
;;;2067     /* Disable the Channel: Reset the CCxE Bit */
;;;2068     TIMx->CCER &= (uint16_t)(~((uint16_t)(CCER_CCE_Set << TIM_Channel)));
000002  8c03              LDRH     r3,[r0,#0x20]
000004  2401              MOVS     r4,#1
000006  408c              LSLS     r4,r4,r1
000008  43a3              BICS     r3,r3,r4
00000a  8403              STRH     r3,[r0,#0x20]
;;;2069     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
00000c  b109              CBZ      r1,|L72.18|
00000e  2908              CMP      r1,#8
000010  d118              BNE      |L72.68|
                  |L72.18|
;;;2070     {
;;;2071       /* Reset the OCxM bits in the CCMRx register */
;;;2072       *((__IO uint32_t *)((*(uint32_t*)&TIMx) + CCMR_Offset + (TIM_Channel>>1))) &= CCMR_OC13M_Mask;
000012  f1000318          ADD      r3,r0,#0x18
000016  eb030361          ADD      r3,r3,r1,ASR #1
00001a  681b              LDR      r3,[r3,#0]
00001c  f64f748f          MOV      r4,#0xff8f
000020  4023              ANDS     r3,r3,r4
000022  f1000418          ADD      r4,r0,#0x18
000026  eb040461          ADD      r4,r4,r1,ASR #1
00002a  6023              STR      r3,[r4,#0]
;;;2073      
;;;2074       /* Configure the OCxM bits in the CCMRx register */
;;;2075       *((__IO uint32_t *)((*(uint32_t*)&TIMx) + CCMR_Offset + (TIM_Channel>>1))) |= TIM_OCMode;
00002c  f1000318          ADD      r3,r0,#0x18
000030  eb030361          ADD      r3,r3,r1,ASR #1
000034  681b              LDR      r3,[r3,#0]
000036  4313              ORRS     r3,r3,r2
000038  f1000418          ADD      r4,r0,#0x18
00003c  eb040461          ADD      r4,r4,r1,ASR #1
000040  6023              STR      r3,[r4,#0]
000042  e01f              B        |L72.132|
                  |L72.68|
;;;2076     }
;;;2077     else
;;;2078     {
;;;2079       /* Reset the OCxM bits in the CCMRx register */
;;;2080       *((__IO uint32_t *)((*(uint32_t*)&TIMx) + CCMR_Offset + ((uint16_t)(TIM_Channel - 4)>> 1))) &= CCMR_OC24M_Mask;
000044  1f0b              SUBS     r3,r1,#4
000046  f3c3044e          UBFX     r4,r3,#1,#15
00004a  f1000318          ADD      r3,r0,#0x18
00004e  591b              LDR      r3,[r3,r4]
000050  f64874ff          MOV      r4,#0x8fff
000054  4023              ANDS     r3,r3,r4
000056  1f0c              SUBS     r4,r1,#4
000058  f3c4054e          UBFX     r5,r4,#1,#15
00005c  f1000418          ADD      r4,r0,#0x18
000060  5163              STR      r3,[r4,r5]
;;;2081       
;;;2082       /* Configure the OCxM bits in the CCMRx register */
;;;2083       *((__IO uint32_t *)((*(uint32_t*)&TIMx) + CCMR_Offset + ((uint16_t)(TIM_Channel - 4)>> 1))) |= (uint16_t)(TIM_OCMode << 8);
000062  1f0b              SUBS     r3,r1,#4
000064  f3c3044e          UBFX     r4,r3,#1,#15
000068  f1000318          ADD      r3,r0,#0x18
00006c  591b              LDR      r3,[r3,r4]
00006e  f64f74ff          MOV      r4,#0xffff
000072  ea042402          AND      r4,r4,r2,LSL #8
000076  4323              ORRS     r3,r3,r4
000078  1f0c              SUBS     r4,r1,#4
00007a  f3c4054e          UBFX     r5,r4,#1,#15
00007e  f1000418          ADD      r4,r0,#0x18
000082  5163              STR      r3,[r4,r5]
                  |L72.132|
;;;2084     }
;;;2085   }
000084  bd30              POP      {r4,r5,pc}
;;;2086   
                          ENDP


                          AREA ||i.TIM_SelectOnePulseMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectOnePulseMode PROC
;;;2169     */
;;;2170   void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
000000  8802              LDRH     r2,[r0,#0]
;;;2171   {
;;;2172     /* Check the parameters */
;;;2173     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2174     assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;2175     /* Reset the OPM Bit */
;;;2176     TIMx->CR1 &= CR1_OPM_Reset;
000002  f24033f7          MOV      r3,#0x3f7
000006  401a              ANDS     r2,r2,r3
000008  8002              STRH     r2,[r0,#0]
;;;2177     /* Configure the OPM Mode */
;;;2178     TIMx->CR1 |= TIM_OPMode;
00000a  8802              LDRH     r2,[r0,#0]
00000c  430a              ORRS     r2,r2,r1
00000e  8002              STRH     r2,[r0,#0]
;;;2179   }
000010  4770              BX       lr
;;;2180   
                          ENDP


                          AREA ||i.TIM_SelectOutputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectOutputTrigger PROC
;;;2198     */
;;;2199   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
000000  8882              LDRH     r2,[r0,#4]
;;;2200   {
;;;2201     /* Check the parameters */
;;;2202     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2203     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2204     assert_param(IS_TIM_PERIPH_TRGO(TIMx, TIM_TRGOSource));
;;;2205     /* Reset the MMS Bits */
;;;2206     TIMx->CR2 &= CR2_MMS_Mask;
000002  f64f738f          MOV      r3,#0xff8f
000006  401a              ANDS     r2,r2,r3
000008  8082              STRH     r2,[r0,#4]
;;;2207     /* Select the TRGO source */
;;;2208     TIMx->CR2 |=  TIM_TRGOSource;
00000a  8882              LDRH     r2,[r0,#4]
00000c  430a              ORRS     r2,r2,r1
00000e  8082              STRH     r2,[r0,#4]
;;;2209   }
000010  4770              BX       lr
;;;2210   
                          ENDP


                          AREA ||i.TIM_SelectSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectSlaveMode PROC
;;;2222     */
;;;2223   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2224   {
;;;2225     /* Check the parameters */
;;;2226     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2227     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2228     /* Reset the SMS Bits */
;;;2229     TIMx->SMCR &= SMCR_SMS_Mask;
000002  f64f73f8          MOV      r3,#0xfff8
000006  401a              ANDS     r2,r2,r3
000008  8102              STRH     r2,[r0,#8]
;;;2230     /* Select the Slave Mode */
;;;2231     TIMx->SMCR |= TIM_SlaveMode;
00000a  8902              LDRH     r2,[r0,#8]
00000c  430a              ORRS     r2,r2,r1
00000e  8102              STRH     r2,[r0,#8]
;;;2232   }
000010  4770              BX       lr
;;;2233   
                          ENDP


                          AREA ||i.TIM_SetAutoreload||, CODE, READONLY, ALIGN=1

                  TIM_SetAutoreload PROC
;;;2276     */
;;;2277   void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload)
000000  8581              STRH     r1,[r0,#0x2c]
;;;2278   {
;;;2279     /* Check the parameters */
;;;2280     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2281     /* Set the Autoreload Register value */
;;;2282     TIMx->ARR = Autoreload;
;;;2283   }
000002  4770              BX       lr
;;;2284   
                          ENDP


                          AREA ||i.TIM_SetClockDivision||, CODE, READONLY, ALIGN=1

                  TIM_SetClockDivision PROC
;;;2451     */
;;;2452   void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
000000  8802              LDRH     r2,[r0,#0]
;;;2453   {
;;;2454     /* Check the parameters */
;;;2455     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2456     assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;2457     /* Reset the CKD Bits */
;;;2458     TIMx->CR1 &= CR1_CKD_Mask;
000002  b2d2              UXTB     r2,r2
000004  8002              STRH     r2,[r0,#0]
;;;2459     /* Set the CKD value */
;;;2460     TIMx->CR1 |= TIM_CKD;
000006  8802              LDRH     r2,[r0,#0]
000008  430a              ORRS     r2,r2,r1
00000a  8002              STRH     r2,[r0,#0]
;;;2461   }
00000c  4770              BX       lr
;;;2462   
                          ENDP


                          AREA ||i.TIM_SetCompare1||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare1 PROC
;;;2291     */
;;;2292   void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1)
000000  8681              STRH     r1,[r0,#0x34]
;;;2293   {
;;;2294     /* Check the parameters */
;;;2295     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2296     /* Set the Capture Compare1 Register value */
;;;2297     TIMx->CCR1 = Compare1;
;;;2298   }
000002  4770              BX       lr
;;;2299   
                          ENDP


                          AREA ||i.TIM_SetCompare2||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare2 PROC
;;;2306     */
;;;2307   void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2)
000000  8701              STRH     r1,[r0,#0x38]
;;;2308   {
;;;2309     /* Check the parameters */
;;;2310     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2311     /* Set the Capture Compare2 Register value */
;;;2312     TIMx->CCR2 = Compare2;
;;;2313   }
000002  4770              BX       lr
;;;2314   
                          ENDP


                          AREA ||i.TIM_SetCompare3||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare3 PROC
;;;2321     */
;;;2322   void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3)
000000  8781              STRH     r1,[r0,#0x3c]
;;;2323   {
;;;2324     /* Check the parameters */
;;;2325     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2326     /* Set the Capture Compare3 Register value */
;;;2327     TIMx->CCR3 = Compare3;
;;;2328   }
000002  4770              BX       lr
;;;2329   
                          ENDP


                          AREA ||i.TIM_SetCompare4||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare4 PROC
;;;2336     */
;;;2337   void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4)
000000  f8a01040          STRH     r1,[r0,#0x40]
;;;2338   {
;;;2339     /* Check the parameters */
;;;2340     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2341     /* Set the Capture Compare4 Register value */
;;;2342     TIMx->CCR4 = Compare4;
;;;2343   }
000004  4770              BX       lr
;;;2344   
                          ENDP


                          AREA ||i.TIM_SetCounter||, CODE, READONLY, ALIGN=1

                  TIM_SetCounter PROC
;;;2262     */
;;;2263   void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter)
000000  8481              STRH     r1,[r0,#0x24]
;;;2264   {
;;;2265     /* Check the parameters */
;;;2266     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2267     /* Set the Counter Register value */
;;;2268     TIMx->CNT = Counter;
;;;2269   }
000002  4770              BX       lr
;;;2270   
                          ENDP


                          AREA ||i.TIM_SetIC1Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC1Prescaler PROC
;;;2357     */
;;;2358   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2359   {
;;;2360     /* Check the parameters */
;;;2361     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2362     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2363     /* Reset the IC1PSC Bits */
;;;2364     TIMx->CCMR1 &= CCMR_IC13PSC_Mask;
000002  f64f73f3          MOV      r3,#0xfff3
000006  401a              ANDS     r2,r2,r3
000008  8302              STRH     r2,[r0,#0x18]
;;;2365     /* Set the IC1PSC value */
;;;2366     TIMx->CCMR1 |= TIM_ICPSC;
00000a  8b02              LDRH     r2,[r0,#0x18]
00000c  430a              ORRS     r2,r2,r1
00000e  8302              STRH     r2,[r0,#0x18]
;;;2367   }
000010  4770              BX       lr
;;;2368   
                          ENDP


                          AREA ||i.TIM_SetIC2Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC2Prescaler PROC
;;;2381     */
;;;2382   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2383   {
;;;2384     /* Check the parameters */
;;;2385     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2386     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2387     /* Reset the IC2PSC Bits */
;;;2388     TIMx->CCMR1 &= CCMR_IC24PSC_Mask;
000002  f24f33ff          MOV      r3,#0xf3ff
000006  401a              ANDS     r2,r2,r3
000008  8302              STRH     r2,[r0,#0x18]
;;;2389     /* Set the IC2PSC value */
;;;2390     TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
00000a  8b02              LDRH     r2,[r0,#0x18]
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032301          AND      r3,r3,r1,LSL #8
000014  431a              ORRS     r2,r2,r3
000016  8302              STRH     r2,[r0,#0x18]
;;;2391   }
000018  4770              BX       lr
;;;2392   
                          ENDP


                          AREA ||i.TIM_SetIC3Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC3Prescaler PROC
;;;2405     */
;;;2406   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2407   {
;;;2408     /* Check the parameters */
;;;2409     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2410     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2411     /* Reset the IC3PSC Bits */
;;;2412     TIMx->CCMR2 &= CCMR_IC13PSC_Mask;
000002  f64f73f3          MOV      r3,#0xfff3
000006  401a              ANDS     r2,r2,r3
000008  8382              STRH     r2,[r0,#0x1c]
;;;2413     /* Set the IC3PSC value */
;;;2414     TIMx->CCMR2 |= TIM_ICPSC;
00000a  8b82              LDRH     r2,[r0,#0x1c]
00000c  430a              ORRS     r2,r2,r1
00000e  8382              STRH     r2,[r0,#0x1c]
;;;2415   }
000010  4770              BX       lr
;;;2416   
                          ENDP


                          AREA ||i.TIM_SetIC4Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC4Prescaler PROC
;;;2429     */
;;;2430   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2431   {  
;;;2432     /* Check the parameters */
;;;2433     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2434     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2435     /* Reset the IC4PSC Bits */
;;;2436     TIMx->CCMR2 &= CCMR_IC24PSC_Mask;
000002  f24f33ff          MOV      r3,#0xf3ff
000006  401a              ANDS     r2,r2,r3
000008  8382              STRH     r2,[r0,#0x1c]
;;;2437     /* Set the IC4PSC value */
;;;2438     TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
00000a  8b82              LDRH     r2,[r0,#0x1c]
00000c  f64f73ff          MOV      r3,#0xffff
000010  ea032301          AND      r3,r3,r1,LSL #8
000014  431a              ORRS     r2,r2,r3
000016  8382              STRH     r2,[r0,#0x1c]
;;;2439   }
000018  4770              BX       lr
;;;2440   
                          ENDP


                          AREA ||i.TIM_TIxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_TIxExternalClockConfig PROC
;;;1027     */
;;;1028   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1029                                   uint16_t TIM_ICPolarity, uint16_t ICFilter)
;;;1030   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1031     /* Check the parameters */
;;;1032     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1033     assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
;;;1034     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;1035     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;1036     /* Configure the Timer Input Clock Source */
;;;1037     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
00000c  2d60              CMP      r5,#0x60
00000e  d106              BNE      |L87.30|
;;;1038     {
;;;1039       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
000010  463b              MOV      r3,r7
000012  2201              MOVS     r2,#1
000014  4631              MOV      r1,r6
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       TI2_Config
00001c  e005              B        |L87.42|
                  |L87.30|
;;;1040     }
;;;1041     else
;;;1042     {
;;;1043       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
00001e  463b              MOV      r3,r7
000020  2201              MOVS     r2,#1
000022  4631              MOV      r1,r6
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       TI1_Config
                  |L87.42|
;;;1044     }
;;;1045     /* Select the Trigger source */
;;;1046     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
00002a  4629              MOV      r1,r5
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       TIM_SelectInputTrigger
;;;1047     /* Select the External clock mode1 */
;;;1048     TIMx->SMCR |= TIM_SlaveMode_External1;
000032  8920              LDRH     r0,[r4,#8]
000034  f0400007          ORR      r0,r0,#7
000038  8120              STRH     r0,[r4,#8]
;;;1049   }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;1050   
                          ENDP


                          AREA ||i.TIM_TimeBaseInit||, CODE, READONLY, ALIGN=2

                  TIM_TimeBaseInit PROC
;;;249      */
;;;250    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  8802              LDRH     r2,[r0,#0]
;;;251    {
;;;252      /* Check the parameters */
;;;253      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;254      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;255      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;256      /* Select the Counter Mode and set the clock division */
;;;257      TIMx->CR1 &= CR1_CKD_Mask & CR1_CounterMode_Mask;
000002  f002028f          AND      r2,r2,#0x8f
000006  8002              STRH     r2,[r0,#0]
;;;258      TIMx->CR1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision |
000008  88ca              LDRH     r2,[r1,#6]
00000a  884b              LDRH     r3,[r1,#2]
00000c  431a              ORRS     r2,r2,r3
00000e  8803              LDRH     r3,[r0,#0]
000010  431a              ORRS     r2,r2,r3
000012  8002              STRH     r2,[r0,#0]
;;;259                    TIM_TimeBaseInitStruct->TIM_CounterMode;
;;;260      
;;;261      /* Set the Autoreload value */
;;;262      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
000014  888a              LDRH     r2,[r1,#4]
000016  8582              STRH     r2,[r0,#0x2c]
;;;263     
;;;264      /* Set the Prescaler value */
;;;265      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
000018  880a              LDRH     r2,[r1,#0]
00001a  8502              STRH     r2,[r0,#0x28]
;;;266        
;;;267      if (((*(uint32_t*)&TIMx) == TIM1_BASE) || ((*(uint32_t*)&TIMx) == TIM8_BASE))  
00001c  4a05              LDR      r2,|L88.52|
00001e  4290              CMP      r0,r2
000020  d002              BEQ      |L88.40|
000022  4a05              LDR      r2,|L88.56|
000024  4290              CMP      r0,r2
000026  d101              BNE      |L88.44|
                  |L88.40|
;;;268      {
;;;269        /* Set the Repetition Counter value */
;;;270        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
000028  7a0a              LDRB     r2,[r1,#8]
00002a  8602              STRH     r2,[r0,#0x30]
                  |L88.44|
;;;271      }
;;;272    
;;;273      /* Generate an update event to reload the Prescaler value immediatly */
;;;274      TIMx->EGR = TIM_PSCReloadMode_Immediate;          
00002c  2201              MOVS     r2,#1
00002e  8282              STRH     r2,[r0,#0x14]
;;;275    }
000030  4770              BX       lr
;;;276    
                          ENDP

000032  0000              DCW      0x0000
                  |L88.52|
                          DCD      0x40012c00
                  |L88.56|
                          DCD      0x40013400

                          AREA ||i.TIM_TimeBaseStructInit||, CODE, READONLY, ALIGN=1

                  TIM_TimeBaseStructInit PROC
;;;736      */
;;;737    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  f64f71ff          MOV      r1,#0xffff
;;;738    {
;;;739      /* Set the default configuration */
;;;740      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
000004  8081              STRH     r1,[r0,#4]
;;;741      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
000006  2100              MOVS     r1,#0
000008  8001              STRH     r1,[r0,#0]
;;;742      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
00000a  80c1              STRH     r1,[r0,#6]
;;;743      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
00000c  8041              STRH     r1,[r0,#2]
;;;744      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
00000e  7201              STRB     r1,[r0,#8]
;;;745    }
000010  4770              BX       lr
;;;746    
                          ENDP


                          AREA ||i.TIM_UpdateDisableConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateDisableConfig PROC
;;;2093     */
;;;2094   void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  b121              CBZ      r1,|L90.12|
;;;2095   {
;;;2096     /* Check the parameters */
;;;2097     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2098     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2099     if (NewState != DISABLE)
;;;2100     {
;;;2101       /* Set the Update Disable Bit */
;;;2102       TIMx->CR1 |= CR1_UDIS_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420202          ORR      r2,r2,#2
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L90.22|
                  |L90.12|
;;;2103     }
;;;2104     else
;;;2105     {
;;;2106       /* Reset the Update Disable Bit */
;;;2107       TIMx->CR1 &= CR1_UDIS_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f24033fd          MOV      r3,#0x3fd
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L90.22|
;;;2108     }
;;;2109   }
000016  4770              BX       lr
;;;2110   
                          ENDP


                          AREA ||i.TIM_UpdateRequestConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateRequestConfig PROC
;;;2119     */
;;;2120   void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
000000  b121              CBZ      r1,|L91.12|
;;;2121   {
;;;2122     /* Check the parameters */
;;;2123     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2124     assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;2125     if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;2126     {
;;;2127       /* Set the URS Bit */
;;;2128       TIMx->CR1 |= CR1_URS_Set;
000002  8802              LDRH     r2,[r0,#0]
000004  f0420204          ORR      r2,r2,#4
000008  8002              STRH     r2,[r0,#0]
00000a  e004              B        |L91.22|
                  |L91.12|
;;;2129     }
;;;2130     else
;;;2131     {
;;;2132       /* Reset the URS Bit */
;;;2133       TIMx->CR1 &= CR1_URS_Reset;
00000c  8802              LDRH     r2,[r0,#0]
00000e  f24033fb          MOV      r3,#0x3fb
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L91.22|
;;;2134     }
;;;2135   }
000016  4770              BX       lr
;;;2136   
                          ENDP

